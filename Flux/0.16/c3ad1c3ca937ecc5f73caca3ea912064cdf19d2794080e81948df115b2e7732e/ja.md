```
identity_init(size...; gain=1, shift=0) -> Array
identity_init(; kw...) -> Function
```

与えられた `size` の `Array{Float32}` を返し、ほとんどの Flux レイヤーでパラメータとして使用したときにアイデンティティマッピングを生成します。`gain` を使用してアイデンティティを定数でスケールします。

転移学習の文脈でしばしば便利であり、つまり、モデルにより多くの容量を追加したいが、同じマッピングから始めたいときに役立ちます。

以下の動作を持ちます。

  * 1D: `zeros` の `Vector`（アイデンティティバイアスに便利）
  * 2D: アイデンティティ行列（アイデンティティ行列の乗算に便利）
  * 2D 以上: 中心タップ空間フィルタの密なブロック配列（アイデンティティ畳み込みに便利）

いくつかの注意点：

  * この初期化を使用した場合、すべてのレイヤーがアイデンティティマッピングになるわけではありません。例外には再帰的レイヤーや正規化レイヤーが含まれます。
  * アイデンティティマッピングが可能であるためには、レイヤーの `input_size` が `output_size` と等しい必要があります。これが満たされない場合、配列の余分な次元はゼロでパディングされます。
  * 畳み込みレイヤーの場合、上記に加えて、カーネルサイズも奇数でなければならず、出力フィーチャーマップが入力フィーチャーマップと同じサイズになるようにパディングを適用する必要があります。例えば、[`SamePad`](@ref) を使用します。

キーワード `shift`（整数またはタプル）を使用して出力に円形シフトを適用します。これは `Base.circshift(identity_init(size...), shift)` に相当します。

他の初期化子との一貫性のために、オプションの最初の引数として `rng::AbstractRNG` を受け入れます。しかし、結果がランダムでないため、これは無視されます。

# 例

```jldoctest
julia> Flux.identity_init(3,5)
3×5 Matrix{Float32}:
 1.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0

julia> Dense(5 => 3, relu, init=Flux.identity_init)([1,-2,3,-4,5])
3-element Vector{Float32}:
 1.0
 0.0
 3.0

julia> Flux.identity_init(3,3,2; gain=100)
3×3×2 Array{Float32, 3}:
[:, :, 1] =
   0.0  0.0  0.0
 100.0  0.0  0.0
   0.0  0.0  0.0

[:, :, 2] =
 0.0    0.0  0.0
 0.0  100.0  0.0
 0.0    0.0  0.0

julia> x4 = cat([1 2 3; 4 5 6; 7 8 9]; dims=4);

julia> Conv((2,2), 1 => 1, init=Flux.identity_init(gain=10), pad=SamePad())(x4)
3×3×1×1 Array{Float32, 4}:
[:, :, 1, 1] =
 10.0  20.0  30.0
 40.0  50.0  60.0
 70.0  80.0  90.0
```
