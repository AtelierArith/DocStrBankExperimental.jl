```
    (1) randPosDefMat(n::Int;
    <
    df::Int=2,
    eigvalsSNR::Real=10e3 >)

    (2) randPosDefMat(::Type{Complex{T}}, n:: Int;
    < same keyword arguments as in (1) >)

    (3) randPosDefMat(n::Int, k::Int;
    <
    df::Int=2,
    eigvalsSNR::Real=10e3,
    SNR::Real=100,
    commuting=false >)

    (4) randPosDefMat(::Type{Complex{T}}, n::Int, k::Int;
    < same keyword arguments as in (3) >)
```

**alias**: `randP`

Generate

  * (1) one random `Hermitian` positive definite matrix (real) of size $n⋅n$
  * (2) one random `Hermitian` positive definite matrix (complex) of size $n⋅n$
  * (3) an array 1d (of [ℍVector type](@ref)) of $k$ matrices of the kind in (1)
  * (4) an array 1d (of [ℍVector type](@ref)) of $k$ matrices of the kind in (2).

Methods (3) and (4) are **multi-threaded**. See [Threads](@ref).

For (1) and (2) the matrix is generated according to model

$UΛU^H+ηI$,

where $U$ is a random orthogonal (1) or unitary (2) matrix generated by  function `randU`([`randUnitaryMat`](@ref)) and $Λ$, $η$ are a positive definite  diagonal matrix and a non-negative scalar depending on *<optional keywords arguments>*  `df` and `eigvalsSNR` randomly generated calling function  `randΛ`([`randEigvalsMat`](@ref)).

For (3) and (4), if the *<optional keyword argument>* `commuting=true` is passed,  the $k$ matrices are generated according to model

$UΛ_iU^H+ηI,\hspace{8pt}$, for $i$=1:$k$

otherwise they are generated according to model

$(UΛ_iU^H+ηI)+φ(V_iΔ_iV_i^H+ηI),\hspace{8pt}$, for $i$=1:$k$  Eq.[1]

where

  * $U$ and the $V_i$ are random (3) orthogonal/(4) unitary matrices,
  * $Λ_i$ and $Δ_i$ are positive definite diagonal matrices
  * $η$ is a non-negative scalar.

All variables here above are randomly generated as in (1) and (2)

  * $φ$ is adjusted so as to obtain a desired output `SNR` ([signal-to-noise ratio](https://bit.ly/1VvpvnQ)), which is also an

*<optional keywords arguments>*, such as

$SNR=\frac{\displaystyle\sum_{i=1}^{k}\textrm{tr}(UΛ_iU^H+ηI)}{\displaystyle\sum_{i=1}^{k}\textrm{tr}φ(V_iΔ_iV_i^H+ηI)}$.

!!! note "Nota Bene"
    The keyword arguments `SNR` is not expressed in decibels, but as the expected SNR variance ratio. It must be a positive number.


A slightly different version of this model for generating positive definite  matrices has been proposed in (Congedo et *al.*, 2017b)[🎓];  in the model of Eq. [1]

  * $UΛ_iU^H$ is the signal term, where the signal is supposed sharing the same coordinates for all matrices,
  * $φ(V_iΔ_iV_i^H)$ is a structured noise term, which is different for all matrices
  * $ηI$ is a [white noise](https://bit.ly/2TN8472) term, with same variance for all matrices.

**See also**: the aforementioned paper and `randΛ` ([`randEigvalsMat`](@ref)).

**Examples**

```julia
using PosDefManifold
R=randP(10, df=10, eigvalsSNR=1000) # 1 SDP Matrix of size 10x10 #(1)
H=randP(ComplexF64, 5, eigvalsSNR=10) # 1 Hermitian Matrix of size 5x5 # (2)
ℛ=randP(10, 1000, eigvalsSNR=100) # 1000 SPD Matrices of size 10x10 # (3)
using Plots
heatmap(Matrix(ℛ[1]), yflip=true, c=:bluesreds)
ℋ=randP(ComplexF64, 20, 1000) # 1000 Hermitian Matrices of size 20x20 # (4)
```
