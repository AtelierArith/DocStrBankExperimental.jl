```
AbstractVectorOfArray{T, N, A}
```

AbstractVectorOfArrayは、配列の配列および配列の任意の再帰的ネストを単一の配列のようなオブジェクトとして表すオブジェクトです。したがって、AbstractVectorOfArrayの典型的な例は、`VectorOfArray([[1,2],[3,4]])`の形式のものであり、これは行列[1 3; 2 4]のように「動作」しますが、データは列優先の形式で格納およびアクセスされます（これはJuliaでは一般的です）。しかし、実際の行列は決して構築されず、代わりに型を通じて遅延的に表現されます。

AbstractVectorOfArrayのサブタイプは、以下の動作に一致する必要があります。

!!! note
    2023年に線形インデックス`A[i]`は非推奨になりました。以前は`A[i] = A.u[i]`という動作をしていました。しかし、これは標準の`AbstractArray`インターフェースと互換性がありません。もし`A = VectorOfArray([[1,2],[3,4]])`であり、`A`が`[1 3; 2 4]`のように動作することになっている場合、`A[1] = [1,2]`はVectorOfArrayに対して異なり、行列に対しては`A[1] = 1`となります。これは、`AbstractVectorOfArray <: AbstractArray`の場合に多くの問題を引き起こします。したがって、2026年には非推奨を完了し、`A[i]`が`AbstractArray`の線形インデックスに一致するようにし、次に`AbstractVectorOfArray <: AbstractArray`にする予定です。それまでの間、`AbstractVectorOfArray`はこのインターフェースの破損のために手動でAbstractArrayのようなインターフェースを実装し、将来の互換性を保ちます。


## フィールド

AbstractVectorOfArrayには以下のフィールドがあります：

  * `u`は各タイムステップでの値のベクトルを保持します

## 配列インターフェース

一般的な操作は次のとおりです。次のように使用します。

```julia
A.u[j]
```

で`j`番目の配列にアクセスします。多次元システムの場合、これは最初にコンポーネントで、最後に時間でアドレス指定されるため、

```julia
A[i, j]
```

は配列`j`の`i`番目のコンポーネントになります。したがって、`A[j][i] == A[i, j]`です。これはJuliaが列優先であるため、先行次元はメモリ内で連続している必要があります。独立変数が形状を持っている場合（例えば、行列である場合）、`i`は線形インデックスです。また、次のように形状を持つ解にアクセスすることもできます：

```julia
A[i, k, j]
```

は配列`j`のシステムの`[i,k]`コンポーネントを返します。コロン演算子がサポートされているため、次のようにします。

```julia
A[i, :]
```

は`i`番目のコンポーネントの時系列を返します。

## AbstractArrayインターフェースの使用

`AbstractArray`インターフェースは直接使用できます。例えば、変数のベクトルシステムに対して、`A[i,j]`は変数が行、時間点が列の行列です。`A'`のような操作は解の型を転置します。`AbstractArray`用に書かれた機能はこれを直接使用できます。例えば、Baseの`cov`関数は列間の相関を計算し、したがって：

```julia
cov(A)
```

は時間におけるシステム状態の相関を計算し、一方で

```julia
cov(A, 2)
```

は変数間の相関を計算します。同様に、`mean(A,2)`は時間における変数の平均であり、`var(A,2)`は分散です。他の統計関数やパッケージは`AbstractArray`型で動作し、解の型でも動作します。

## 変換

いつでも、真の`Array`は`Array(A)`を使用して作成できます。また、より一般的には`stack(A)`を使用して配列型を内部配列型に一致させることができます（例えば、`A`がGPU配列の配列である場合、`stack(A)`はGPU配列になります）。
