```
mutable struct SlabBuffer{SlabSize}
```

スラブベースのバンプアロケータで、任意の量のメモリを動的に保持することができます。小さなアロケーションは特定のスラブのメモリ内に存在し、そのスラブが満杯になると、新しいスラブが割り当てられ、今後のアロケーションはそのスラブで行われます。小さなアロケーションは `SlabSize` バイトのサイズのスラブに格納され、現在のスラブのリストは `slabs` フィールドで追跡されます。1つのスラブに収まらないほど大きなアロケーションは、`custom_slabs` フィールドに格納され、追跡されます。

デフォルトのスラブサイズは1048576バイトです。

`SlabBuffer` は、通常の使用においてスタックアロケーションとほぼ同じくらい速い（通常は数ナノ秒以内）です。1つの潜在的なパフォーマンスの落とし穴は、`SlabBuffer` の現在の位置がスラブの端にある場合、次のアロケーションが遅くなることです。なぜなら、新しいスラブを作成する必要があるからです。これは、次のようなことを行うと意味します。

```
buf = SlabBuffer{N}()
@no_escape buf begin
    @alloc(Int8, N÷2 - 1) # 最初のスラブの半分未満を占有
    @alloc(Int8, N÷2 - 1) # 最初のスラブのもう半分を占有
    # これで buf は実質的にスペースがなくなります。
    for i in 1:1000
        @no_escape buf begin
            y = @alloc(Int8, 10) # スペースがないため、新しいスラブが割り当てられます
            f(y)
        end # このブロックの終わりで、新しいスラブは必要ないため削除されます。
    end
end
```

このようにすると、内側のループは通常よりも遅く実行されます。なぜなら、各反復で新しいサイズ `N` バイトのスラブが新たに割り当てられなければならないからです。これは稀な出来事であるべきですが、遭遇する可能性があります。

使用中の SlabBuffer のフィールドを操作しないでください。
