```
construct_linear_solver(alg, linsolve, A, b, u; stats, kwargs...)
```

線形システム `A * u = b` を解くためのキャッシュを構築します。以下のケースが処理されます：

1. `A` が Number の場合、`u = b / A` で解きます。
2. `A` が `SMatrix` の場合、`u = A \ b` で解きます（ベースの Julia からのデフォルトを使用します）（前処理器が指定されていない限り）。
3. `linsolve` が `\` の場合、`ldiv!(u, A, b)` を直接使用して解きます。
4. その他のすべてのケースでは、[LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) を使用して線形システムを解くために `alg` を使用します。

### システムの解決

```julia
(cache::LinearSolverCache)(;
    A = nothing, b = nothing, linu = nothing, reuse_A_if_factorization = false, kwargs...
)
```

システムの解 `u` を返し、更新されたキャッシュを `cache.lincache` に保存します。

#### ランク欠損行列 `A` の特別な処理

線形解法で失敗を検出した場合（主にランク欠損行列をサポートしないアルゴリズムを使用したため）、警告を発し、ピボット QR 因子分解を使用して問題を解こうとします。これは、問題に起因するランク欠損が少数の場合には非常に効率的です。ただし、これらが主な非線形システムに対して頻繁に発生する場合は、ランク欠損行列をサポートする別の線形ソルバーを使用することをお勧めします。

#### キーワード引数

  * `reuse_A_if_factorization`: `true` の場合、可能であれば `A` の因子分解が再利用されます。これは、異なる `b` 値で同じシステムを解くときに便利です。アルゴリズムが反復ソルバーである場合、内部の線形解法キャッシュをリセットします。

LinearSolve のキャッシュと比較してのこの特徴的な点は、キャッシュ構築後もエイリアス引数を尊重することです。つまり、`A` を渡した場合、`A` が変更されないように、事前に構築されたキャッシュに `A` をコピーすることで実現します。
