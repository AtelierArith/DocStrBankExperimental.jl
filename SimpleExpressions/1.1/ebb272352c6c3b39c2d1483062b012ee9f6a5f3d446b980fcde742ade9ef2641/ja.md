```
@symbolic x [p]
```

シンボリック変数とオプションのシンボリックパラメータを作成します。

# 式と方程式

これらの変数を使用して作成された式は `Function` のサブクラスであるため、関数が期待される場所で使用できます。

`~` 中置演算子を使用して方程式を作成できます。これは、デフォルトで関数として呼び出されたときに `lhs - rhs` として扱われます。

# 拡張ヘルプ

## 式への呼び出しまたは代入

シンボリック式を呼び出すには、位置引数を使用した通常の呼び出し構文が使用されます。最初の引数は *任意の* シンボリック変数にマッピングされ、2番目の引数は与えられた場合、任意のシンボリックパラメータにマッピングされます。パラメータを使用して式を単一の引数で呼び出すことはエラーです。そのためには代入が必要です。

## 例

```@example symbolic
using SimpleExpressions
@symbolic x p
u = x^5 - x - 1
u(2) # 29 呼び出しは u(x)

u.((0,1,2)) # (-1, -1, 29)

u = 2x + p
u(1)    # エラー！
u(1, 2) # 2(1)+2 または 4

u = sum(x .* p)
u(2, [1,2]) # 6 呼び出しは u(x, p)
```

`nothing`、`missing`、または `:` をスロットに指定すると、指定された値が代入され、シンボリック式が残ります。変数やパラメータがない場合もあります。

```@example symbolic
@symbolic x p
u = cos(x) - p*x
u(nothing, 2)  # cos(x) - 2 * x
u(:, 2)        #  cos(x) - 2 * x, 代替呼び出し形式
u(pi, nothing) # -1.0 - p * π
v = u(1,:)(:,2)    # (cos(1)-(2*1)),
```

後者はゼロ引数の呼び出しを使用して評価できます。例：`v()`。

この方法での代入では、任意のシンボリック変数と任意のシンボリックパラメータが同じ代入値を受け取ります。

[`replace`](@ref) シンボリックオブジェクト用のジェネリックは、値のペアを取り、左側の値を右側の値で置き換え、左から右に処理し、シンボリック式を残します。`replace` メソッドは、異なるシンボルを持つシンボリック変数とシンボリックパラメータをユニークなものとして扱います。

`~` を通じて定義されたシンボリック方程式は、左辺と右辺の値を指定するためにも使用できます。

主な用途は、無名関数の簡単に入力できる置き換えとしてですが、違いがあります：

```@example symbolic
1 |> sin(x) |> x^2  # 0.708… from sin(1)^2
u = cos(x) - p*x
2 |> u(:, 3) # -6.4161…, u(2,3) の代替
```

```@example symbolic
map(x^2, (1, 2)) # (1,4)
```

シンボリック式は他のパッケージとともに使用でき、いくつかの関数呼び出しを簡素化しますが、非慣用的になります：

```julia
using Roots
@symbolic x p
find_zero(x^5 - x - 1, 1)       # 1.167…
find_zero(x^5 - x ~ p, 1; p=4)  # 1.401…

using ForwardDiff
Base.adjoint(𝑓::Function) = x -> ForwardDiff.derivative(𝑓, x)
u = x^5 - x - 1
find_zero((u,u'), 1, Roots.Newton()) # 1.167…
```

または

```julia
using Plots
plot(x^5 - x - 1, 0, 1.5)
```

または両方の位置を使用して、二変数関数として呼び出します：

```julia
@symbolic x y
xs = ys = range(-5, 5, length=100)
contour(xs, ys, x^2 - y^2 + 2x*y)
```

シンボリック微分はシンボリック値に関して行うことができ、シンボリックパラメータは定数として扱われます。インターフェースとして `diff` を使用します。

```julia
@symbolic x p
u = x^5 - p*x - 1
diff(u, x)           # (5 * (x ^ 4)) - p
u = u(:, 1)    # パラメータを設定
a, b = 1, 2
find_zeros(diff(u,x) ~ (u(b)-u(a)) / (b-a), (a,b)) # [1.577…]
```

## 特異性

これは *単純な* ケースのための便利さです。特異性に遭遇するのは簡単です。

### 式はスコープの観点から関数ではない

関数とは異なり、式は定義時に変数が定義され、呼び出されたときではありません。たとえば、クリーンな環境で：

```@example symbolic
@symbolic x
u = m*x + b    # エラー、`m` が定義されていない
f(x) = m*x + b # ok
m, b = 1, 2
u = m*x + b    # 割り当て時に `m` と `b` を使用して定義
u(3)           # 1 * 3 + 2
f(3)           # 1 * 3 + 2 呼び出し時の `m` と `b` の値
m, b = 3, 4
u(3)           # まだ 1 * 3 + 2 を計算中
f(3)           # 3 * 3 + 4 を計算中、呼び出し時の `m` と `b` の値を使用
```

### シンボリック値は位置による呼び出し時に本当にシングルトンである

異なるシンボリック変数を作成することはできますが、位置による基本的な呼び出し構文はそれらを同じものとして扱います：

```@example symbolic
@symbolic x
@symbolic y    # x と y は両方とも `SymbolicVariable` 型
u = x + 2y
u(3)           # 9 は 3 + 2*(3) から来る
```

ただし、これは呼び出しインターフェースを簡素化するためだけです。*キーワード* 引数を使用すると、異なる値で評価できます：

```@example symbolic
u(;x=3, y=2)   # 7
```

`replace` を使用すると、次のようになります：

```@example symbolic
u(x=>3, y=>2)  # 3 + (2 * 2); u(x=>3, y=>2)() で評価
```

上記の方法で直接呼び出される基礎となる `CallableExpressions` オブジェクトがあります。そのパッケージはこのパッケージの狭められた設計を持っていません。

## コンテナ

変数はコンテナのプレースホルダーとして使用できます。例えば：

```@example symbolic
u = sum(xi*pi for (xi, pi) in zip(x,p))
u((1,2),(3,4))  # 11
```

## 関数としてのブロードキャスティング

関数呼び出しのブロードキャスティングは期待通りに機能します。

```@example symbolic
@symbolic x
u = x^2
u.((1,2)) # (1, 4)
```

呼び出しをブロードキャストするシンボリック式も構築できます。

```@example symbolic
u = x.^2 .+ sin.(p)
u((1,2),3)

u = @. x^2 + sin(p)
u((1,2),(3,4))
```
