```
SimpleExpressions
```

非常に軽量な手段で、式を使用して呼び出し可能な関数を作成します。これは、[CallableExpressions](https://juliahub.com/ui/Packages/General/SimpleExpressions)をバックエンドとして使用しています。類似の機能を持つ高性能なパッケージについては、[DynamicExpressions](https://juliahub.com/ui/Packages/General/DynamicExpressions)も参照してください。

[`@symbolic`](@ref)マクロは、唯一のエクスポートであり、シンボリック変数とオプションのシンボリックパラメータを作成できます。これらの変数を使用して式が作成されると、評価は関数のように式が呼び出されるまで遅延されます。式は`Function`のサブタイプであり、`Julia`の高階関数と一緒に使用することを意図しています。

式は、単変数関数`u(x)`、パラメータを持つ単変数関数`u(x, p)`、または二変数関数`u(x,y)`（`y`はパラメータ）として評価できます。これらはすべて、関数が数値ルーチンに渡されるときの典型的な呼び出しパターンです。シンボリック値を持たない式（置換を通じて発生する可能性があります）に対しては、`u()`が値を評価します。

変数またはパラメータのいずれかに対して置換を行い、シンボリック式を残すために、呼び出しパターン`u(:,p)`、`u(x,:)`を使用してそれぞれパラメータと変数に置換を行います。コロンは`nothing`または`missing`でも構いません。

上記のように呼び出しで位置引数を使用する場合、すべてのシンボリック変数は同一に扱われ、すべてのシンボリックパラメータも同様です。

より複雑な置換を可能にする`replace`のメソッドもあります。`replace`では、シンボリックオブジェクトが返されます。`replace`では、変数は異なり、そのシンボルによって識別されます。ペアは、`replace`の便宜のために呼び出し表記に指定できます。

パフォーマンスに関する主張はありません。このパッケージはすべて便利さに関するものです。`SymPy`、`SymEngine`、`Symbolics`などでも同様の便利さが利用可能です。また、`Underscores.jl`、`Chain.jl`、`DataPipes.jl`などでプレースホルダー構文も利用可能です。このパッケージは非常に軽量であり、希望的には直感的にシンプルであることに価値があります。

ただし、`CallableExpressions`が高性能であるため、パフォーマンスは良好です。関数のゼロを見つけるベンチマークケースは、`0`のアロケーションで`1.099 μs`で実行され、シンボリック式では`0`のアロケーションで`1.231 μs`で実行されます。`SymEngine`は2桁遅く（`302.329 μs`で`1731`のアロケーション）、SymPyは約4桁遅く（`80k`のアロケーション）なります。

`SpecialFunctions`、`AbstractTrees`、`Latexify`、および`RecipesBase`の拡張が提供されています。

# 例

```julia
using SimpleExpressions
@symbolic x       # (x,)
u = sin(x) - (x - x^3/6)
u(0.5)  # 0.000258...
u = u - x^5/120
u(0.5) # -1.544...e-6
```

```julia
map(x^2, (1, 2))  # (1, 4)
```

```julia
using Plots
@symbolic x p     # (x, p)
u = x^5 - x - p   # (x ^ 5) + (-1 * x) + (-1 * p)
plot(u(:, 1), 0, 1.5)
plot!(u(:, 2))    # または plot(u.(:, 1:2), 0, 1.5)
eq = cos(x) ~ 2x
plot(eq, 0, pi/2) # plot([eq...], 0, pi/2)のように
```
