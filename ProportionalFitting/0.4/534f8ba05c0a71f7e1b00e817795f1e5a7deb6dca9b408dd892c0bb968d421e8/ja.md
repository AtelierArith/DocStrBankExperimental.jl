```
ipf(X::AbstractArray{<:Real}, mar::ArrayMargins; maxiter::Int = 1000, tol::Float64 = 1e-10)
ipf(X::AbstractArray{<:Real}, mar::Vector{<:Vector{<:Real}})
ipf(mar::ArrayMargins)
ipf(mar::Vector{<:Vector{<:Real}})
```

反復比例適合（ファクターメソッド）を実行します。配列（X）は任意の次元数を持つことができ、マージンも多次元である可能性があります。マージンのみが指定された場合、シード行列 `X` は正しいサイズと要素タイプの1で埋められた配列であると仮定されます。

マージンがArrayMarginsオブジェクトでない場合、それらはこのタイプに強制されます。

この関数は、ArrayFactorsオブジェクトとして更新行列を返します。更新された行列を計算するには、`Array(result) .* X` を使用します（例を参照）。

関連情報: [`ArrayFactors`](@ref), [`ArrayMargins`](@ref)

# 引数

  * `X::AbstractArray{<:Real}`: 調整される配列
  * `mar::ArrayMargins`: ArrayMarginsオブジェクトとしてのターゲットマージン
  * `maxiter::Int=1000`: 最大反復回数
  * `tol::Float64=1e-10`: 収束のためのファクタ変化許容値

# 例

```julia-repl
julia> X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]
julia> u = [150, 300, 400, 150]
julia> v = [200, 300, 400, 100]
julia> AF = ipf(X, [u, v])
2D配列のファクタ:
    [1]: [0.9986403503185242, 0.8833622306385376, 1.1698911437112522, 0.8895042701910321]
    [2]: [1.616160156063788, 1.5431801747375655, 1.771623700829941, 0.38299396265192226]

julia> Z = Array(AF) .* X
4×4 Matrix{Float64}:
 64.5585   46.2325   35.3843   3.82473
 49.9679   68.1594  156.499   25.3742
 56.7219  144.428   145.082   53.7673
 28.7516   41.18     63.0347  17.0337

julia> ArrayMargins(Z)
2D配列のマージン:
  [1]: [150.0000000009452, 299.99999999962523, 399.99999999949796, 149.99999999993148]
  [2]: [200.0, 299.99999999999994, 399.99999999999994, 99.99999999999997]
```
