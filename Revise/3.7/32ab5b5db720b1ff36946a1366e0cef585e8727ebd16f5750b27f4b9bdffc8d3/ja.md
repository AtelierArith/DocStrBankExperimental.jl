```
includet(filename)
```

`filename`をロードし、将来の変更を追跡します。`includet`は迅速な「ユーザースクリプト」を意図しており、より大きなまたは確立されたプロジェクトでは、`using`または`import`でロードされた1つ以上のパッケージにコードを置くことが推奨されます。パッケージワークフローの設定に関するヒントについては、https://timholy.github.io/Revise.jl/stable/cookbook/を参照してください。

デフォルトでは、`includet`は*データ*ではなく*メソッド*の変更のみを追跡します。詳細については拡張ヘルプを参照してください。これは、デフォルトですべての変更を評価するパッケージとは異なることに注意してください。このデフォルトの動作はオーバーライド可能です。詳細は[Configuring the revise mode](@ref)を参照してください。

# 拡張ヘルプ

## デフォルトのリビジョンモード（`:evalmeth`）の動作と正当性

`includet`はデフォルトで`__revise_mode__ = :evalmeth`を使用します。その結果、次のように変更した場合

```
a = [1]
f() = 1
```

```
a = [2]
f() = 2
```

Reviseは`f`を更新しますが、`a`は更新しません。

これは、`includet`のデフォルトの選択です。なぜなら、そのようなファイルは通常、メソッド定義とデータ処理を混在させるからです。データには多くの追跡されていない依存関係があることが多く、同じファイルの後半で`push!(a, 22)`を行うかもしれませんが、Reviseは`a`を再定義した後にその行を再実行するかどうかを判断できません。したがって、最も安全なデフォルトの選択は、ユーザーにデータの管理を任せることです。

## ワークフローヒント

メソッドを再定義する際に実行したい計算のシリーズがある場合は、メソッド定義を計算から分離することを検討してください：

  * メソッド定義はパッケージに、または1回だけ`includet`するファイルに置きます
  * 計算は別のファイルに置き、計算を再実行したいときに毎回再`include`します（末尾に「t」は付けません）。

これは[`entr`](@ref)を使用して自動化できます。

## 内部

`includet`は本質的に次の短縮形です。

```
Revise.track(Main, filename; mode=:includet, skip_include=true)
```

パッケージには`includet`を使用しないでください。パッケージは`using`または`import`で処理する必要があります。`using`と`import`が機能しない場合、パッケージが非標準の場所にある可能性があります。`push!(LOAD_PATH, "/path/to/my/private/repos")`のようなもので修正してみてください。（BaseやJuliaの標準ライブラリのコードを扱っている場合は、`mod`がモジュールである`Revise.track(mod)`を代わりに使用してください。）

`includet`は意図的に再帰的ではないため、`filename`が他のファイルをロードする場合、それらは自動的に追跡されません。（必要なすべてのコードをすでに`included`している場合は、各ファイルに対して手動で[`Revise.track`](@ref)を呼び出してください。）
