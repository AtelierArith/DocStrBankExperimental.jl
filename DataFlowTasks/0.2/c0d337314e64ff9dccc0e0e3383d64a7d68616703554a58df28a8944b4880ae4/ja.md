```
@dspawn expr [kwargs...]
```

Juliaの`Task`を生成して、`expr`で与えられたコードを実行し、利用可能なスレッドで実行されるようにスケジュールします。

`expr`内のコードには、データへのアクセス方法を示すために`@R`、`@W`、および/または`@RW`で注釈を付けてください（以下の例を参照）。この情報は、タスクの依存関係を自動的に推測するために使用されます。

さらに、次のキーワード引数を指定できます：

  * `label`: タスクを識別するためのラベルを提供します。これは、スケジューリング情報をログに記録する際に便利です；
  * `priority`: タスクの相対的な優先度についてスケジューラに通知します。この情報は、デフォルトのスケジューラでは（まだ）活用されていません。

## 例：

以下は、`C`に対する読み書き依存関係と、`A`および`B`に対する読み依存関係を表す同じ`Task`を作成する3つの同等の方法です。

```jldoctest; output = false
using LinearAlgebra
using DataFlowTasks
A = ones(5, 5)
B = ones(5, 5)
C = zeros(5, 5)
α, β = (1, 0)

# オプション1: 関数呼び出しで引数に注釈を付ける
@dspawn mul!(@RW(C), @R(A), @R(B), α, β)

# オプション2: コードブロック内でデータアクセスモードを指定する
@dspawn begin
   @RW C
   @R  A B
   mul!(C, A, B, α, β)
end

# オプション3: コードブロックの後にデータアクセスモードを指定する
# （すなわち、キーワード引数と並行して）
res = @dspawn mul!(C, A, B, α, β) @RW(C) @R(A,B)

fetch(res) # 5×5の行列5.0

# 出力

5×5 Matrix{Float64}:
 5.0  5.0  5.0  5.0  5.0
 5.0  5.0  5.0  5.0  5.0
 5.0  5.0  5.0  5.0  5.0
 5.0  5.0  5.0  5.0  5.0
 5.0  5.0  5.0  5.0  5.0
```

こちらは、2つの異なるタスクを含む完全な計算を示すより完全な例です。

```jldoctest
using DataFlowTasks

A = rand(5)

# Aへの書き込みアクセスモードでタスクを作成
# ラベルは「writer」
t1 = @dspawn begin
    @W A
    sleep(1)
    fill!(A,0)
    println("書き込みが完了しました")
end  label="writer"

# Aへの読み取りアクセスモードでタスクを作成
t2 = @dspawn begin
    @R A
    println("私は自動的に`t1`の完了を待ちます")
    sum(A)
end  priority=1

fetch(t2) # 0

# 出力

書き込みが完了しました
私は自動的に`t1`の完了を待ちます
0.0
```

上記の例では、`t2`が`A`のデータフィールドを読み取ったため、`t1`の完了を待っていたことに注意してください。`t1`はそのフィールドに書き込み可能な方法でアクセスしました。
