```
==(x, y)
```

汎用等価演算子。[`===`](@ref)にフォールバックします。等価性の概念を持つすべての型に対して実装されるべきです。これは、インスタンスが表す抽象的な値に基づいています。たとえば、すべての数値型は型を無視して数値で比較されます。文字列はエンコーディングを無視して文字のシーケンスとして比較されます。コレクションの場合、`==`は一般的にすべての内容に対して再帰的に呼び出されますが、配列の形状のような他の特性も考慮される場合があります。

この演算子は浮動小数点数に対してIEEEのセマンティクスに従います：`0.0 == -0.0`および`NaN != NaN`。

結果は`Bool`型ですが、オペランドの1つが[`missing`](@ref)である場合は`missing`が返されます（[三値論理](https://en.wikipedia.org/wiki/Three-valued_logic)）。コレクションの場合、オペランドの1つに`missing`値が含まれていて、すべての非欠損値が等しい場合は`missing`が返されます。常に`Bool`結果を得るには、[`isequal`](@ref)または[`===`](@ref)を使用してください。

# 実装

新しい数値型は、新しい型の2つの引数に対してこの関数を実装し、可能な限り昇格ルールを介して他の型との比較を処理する必要があります。

[`isequal`](@ref)は`==`にフォールバックするため、新しい`==`のメソッドは[`Dict`](@ref)型によってキーの比較に使用されます。あなたの型が辞書のキーとして使用される場合、したがって[`hash`](@ref)も実装する必要があります。

ある型が`==`、[`isequal`](@ref)、および[`isless`](@ref)を定義している場合、それは比較の一貫性を確保するために[`<`](@ref)も実装する必要があります。
