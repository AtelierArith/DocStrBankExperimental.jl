```
module ArgumentModes
```

このモジュールは、`Val`の拡張として見ることができる型`Mode`を提供します。`Mode`は、関数メソッドの引数の型として使用されることを意図しています。`Mode`型の特化は、受け入れられるシンボル（フラグ）のリストを含みます。ディスパッチは、引数の値（`Mode`インスタンス）が、引数の型で宣言された受け入れられるシンボルのリストに含まれるシンボルのみを含む場合にのみメソッドを選択します。

`Mode`の想定される使用法：

1. 通常の`Symbol`をフラグパラメータとして関数引数として使用することの置き換え。ここで`Mode`は、関数の各メソッドに対して異なる受け入れられるシンボルのリストを持つシンボルの集合として関数引数を明示的に宣言することを可能にします。ディスパッチプロセスは、そのリストに基づいてメソッドを選択します。この方法では、タイプ制御も間接的に行われます。例えば、`open(f, Mode(:read))`、`open(f, Mode(:write))`、`open(f, Mode(:write, :sync))`は（設計によって異なる場合がありますが）3つの異なるメソッドに対応するかもしれません。
2. 関数引数に対して値がどのような意味で提供されているかを明示的に示す方法。これは、引数の意味を型だけで区別することができない場合に便利です。

    例えば、関数**f**が任意の次元数の配列型オブジェクトを処理するとします。単一のオブジェクトとオブジェクトの反復可能なコレクションの両方を処理するためのメソッドを宣言したい場合があります。`f([x,y])`は、単一のオブジェクト`[x,y]`を処理することも、2つのオブジェクト`x`と`y`を処理することも意味する可能性があるため、引数の型だけでメソッドを区別するのは難しいでしょう。しかし、コレクションのメソッドの宣言で`Mode`を使用することで、ユーザーは呼び出しで何が渡されているかを明示的に示すことができます：単一のオブジェクトの場合は`f([x,y])`、オブジェクトのコレクションの場合は`f(Mode(:collection)=> [x, y])`です。

一連のテストにより、`Mode`の現在の実装は関数引数とメソッドディスパッチに使用されるときに完全にコンパイルされることが示されており、これを使用することによるランタイムオーバーヘッドはないようです（少なくともテストで考慮された使用ケースにおいては）。

# 型

  * `Mode`：シンボルの集合（おそらくパラメータ付き）に似ており、ディスパッチプロセスが`Mode`インスタンスの値に基づいて関数メソッドを選択する能力を持っています。

# 型コンストラクタ

  * `Mode[ s₁ [=> t₁] [, s₂ [=> t₂]]... ]`：シンボル`s₁`、`s₂`、…を受け入れる型特化を宣言します。引数の型として関数メソッド宣言で使用されることを意図しています。

# インスタンスコンストラクタ

  * `Mode( s₁[=> v₁] [, v₂ [=> v₂]]... )`：シンボル`s₁`、`s₂`、…とそれに対応する値`v₁`、`v₂`、…を持つインスタンスを作成します。関数呼び出しで引数値として使用されることを意図しています。

# `Mode`インスタンスに対する操作

  * `m => v` `m::Mode[s => Nothing]`の場合：単一のシンボルを持つ新しいインスタンスを返します。
  * `m₁ ~ m₂`：`m₁`と`m₂`を結合します。
  * `keys(m), values(m), pairs(m)`：シンボル / 値 / シンボルと値のペアを返します。
  * `m[s₁ [, s₂]... ]`：`s₁`の値 / `s₁, s₂, ...`の値のタプルを返します。
  * `m[]`：`m`が単一の値のみを含む場合はそれを返します。そうでない場合はArgumentErrorをスローします。
  * `checkmode(m, ...)`：`m`が`Mode`であり、指定されたシンボルを含むかどうかをチェックし、必要に応じてアクションを実行します。
