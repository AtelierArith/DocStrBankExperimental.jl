メモリ帯域幅を次のストリーミングカーネルを使用して測定します。対応するデータアクセスパターン（表記: S - ストア, L - ロード, WA - 書き込みアロケート）。すべての変数はベクトルであり、`s` はスカラーです：

```
init (S1, WA): 配列を初期化します: `a = s`。ストアのみ。
sum (L1): ベクトル還元: `s += a`。ロードのみ。
copy (L1, S1, WA): クラシックメモリコピー: `a = b`。
update (L1, S1): ベクトルの更新: `a = a * scalar`。ロード + ストアですが、書き込みアロケートなし。
triad (L2, S1, WA): ストリームトライアド: `a = b + c * scalar`。
daxpy (L2, S1): Daxpy: `a = a + b * scalar`。
striad (L3, S1, WA): ショエナウアートライアド: `a = b + c * d`。
sdaxpy (L3, S1): 書き込みアロケートなしのショエナウアートライアド: `a = a + b * c`。
```

キーワード引数：

  * `N`（デフォルト: `120_000_000`）：ベクトルの長さ
  * `nthreads`（デフォルト: `Threads.nthreads()`）：使用するJuliaスレッドの数
  * `niter`（デフォルト: `10`）：測定を繰り返す回数
  * `alignment`（デフォルト: `64`）：配列のアライメント
  * `verbose`（デフォルト: `false`）：結果テーブル + スレッド情報などを印刷
  * `write_allocate`（デフォルト: `false`）：書き込みアロケート補償係数を含める
