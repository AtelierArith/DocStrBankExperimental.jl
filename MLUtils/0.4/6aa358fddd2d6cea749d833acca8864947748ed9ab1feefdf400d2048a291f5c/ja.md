```
undersample([rng], data, classes; shuffle=true)
undersample([rng], data::Tuple; shuffle=true)
```

`data`の観測値をサンプリングして、クラスバランスの取れたバージョンを生成します。これにより、結果として得られる観測値の数はすべてのクラスで同じになります。この方法で、すべてのクラスは、与えられた（元の）`data`の中で最も小さいクラスが持つ観測値の数と同じだけの観測値を持つことになります。

便利なパラメータ`shuffle`は、生成されたデータが作成後にシャッフルされるかどうかを決定します。シャッフルされない場合、すべての観測値は元の順序のままになります。デフォルトは`false`です。

`data`がタプルであり、`classes`が指定されていない場合、タプルの最後の要素がクラスを含むと見なされます。

出力には、再サンプリングされたデータとクラスの両方が含まれます。

```julia
# 6つの観測値とそれぞれ3つの特徴
X = rand(3, 6)
# 2つのクラス、非常に不均衡
Y = ["a", "b", "b", "b", "b", "a"]

# クラス "b" を "a" に合わせてサンプリング
X_bal, Y_bal = undersample(X, Y)

# これにより、データセットが小さくなります
@assert size(X_bal) == (3,4)
@assert length(Y_bal) == 4

# 現在、"a" と "b" の両方にそれぞれ2つの観測値があります
@assert sum(Y_bal .== "a") == 2
@assert sum(Y_bal .== "b") == 2
```

この関数が機能するためには、`data`の型が[`numobs`](@ref)および[`getobs`](@ref)を実装している必要があります。

`data`がタプルである場合、タプルの最後の要素がターゲットを含むと見なされることに注意してください。

```julia
julia> data = DataFrame(X1=rand(6), X2=rand(6), Y=[:a,:b,:b,:b,:b,:a])
6×3 DataFrames.DataFrame
│ Row │ X1        │ X2          │ Y │
├─────┼───────────┼─────────────┼───┤
│ 1   │ 0.226582  │ 0.0443222   │ a │
│ 2   │ 0.504629  │ 0.722906    │ b │
│ 3   │ 0.933372  │ 0.812814    │ b │
│ 4   │ 0.522172  │ 0.245457    │ b │
│ 5   │ 0.505208  │ 0.11202     │ b │
│ 6   │ 0.0997825 │ 0.000341996 │ a │

julia> getobs(undersample(data, data.Y))
4×3 DataFrame
 Row │ X1        X2         Y      
     │ Float64   Float64    Symbol 
─────┼─────────────────────────────
   1 │ 0.427064  0.0648339  a
   2 │ 0.376304  0.100022   a
   3 │ 0.467095  0.185437   b
   4 │ 0.457043  0.490688   b
```

データのサブセットに関する詳細は[`ObsView`](@ref)を参照してください。また、[`oversample`](@ref)も参照してください。
