```
splitobs([rng,] data; at, shuffle=false, stratified=nothing) -> Tuple
```

`data`を2つ以上のサブセットに分割します。

引数`at`はデータを分割する方法を指定します：

  * `at`が0と1の間の数値の場合、これは最初のサブセットの割合を指定します。
  * `at`が整数の場合、最初のサブセットの観測数を指定します。
  * `at`がタプルの場合、各サブセットの数または割合を指定しますが、最後のサブセットには残りの観測が含まれます。返されるサブセットの数は`length(at)+1`です。

`shuffle=true`の場合、分割する前に観測をランダムに並べ替えます。ランダム数生成器`rng`は、最初の引数としてオプションで渡すことができます。

`stratified`が`nothing`でない場合、それはデータと同じ長さのラベルの配列である必要があります。観測は、各サブセットにおいて各ラベルの割合が保持されるように分割されます。

[`numobs`](@ref)を実装している任意のデータ型をサポートします。

データのビューを作成するために[`obsview`](@ref)に依存しています。

# 例

```jldoctest
julia> splitobs(reshape(1:100, 1, :); at=0.7)  # 行列の単純な70%-30%分割
([1 2 … 69 70], [71 72 … 99 100])

julia> data = (x=ones(2,10), n=1:10)  # 一貫した最終次元のNamedTuple
(x = [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], n = 1:10)

julia> splitobs(data, at=(0.5, 0.3))  # 50%-30%-20%の分割、例：トレーニング/テスト/検証
((x = [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], n = 1:5), (x = [1.0 1.0 1.0; 1.0 1.0 1.0], n = 6:8), (x = [1.0 1.0; 1.0 1.0], n = 9:10))

julia> train, test = splitobs((reshape(1.0:100.0, 1, :), 101:200), at=0.7, shuffle=true);  # タプルを分割

julia> vec(test[1]) .+ 100 == test[2]
true

julia> splitobs(1:10, at=0.5, stratified=[0,0,0,0,1,1,1,1,1,1]) # 各サブセットに2つのゼロと3つの1
([1, 2, 5, 6, 7], [3, 4, 8, 9, 10])
```
