```
transform!(df::AbstractDataFrame, args...;
           renamecols::Bool=true, threads::Bool=true)
transform!(args::Callable, df::AbstractDataFrame;
           renamecols::Bool=true, threads::Bool=true)
transform!(gd::GroupedDataFrame, args...;
           ungroup::Bool=true, renamecols::Bool=true, threads::Bool=true)
transform!(f::Base.Callable, gd::GroupedDataFrame;
           ungroup::Bool=true, renamecols::Bool=true, threads::Bool=true)
```

`df` または `gd` をその場で変更して、`args...` で指定された列を追加し、それを返します。結果は `df` と同じ行数を持つことが保証されています。これは `select!(df, :, args...)` または `select!(gd, :, args...)` と同等ですが、列のリネームはコピーを行います。

以下に、DataFrames.jl がサポートするすべての変換関数の一般的なルールを詳しく説明し、比較します。

これらの操作は、`AbstractDataFrame`（分割と結合のステップをスキップした場合）および `GroupedDataFrame` の両方でサポートされています。技術的には、`AbstractDataFrame` は列がないグループにグループ化されていると見なされます（つまり、単一のグループを持つか、空であればゼログループです）。この場合の唯一の違いは、`keepkeys` および `ungroup` キーワード引数（以下に説明）をサポートしておらず、データフレームは常に返されることです。この場合、分割と結合のステップは存在しません。

グループごとに操作を実行するには、まず `groupby` 関数を使用してデータフレームから `GroupedDataFrame` オブジェクトを作成する必要があります。この関数は2つの引数を取ります：（1）グループ化されるデータフレーム、（2）グループ化する列のセットです。

その後、次の関数のいずれかを使用して各グループに操作を適用できます：

  * `combine`: 各グループごとに返される行数に制限を設けません。返される値は `GroupedDataFrame` 内のグループの順序に従って垂直に連結されます。通常、グループごとの要約統計を計算するために使用されます。`GroupedDataFrame` の場合、グループ化列が保持されている場合は、結果の最初の列に配置されます。
  * `select`: ソースデータフレームと同じ行数と順序を持つデータフレームを返し、新しく計算された列のみを含みます。`select!` は `select` のその場でのバージョンです。`GroupedDataFrame` の場合、グループ化列が保持されている場合は、結果の最初の列に配置されます。
  * `transform`: ソースデータフレームと同じ行数と順序を持つデータフレームを返し、ソースからのすべての列と新しく計算された列を含みます。`transform!` は `transform` のその場でのバージョンです。ソースデータフレームの既存の列は、結果の最初の列に配置されます。

特別なケースとして、ゼログループの `GroupedDataFrame` が渡された場合、操作の結果は、0行の引数を渡して変換関数を1回呼び出すことによって決定されます。この操作の出力は、生成される列の数と型を特定するためにのみ使用されますが、結果はゼロ行です。

これらの関数はすべて、`DataFrame` の各サブセットに適用する1つ以上の関数の仕様を受け取ります。この仕様は次の形式のいずれかです：

1. 標準の列セレクタ（整数、`Symbol`、文字列、整数のベクトル、`Symbol` のベクトル、文字列のベクトル、`All`、`Cols`、`:`、`Between`、`Not` および正規表現）
2. `cols => function` ペアは、`function` が `cols` を持つ位置引数で呼び出されるべきことを示します。ここで `cols` は有効な列セレクタである必要があります。この場合、ターゲット列名は自動的に生成され、`function` が単一の値またはベクトルを返すことが想定されます。生成された名前は、デフォルトでソース列名と `function` 名を連結して作成されます（以下の例を参照）。
3. `cols => function => target_cols` 形式は、ターゲット列または列を明示的に指定します。これは単一の名前（`Symbol` または文字列）、名前のベクトル、または `AsTable` でなければなりません。さらに、`cols` で選択された列の名前を含む文字列または文字列のベクトルを引数として受け取り、ターゲット列名を返す `Function` であることもできます（`AsTable` 以外のすべての受け入れられる型が許可されます）。
4. `col => target_cols` ペアは、列 `col` を `target_cols` にリネームします。`target_cols` は単一の名前（`Symbol` または文字列）、名前のベクトル、または `AsTable` でなければなりません。
5. 列に依存しない操作 `function => target_cols` または特定の `function` のための単に `function` では、入力列が省略されます。`target_cols` がない場合、新しい列は `function` と同じ名前になります。そうでない場合、単一の名前（`Symbol` または文字列）でなければなりません。サポートされている `function` は次のとおりです：

      * `nrow` は各グループの行数を効率的に計算します。
      * `proprow` は各グループの行の割合を効率的に計算します。
      * `eachindex` は各グループ内の各行の番号を保持するベクトルを返します。
      * `groupindices` はグループ番号を返します。
6. `Pair` 構文で指定された変換を含むベクトルまたは行列（ポイント2から5で説明された）
7. `GroupedDataFrame` が処理されている場合は、各グループに対応する `SubDataFrame` で呼び出される関数、または `AbstractDataFrame` が処理されている場合はデータフレーム自体で呼び出される関数。この形式は、グループの数が少ない場合や非常に多くの列が処理される場合を除いて、パフォーマンスが悪いため避けるべきです（この場合、`SubDataFrame` は過剰なコンパイルを回避します）。

注意！ `x => y` の形式の式が渡された場合、特別な便利形式 `nrow => target_cols` を除いて、常に `cols => function` と解釈されます。特に、次の式 `function => target_cols` は有効な変換仕様ではありません。

注意！ `cols` または `target_cols` が `All`、`Cols`、`Between`、または `Not` のいずれかである場合、`.=>` を使用したブロードキャストがサポートされており、`names(df, cols)` または `names(df, target_cols)` の結果をブロードキャストするのと同等です。これは、データフレームスコープ内で選択された列名に置き換えた後にブロードキャストが行われたかのように動作します。

すべての関数には2つのタイプのシグネチャがあります。1つは `GroupedDataFrame` を最初の引数として受け取り、次の引数として上記で説明された任意の数の変換を受け取ります。2つ目のタイプのシグネチャは、`Function` または `Type` が最初の引数として渡され、`GroupedDataFrame` が2番目の引数として渡される場合です（`map` に似ています）。

特別なルールとして、`cols => function` および `cols => function => target_cols` 構文では、`cols` が `AsTable` オブジェクトでラップされている場合、`function` に `cols` で選択された列を含む `NamedTuple` が渡されます。 [`DataFrames.table_transformation`](@ref) のドキュメントは、この機能に関する詳細情報を提供し、特にパフォーマンスの考慮事項をカバーしています。

`function` が返すことが許可されているものは、`target_cols` の値によって決まります：

1. `cols` と `target_cols` の両方が省略されている場合（つまり、`function` のみが渡されている場合）、データフレーム、行列、`NamedTuple`、`Tables.AbstractRow` または `DataFrameRow` を返すと、結果に複数の列が生成されます。他の値を返すと、単一の列が生成されます。
2. `target_cols` が `Symbol` または文字列の場合、関数は単一の列を返すと見なされます。この場合、データフレーム、行列、`NamedTuple`、`Tables.AbstractRow`、または `DataFrameRow` を返すとエラーが発生します。
3. `target_cols` が `Symbol` または文字列のベクトルまたは `AsTable` の場合、`function` は複数の列を返すと見なされます。`function` が `AbstractDataFrame`、`NamedTuple`、`DataFrameRow`、`Tables.AbstractRow`、`AbstractMatrix` のいずれかを返す場合、上記のポイント1で説明されたルールが適用されます。`function` が `AbstractVector` を返す場合、このベクトルの各要素は `keys` 関数をサポートし、`keys` は `Symbol`、文字列、または整数のコレクションを返す必要があります。`keys` の返り値はすべての要素で同一でなければなりません。次に、`keys` 関数の返り値の要素数と同じ数の列が作成されます。`target_cols` が `AsTable` の場合、名前はキー名と等しく設定されますが、`keys` が整数を返す場合は、`x` で接頭辞が付けられます（したがって、列名は `x1`、`x2` などになります）。`target_cols` が `Symbol` または文字列のベクトルの場合、上記のルールを使用して生成された列名は無視され、`target_cols` に置き換えられます（この場合、列の数は `target_cols` の長さと同じでなければなりません）。`fun` が他の型の値を返す場合、それは Tables.jl API に準拠したテーブルであると見なされ、`Tables.columntable` 関数が呼び出されて結果の列とその名前が取得されます。名前は `target_cols` が `AsTable` の場合に保持され、`target_cols` が `Symbol` または文字列のベクトルの場合に置き換えられます。

これらのすべてのケースで、`function` は単一の行または複数の行を返すことができます。特別なルールとして、`Ref` または 0 次元の `AbstractArray` でラップされた値はアンラップされ、単一の行として扱われます。

`select`/`select!` および `transform`/`transform!` は常にソースと同じ行数と順序を持つデータフレームを返します（`GroupedDataFrame` がグループを再配置しても）。ただし、選択の結果、結果のデータフレームにゼロ列がある場合（この場合、結果はゼロ行になります）。

`combine` の場合、返されたオブジェクトの行は `GroupedDataFrame` 内のグループの順序で表示されます。関数は各グループに対して任意の数の行を返すことができますが、返されるオブジェクトの種類と列の数および名前はすべてのグループで同じでなければなりません。ただし、`DataFrame()` または `NamedTuple()` が返される場合は、特定のグループがスキップされます。

複数の変換が要求される場合、単一の値とベクトルを混在させることが許可されています。この場合、単一の値は返されたベクトルで指定された列の長さに合わせて繰り返されます。

`function` を各行に適用するには、`ByRow` 構造体でラップできます。`cols` は任意の列インデックス構文であり、この場合、`function` は `cols` で指定された各列の引数を1つ受け取るか、`AsTable` で指定された場合はそれらの `NamedTuple` を受け取ります。`ByRow` が使用される場合、`cols` が空の列のセットを選択することが許可され、この場合、`function` は引数なしで各行に対して呼び出され、空の `NamedTuple` が空の列のセットが `AsTable` でラップされている場合に渡されます。

列名のコレクションが渡された場合、ターゲットデータフレームで重複した列名を要求することが許可されます（例：`select!(df, [:a], :, r"a")` が許可されます）および最初の出現のみが使用されます。特に、列 `:col` をデータフレームの最初の位置に移動する構文は `select!(df, :col, :)` です。逆に、リネーム、変換、および単一列選択操作の出力列名は一意でなければならないため、例えば `select!(df, :a, :a => :a)` または `select!(df, :a, :a => ByRow(sin) => :a)` は許可されません。

一般に、変換によって返される列は、ターゲットデータフレームにコピーなしで保存されます。このルールの例外は、ソースデータフレームの列がターゲットデータフレームで再利用される場合です。これは、次のような式を介して発生する可能性があります：`:x1`、`[:x1, :x2]`、`:x1 => :x2`、`:x1 => identity => :x2`、または `:x1 => (x -> @view x[inds])`（最後のケースでは、ソース列はビューを介して間接的に再利用されます）。このような場合の動作は、`copycols` キーワード引数の値によって異なります：

  * `copycols=true` の場合、そのような変換の結果は常にソース列またはそのビューのコピーを実行します。
  * `copycols=false` の場合、ターゲットデータフレームに同じ列を複数回保存するのを避けるためにのみコピーが実行されます。より正確には、列が最初に使用されるときはコピーは行われませんが、ソース列の各後続の再利用（ソース列のビューを除外して `===` を使用して比較する場合）ではコピーが実行されます。

`transform!` または `select!` を実行することは、`copycols=false` を前提としています。

`df` が `SubDataFrame` であり、`copycols=true` の場合、`DataFrame` が返され、同じコピー規則が `DataFrame` 入力に適用されます。これは特に、選択された列がコピーされることを意味します。`copycols=false` の場合、列をコピーせずに `SubDataFrame` が返され、この場合、列の変換またはリネームは許可されません。

`GroupedDataFrame` が渡され、`threads=true`（デフォルト）である場合、指定された各変換に対して別のタスクが生成されます。各変換は、Julia スレッドの数だけタスクを生成し、グループの処理をそれらに分割します（ただし、現在、`sum` のような最適化された実装を持つ変換や、複数の行を返す変換は、すべてのグループに対して単一のタスクを使用します）。これにより、Julia が複数のスレッドで起動された場合に並列操作が可能になります。したがって、渡された変換関数はグローバル変数を変更してはならず（つまり、純粋でなければなりません）、並列アクセスを制御するためにロックを使用するか、マルチスレッドを無効にするために `threads=false` を渡す必要があります。将来的には、並列処理が他のケースにも拡張される可能性があるため、この要件は `DataFrame` 入力にも適用されます。

操作のパフォーマンスを向上させるために、一部の変換は最適化された実装を呼び出します。詳細については、[`DataFrames.table_transformation`](@ref) を参照してください。

# キーワード引数

  * `renamecols::Bool=true` : `cols => function` 形式で自動生成された列名に変換関数の名前を含めるべきかどうか。
  * `ungroup::Bool=true` : `gd` に対する操作の返り値がデータフレームであるべきか、`GroupedDataFrame` であるべきか。
  * `threads::Bool=true` : 変換が並列で実行できる別のタスクで実行される可能性があるかどうか（同時に複数の行またはグループに適用される可能性があります）。タスクが実際に生成されるかどうか、およびその数は自動的に決定されます。いくつかの変換が直列実行を必要とする場合やスレッドセーフでない場合は、`false` に設定してください。

メタデータ：この関数は、テーブルレベルの `:note` スタイルのメタデータを伝播します。列レベルの `:note` スタイルのメタデータは、次の条件を満たす場合に伝播されます：a) 単一の列が単一の列に変換され、列の名前が変更されない場合（これにはすべての列選択操作が含まれます）、または b) 単一の列が `identity` または `copy` で単一の列に変換される場合、列名が変更されても（これには列のリネームが含まれます）。特別なケースとして、`GroupedDataFrame` の場合、出力がグループ化列と同じ名前を持ち、`keepkeys=true` の場合、メタデータは元のグループ化列から取得されます。

例については、[`select`](@ref) を参照してください。
