```
hcubature(f, a, b; norm=norm, rtol=sqrt(eps), atol=0, maxevals=typemax(Int),
initdiv=1, buffer=nothing)
```

関数 `f(x)` の n 次元積分を計算します。ここで `n == length(a) == length(b)` であり、ベクトル（またはタプル） `a` と `b` によって与えられるハイパーキューブのコーナー上で積分を行います。つまり、次元 `x[i]` は `a[i]` から `b[i]` まで積分されます。`hcubature` の戻り値は、推定された積分 `I` と推定誤差 `E` のタプル `(I, E)` です。

`f` は n 次元ベクトル `x` を受け取り、`x` における被積分関数を返す関数 `f(x)` である必要があります。被積分関数は、`+`、`-`、`*` の実数および `norm` 関数をサポートする任意の型であることができます。たとえば、被積分関数は実数または複素数、ベクトル、行列などである可能性があります。

被積分関数 `f(x)` は常に `SVector{n,T}` が渡されます。ここで `SVector` は `StaticArrays` パッケージで定義された効率的なベクトル型であり、`T` はエンドポイント `a` と `b` の座標を浮動小数点型に昇格させることによって決定される浮動小数点型です。（あなたの被積分関数 `f` は型安定である必要があります：このタイプの `x` が与えられたとき、常に同じ型の値を返すべきです。）

被積分関数は、積分体積の境界で正確に評価されることは決してありません。（したがって、たとえば、境界で爆発する被積分関数を持つことが可能ですが、積分が有限である限り、そうした特異点は収束を遅くします。）

積分体積は、Genz と Malik（1980）によるキュバチュアルールを使用して適応的に細分化され、推定誤差 `E` が `E ≤ max(rtol*norm(I), atol)` を満たすまで続けられます。ここで `rtol` と `atol` はそれぞれ要求された相対および絶対許容誤差です。また、`f` の評価回数が `maxevals` を超えた場合にも停止します。`atol` または `rtol` のいずれも指定されていない場合、デフォルトの `rtol` は上記の座標型 `T` の精度 `eps(T)` の平方根です。最初は、体積は各次元に沿って `initdiv` セグメントに分割されます。

誤差は `norm(I - I′)` によって推定され、ここで `I′` は別の推定積分（「埋め込まれた」低次のキュバチュアルールによる）です。デフォルトでは、使用されるノルム関数（上記の収束テストのためにも）は `norm` ですが、`norm` キーワード引数を使用して代替のノルムを渡すことができます。（これは、`f` が異なるスケーリングを持つ被積分関数のベクトルを返す場合に特に便利です。）

通常の使用では、`hcubature(...)` は内部計算のためにバッファを割り当てます。代わりに、`hcubature_buffer'(@ref)` を使用して事前に割り当てられたバッファを `buffer` 引数として渡すことができます。このバッファは、繰り返しの割り当てを避けるために複数の呼び出しで使用できます。
