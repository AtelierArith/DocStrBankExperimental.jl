```
bin(f::Function, left_bin_edges::AbstractRange, xs, ys, args...; kwargs...) -> Vector{T} where T
```

`ys`の要素を、`left_bin_edges`で定義された`N`のグリッドポイントに基づいて、`xs`の値がどのように分布しているかに応じて、`N-1`の異なるビンベクトルに分配します。もし`xs[i]`が`n`-番目のビン区間に入る場合、`ys[i]`は`n`-番目のビンベクトルに割り当てられます。もし`xs[i]`がグリッドの外にある場合、対応する`ys[i]`は無視されます。詳細は[`bin!`](@ref)を参照してください。

次に、要約関数を各ビンベクトルに要素ごとに適用し、`args`と`kwargs`を引数およびキーワード引数として使用します。その後、各ビンに対して`N-1`の要約値が返されます。空のビンには`NaN`値が割り当てられます。

`N-1`のビン要約を返します。

## 例

### 各ビンに要約関数を適用する

値のベクトルを受け入れる任意の関数を`bin`と組み合わせて使用できます。

```julia
xs = [1.2, 1.7, 2.2, 3.3, 4.5, 4.6, 7.1]
ys = [4.2, 5.1, 6.5, 4.2, 3.2, 3.1, 2.5]
left_bin_edges = 0.0:1.0:6.0
bin(median, left_bin_edges, xs, ys)
```

追加の引数を持つ関数も機能します（引数とキーワード引数は関数呼び出しの最後に指定する必要があります）：

```julia
xs = [1.2, 1.7, 2.2, 3.3, 4.5, 4.6, 7.1]
ys = [4.2, 5.1, 6.5, 4.2, 3.2, 3.1, 2.5]
left_bin_edges = 0.0:1.0:6.0
bin(quantile, left_bin_edges, xs, ys, [0.1])
```
