```
standardMC(X::AbstractGraph, β::Real, iters::Integer; keywords...)
```

与えられたイジングスピンモデル `X` に対して、逆温度 `β` で標準メトロポリスモンテカルロアルゴリズムの `iters` 回の反復を実行します。各スピン反転の試行は反復としてカウントされます。

2つのオブジェクトを返します：エネルギーのベクトルと最後の構成（[`Config`](@ref）を参照）。

可能なキーワード引数は次のとおりです：

  * `step`: エネルギーを収集する反復の間隔（返される結果用）および `hook` 関数を呼び出すための間隔（上記参照）。デフォルトは `1` で、デバッグには良いですが、一般的にはあまり良いアイデアではありません。
  * `seed`: ランダムシード。デフォルトは任意の数です。
  * `C0`: 初期構成。デフォルトは `nothing` で、その場合はランダムに初期化されます。それ以外の場合は [`Config`](@ref) オブジェクトである必要があります。前回の実行の結果を渡すことは、シミュレーテッドアニーリングプロトコルを実装する際や、システムがまだ平衡に達していない場合に便利です。
  * `hook`: 各 `step` 回の反復後に実行される関数（上記参照）。5つの引数を取る必要があります：現在の反復、グラフ `X`、現在の構成、これまでに受け入れられた移動の数、現在のエネルギー。エネルギー以外のデータを収集したり、ファイルに書き込んだりするのに便利です；クロージャを使用することをお勧めします。以下の例を参照してください。戻り値は `Bool` でなければなりません：シミュレーションを中断するには `false` を返し、それ以外の場合は `true` を返します。デフォルトは何もしないで `true` を返します。

基本的な例：

```
julia> Random.seed!(76543); X = RRRMC.GraphPSpin3(3999, 5); β = 1.0;
julia> Es, C = standardMC(X, β, 100_000, step = 1_000);
```

`BitMatrix` の列としてサンプルを収集するための `hook` の使用例：

```
julia> iters = 100_000; step = 1_000; l = iters ÷ step; N = RRRMC.getN(X);
julia> Cs = BitArray(undef, N, l); hook = (it, X, C, acc, E) -> (Cs[:,it÷step]=C.s; true);
julia> Es, C = standardMC(X, β, iters, step = step, hook = hook);
```
