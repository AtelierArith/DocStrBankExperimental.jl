```
extremal_opt(X::AbstractGraph, τ::Real, iters::Integer; keywords...)
```

極値最適化アルゴリズム：これは、与えられたイジングスピンモデル `X` の最低エネルギー状態を求めるもので、低エネルギー状態に偏ったランダムウォークを行いますが、重い尾を持っているため、トラップにかかるのを避けることができます。

インターフェースは [`standardMC`](@ref) や他の RRRMC モンテカルロ関数と非常に似ていますが、`β` の代わりにパラメータ `τ` を取り、戻り値が異なり、`hook` キーワード引数のシグネチャが異なります。詳細は以下を参照してください。

パラメータ `τ` は尾の形状を制御し、1 より大きい必要があります（妥当な値は 1.3 かもしれません）；`iters` は実行されるスピンフリップの総数です。

この関数には [`DiscrGraph`](@ref) モデル用の特化版があります。それ以外の場合は動作しますが、現時点では非常に効率的に実装されていません（希薄グラフでも各スピンフリップに O(N) 時間がかかります）。

4 つのオブジェクトを返します：最終構成、見つかった最小エネルギー、最小エネルギーの構成、およびそのような構成が見つかったイテレーション（[`Config`](@ref) を参照）。

可能なキーワード引数は次のとおりです：

  * `step`：`hook` 関数を呼び出すイテレーションの間隔（下記参照）。デフォルトは `1` で、デバッグには良いですが、一般的にはあまり良いアイデアではないでしょう。
  * `seed`：ランダムシード。デフォルトは任意の数です。
  * `C0`：初期構成。デフォルトは `nothing` で、その場合はランダムに初期化されます。それ以外の場合は [`Config`](@ref) オブジェクトである必要があります。
  * `hook`：各 `step` 回のイテレーション後に実行される関数（上記参照）。5 つの引数を取る必要があります：現在のイテレーション、グラフ `X`、現在の構成、現在のエネルギー、およびこれまでに見つかった最小エネルギー。エネルギー以外のデータを収集したり、ファイルに書き込んだりするのに便利です；クロージャを使用することをお勧めします。以下の例を参照してください。戻り値は `Bool` でなければなりません：シミュレーションを中断するには `false` を返し、それ以外の場合は `true` を返します。デフォルトは何もしないで `true` を返します。シグネチャは [`standardMC`](@ref) の対応する `hook` 引数のものに似ていますが、異なります。

基本的な例：

```
julia> Random.seed!(76543); X = RRRMC.GraphPSpin3(3999, 5); τ = 1.3;
julia> C, Emin, Cmin, itmin = extremal_opt(X, τ, 100_000, step = 1_000);
```

`BitMatrix` の列としてサンプルを収集するための `hook` の使用例：

```
julia> iters = 100_000; step = 1_000; l = iters ÷ step; N = RRRMC.getN(X);
julia> Cs = BitArray(undef, N, l); hook = (it, X, C, E, Emin) -> (Cs[:,it÷step]=C.s; true);
julia> C, Emin, Cmin, itmin = extremal_opt(X, τ, iters, step = step, hook = hook);
```
