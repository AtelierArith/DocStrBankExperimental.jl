```
SimpleColloc(dyn, Ts, nx, na, nu; n = 5, abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)
SimpleColloc(dyn, Ts, x_inds, a_inds, nu; n = 5, abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)
```

手動でステップを踏むことができるシンプルな直接コロケーションインテグレーターで、[`SeeToDee.Rk4`](@ref)によって返される関数に似ています。

このインテグレーターは微分代数方程式（DAE）をサポートしており、ダイナミクスは以下のいずれかの形式であることが期待されます。

  * `nx,na` が提供される場合: `(xz,u,p,t)->[ẋ; res]` ここで `xz` は微分状態 `x` と代数変数 `z` をこの順序で含むベクトル `[x; z]` です。`res` は代数残差であり、`u` は制御入力です。したがって、代数残差はダイナミクスによって返される配列の最後の `na` 要素であると仮定されます（ModelingToolkitで使用される慣例）。
  * `x_inds, a_inds` が提供される場合: `(xz,u,p,t)->xzd` ここで `xzd[x_inds] = ẋ` および `xzd[a_inds] = res` です。

返される関数のシグネチャは `f_discrete : (x,u,p,t)->x(t+Tₛ)` です。

このインテグレーターは、ダイナミクスの完全暗黙的形式もサポートしています。

$$
0 = F(ẋ, x, u, p, t)
$$

このインターフェースを使用する場合、ダイナミクスは最初の引数として追加の入力 `ẋ` を使用して呼び出され、戻り値は全体の状態記述子の残差であることが期待されます。暗黙的形式を使用するには、`residual = true` を渡します。

ダイナミクスを離散化するためにガウス・ラドゥコロケーション法が使用されます。結果として得られる非線形問題は（デフォルトで）ニュートン・ラフソン法を使用して解決されます。この方法は硬いダイナミクスを処理します。

# 引数:

  * `dyn`: ダイナミクス関数（連続時間）
  * `Ts`: サンプル時間
  * `nx`: 微分状態変数の数
  * `na`: 代数変数の数
  * `x_inds, a_inds`: `nx` と `na` の代わりにインデックスが提供される場合、質量行列は対角行列であると仮定され、`x_inds` に1が、`a_inds` に0が配置されます。最大の効率を得るために、これらのインデックスを単位範囲または静的配列として提供してください。
  * `nu`: 入力の数
  * `n`: コロケーションポイントの数。`n=2` は台形積分に対応します。
  * `abstol`: 根を見つけるアルゴリズムの許容誤差
  * `residual`: `true` の場合、ダイナミクス関数は全体の状態記述子の残差を返すと仮定され、シグネチャは `(ẋ, x, u, p, t) -> res` です。これは時々「完全暗黙的形式」と呼ばれます。
  * `solver`: 根を見つける問題に使用する任意の互換性のあるSciML非線形ソルバー

# 拡張ヘルプ

  * このインテグレーターはスーパーサンプリングをサポートしていませんが、同じ入力とサンプル時間 `Ts / supersample` でループ内で `supersample` 回ステップを踏む関数で簡単にラップすることができます。

```
