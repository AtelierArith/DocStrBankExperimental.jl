```
estimate_delay(s, method::String [, τs = 1:100]; kwargs...) -> τ
```

[`embed`](@ref)で使用する最適な遅延を推定します。`method`は以下のいずれかである必要があります：

  * `"ac_zero"` : 自己相関関数が<0になる最初の遅延。
  * `"ac_min"` : 自己相関関数の最初の最小値の遅延。
  * `"mi_min"` : `s`自身との相互情報の最初の最小値の遅延（さまざまな`τs`にシフト）。キーワード`nbins, binwidth`は[`selfmutualinfo`](@ref)に伝播されます。
  * `"exp_decay"` : 相関関数の[`exponential_decay_fit`](@ref)を整数に丸めたもの（`c(t) = exp(-t/τ)`に対して最小二乗法を使用して`τ`を求めます）。
  * `"exp_extrema"` : 上記と同じですが、相関関数の局所的な極値の絶対値に対して指数フィットが行われます。

相互情報と相関関数（`autocor`）は、*遅延`τs`に対してのみ*計算されます。これは、`min`メソッドが`τs`の最初の値を返すことができないことを意味します！

`mi_min`メソッドは他のメソッドよりもかなり正確であり、ほとんどの時系列に対して良好な結果を返します。ただし、最も遅いメソッドですが（それでもかなり速いです！）。
