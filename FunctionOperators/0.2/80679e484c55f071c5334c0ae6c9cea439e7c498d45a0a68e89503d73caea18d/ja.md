**リサイクルマクロ**: マークされた操作の出力用の配列を事前に割り当てることによって、forループ内の割り当ての数を減らします。マーカー: `@♻` (`\:recycle:`)、`🔝` (`\:top:`)、`🔃` (`\:arrows_clockwise:`)、および `@🔃`

マクロ @♻ はforループの直前に置く必要があり、その後、次の置換を実行します。

  * **`🔝`でマークされた式:**

これらはループの前に計算され、結果は変数に保存され、その式はその変数に置き換えられます。ループ内で定数式が使用される場合にも便利ですが、その置換を作成する背後のアイデアは、合成FunctionMatricesのキャッシュを可能にすることです。例:

```julia
@♻ for i=1:5
    result = 🔝((FuncOp₁ + 2I) * FuncOp₂) * data
end
```

は次のように変換されます。

```julia
🔝_1 = (FuncOp₁ + 2I) * FuncOp₂
for i = 1:5
    result = 🔝_1 * data
end
```

このようにして、プランは一度だけ計算され、合成演算子の中間結果のバッファも一度だけ割り当てられます。

  * **`🔃`でマークされた式:**

これらはループの前に計算され（結果を保存するための配列を割り当てるため）、式は各ループの反復で評価されます。置換後の違いは、式の結果が常に事前に割り当てられた配列に保存されることです。例:

```julia
@♻ for i=1:5
    result = FuncOp₁ * 🔃(A + B)
end
```

は次のように変換されます。

```julia
🔃_1 = A + B
for i = 1:5
    result = FuncOp₁ * @.(🔃_1 = A + B)
end
```

この変換は最初に `🔃_1` という名前の配列を割り当て、その後の各反復で再計算され、`🔃_1` に保存され、この値が残りの操作に使用されます（すなわち: `FuncOp₁ * 🔃_1`）。`@.` マクロはインライン代入の前に挿入されることに注意してください。そうしないと、`A + B` が `🔃_1` に保存される前に新しい配列を割り当ててしまいます。**警告!** これによりコードが壊れる可能性があります。例えば、`@.(🔃_1 = A * B) ≠ (🔃_1 = A .* B)` {行列の乗算と要素ごとの乗算}! 一方で、マークされた式が乗算のみで構成されている場合、それは `mul!` の呼び出しに変換されます。例:

```julia
@♻ for i=1:5
    result = FuncOp₁ * 🔃(A * B)
end
```

は次のように変換されます。

```julia
🔃_1 = A * B
for i = 1:5
    result = FuncOp₁ * mul!(🔃_1, A, B)
end
```

  * **最後に、`@🔃`でマークされた代入:**

これらは `mul!` の呼び出しに変換されます。もちろん、`@🔃` の後に単一の乗算が右側にある代入が直接続く場合にのみ機能します。例:

```julia
@♻ for i=1:5
    @🔃 result = FuncOp₁ * A
end
```

は次のように変換されます。

```julia
result = FuncOp₁ * A
for i = 1:5
    mul!(result, FuncOp₁, A)
end
```

最終的な注意: `🔝` は任意にネストでき、`🔃` でマークされた式に埋め込むことができます。`🔃` もネストでき、`@🔃` でマークされた代入に使用することができます（もちろん `🔝` と一緒に）。
