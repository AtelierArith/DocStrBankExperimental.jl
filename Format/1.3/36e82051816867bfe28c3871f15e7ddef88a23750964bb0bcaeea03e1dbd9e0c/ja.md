Format.jl

このパッケージは、CのprintfやPythonのフォーマット文字列に似た形式でフォーマットされた出力を提供するためのさまざまな関数を提供します。

## Pythonスタイルの型と関数

#### フォーマットを表す型

このパッケージには、フォーマット仕様を表すための2つの型$FormatSpec$と$FormatExpr$があります。

特に、$FormatSpec$は単一のエントリの仕様をキャプチャするために使用されます。フォーマット仕様文字列を$FormatSpec$インスタンスにコンパイルすることができます。

```julia
fspec = FormatSpec("d")
fspec = FormatSpec("<8.4f")
```

詳細については、[Pythonのフォーマット仕様言語](http://docs.python.org/2/library/string.html#formatspec)を参照してください。

$$
FormatExpr
$$

は、複数のアイテムを含む可能性のあるフォーマット式をキャプチャします。フォーマット文字列を$FormatExpr$インスタンスにコンパイルすることができます。

```julia
fe = FormatExpr("{1} + {2}")
fe = FormatExpr("{1:d} + {2:08.4e} + {3|>abs2}")
```

詳細については、[Pythonのフォーマット文字列構文](http://docs.python.org/2/library/string.html#format-string-syntax)を参照してください。

**注意:** 同じフォーマットが複数回適用される場合は、最初にコンパイルする方が効率的です。

#### フォーマットされた印刷

$$
printfmt
$$

と$printfmtln$を使用してフォーマットされた印刷を行うことができます：

  * **printfmt**(io, fe, args...)
  * **printfmt**(fe, args...)

    指定されたフォーマット$fe$を使用して引数を印刷します。ここで$fe$はフォーマット文字列、$FormatSpec$または$FormatExpr$のインスタンスであることができます。

    **例**

    ```julia
    printfmt("{1:>4s} + {2:.2f}", "abc", 12) # –> print(" abc + 12.00")
    printfmt("{} = {:#04x}", "abc", 12) # –> print("abc = 0x0c")

    fs = FormatSpec("#04x")
    printfmt(fs, 12)   # –> print("0x0c")

    fe = FormatExpr("{} = {:#04x}")
    printfmt(fe, "abc", 12)   # –> print("abc = 0x0c")
    ```

    **注意**

    最初の引数が文字列の場合、それは最初に$FormatExpr$にコンパイルされるため、最初の引数に仕様のみの文字列を使用することはできません。

    ```julia
    printfmt("{1:d}", 10)   # OK, "{1:d}"はFormatExprインスタンスにコンパイルできます
    printfmt("d", 10)       # エラー, "d"はFormatExprインスタンスにコンパイルできません
    printfmt(FormatSpec("d"), 10)  # OK
    printfmt(FormatExpr("{1:d}", 10)) # OK
    ```
  * **printfmtln**(io, fe, args...)
  * **printfmtln**(fe, args...)

    $$
    printfmt
    $$

    に似ていますが、この関数は最後に改行を印刷します。

#### フォーマットされた文字列

$$
pyfmt
$$

を使用して単一の値を文字列にフォーマットしたり、$format$を使用してフォーマット式を使用して複数の引数を文字列にフォーマットしたりできます。

  * **pyfmt**(fspec, a)

    $$
    fspec
    $$

    で指定されたフォーマット仕様を使用して単一の値をフォーマットします。ここで$fspec$は文字列または$FormatSpec$のインスタンスであることができます。
  * **format**(fe, args...)

    $$
    fe
    $$

    で指定されたフォーマット式を使用して引数をフォーマットします。ここで$fe$は文字列または$FormatSpec$のインスタンスであることができます。

#### Pythonのフォーマットとの違い

この時点で、このパッケージはPythonのフォーマット言語のサブセットを実装しています（わずかな修正があります）。違いの概要は次のとおりです：

  * 引数仕様に関しては、自然順序（例：${} + {}$）、明示的な位置（例：${1} + {2}$）をサポートしています。名前付き引数やフィールド抽出はまだサポートされていません。これら2つのモードを混在させることは許可されていません（例：${1} + {}$）。
  * このパッケージは、${1|>lowercase}$のように明示的に位置指定された引数のフィルタリングをサポートしており、Pythonの対応する部分ではサポートされていません。

## Cスタイルの関数

このパッケージのCスタイルの部分は、`@sprintf`がリテラル文字列引数を取らなければならないという制限を回避することを目的としています。コア部分は基本的に標準の`@sprintf`マクロを使用したCスタイルの印刷フォーマッタです。また、カンマ区切り（千の区切り）、負の数のための括弧、末尾のゼロの削除、混合分数などの機能も追加しています。

### 使用法と実装

ここでのアイデアは、パッケージが`Format.*`名前空間内の各ユニークなフォーマット文字列に対して関数を1回だけコンパイルすることです。これにより、繰り返し使用が速くなります。同じフォーマット文字列を使用するセッションの無関係な部分は、同じ関数を再利用し、冗長なコンパイルを回避します。関数の増殖を避けるために、使用を1引数のみに制限します。実際の考慮事項として、セッション内で作成される関数は数十個に制限されることが示唆されており、管理可能に思えます。

使用法

```julia
using Format

fmt = "%10.3f"
s = cfmt(fmt, 3.14159) # 使用法 1. 非常にパフォーマンスが良い。切り替えが最も簡単。

fmtrfunc = generate_formatter(fmt) # 使用法 2. キャッシュされた関数の再検索を回避します。最もパフォーマンスが良い。
s = fmtrfunc(3.14159)

s = format(3.14159, precision=3) # 使用法 3. 最も柔軟で、いくつかの非printfオプションがあります。最もパフォーマンスが悪い。
```

### カンマ

このパッケージは、千の区切りが不足していることを補完します。例：`"%'d"`、`"%'f"`、`"%'g"`。

注意: `"%'g"`の動作は、十分に小さい浮動小数点数（ただし、あまりにも小さくない場合）に対して千の区切りが使用されます。数値が`"%e"`で表現される必要がある場合、区切りは使用されません。

### 柔軟な`format`関数

このパッケージには、標準の`sprintf`機能を超えるランタイム数フォーマッタ`format`関数が含まれています。

例：

```julia
s = format(1234, commas=true) # 1,234
s = format(-1234, commas=true, parens=true) # (1,234)
```

キーワード引数は次のとおりです（太字のキーワードはprintf標準ではありません）

  * width. 整数。出力をこの文字数に収めようとします。成功しない場合があります。スペースを優先し、その後カンマを使用します。
  * precision. 整数。小数点以下の桁数。
  * leftjustified. ブール値
  * zeropadding. ブール値
  * commas. ブール値。千の区切り。
  * signed. ブール値。常に+/-記号を表示しますか？
  * positivespace. ブール値。正の数の前に余分なスペースを追加しますか？（負の数ときれいに整列するため）
  * **parens**. ブール値。"-"の代わりに括弧を使用します。例：`(1.01)`の代わりに`-1.01`。金融で便利です。`signed`と`parens`オプションを同時に使用することはできません。
  * **stripzeros**. ブール値。小数点の右側の末尾の'0'を削除します（および、あれば'e'の左側の'0'も）。

      * すべての末尾の桁がゼロの場合、小数点自体を削除することがあります。
      * 精度が指定されていない場合はデフォルトでこれが真であり、その逆も同様です。
  * alternative. ブール値。標準printfドキュメントの`#`代替形式の説明を参照してください。
  * conversion. length=1 string. デフォルトは型依存です。`aAeEfFoxX`のいずれかである可能性があります。標準printfドキュメントを参照してください。
  * **mixedfraction**. ブール値。数が有理数の場合、混合分数でフォーマットします。例：`1_1/2`の代わりに`3/2`
  * **mixedfractionsep**. デフォルトは`_`
  * **fractionsep**. デフォルトは`/`
  * **fractionwidth**. 整数。分数部分がこの幅になるまで、分子にゼロをパディングしようとします。
  * **tryden**. 整数。小さなものの代わりにこの分母を使用しようとします。精度を失う場合は無操作です。
  * **suffix**. 文字列。この文字列は出力に追加されます。単位/％に便利です。
  * **autoscale**. シンボル、デフォルトは`:none`。`:metric`、`:binary`、または`:finance`のいずれかです。

      * `:metric`は、大きな数と小さな数のための一般的なSIシンボルを実装します。例：`M`、`k`、`μ`、`n`
      * `:binary`は、大きな数のための一般的なISQシンボルを実装します。例：`Ti`、`Gi`、`Mi`、`Ki`
      * `:finance`は、大きな数のための一般的な金融/ニュースシンボルを実装します。例：`b`（十億）、`m`（百万）
