```
scan(y, G, K; optional inputs) 
scan(y, G, Z, K; optional inputs) - 追加の共変量 Z をモデル化する場合

# 必要な入力

  * `y::Array{Float64, 2} or Array{Float64, 1}`: N 測定の単一の単変量定量的形質 (次元: N*1)
  * `G::Array{Float64, 2}`: p のテストされたマーカーにおける遺伝子型確率の行列 (次元: N*p)
  * `K::Array{Float64, 2}`: N 人の被験者の遺伝的関連性行列 (次元:N*N)

# オプションの入力

## 必須の入力:

  * `addIntercept::Bool`: 設計行列に切片列を追加するオプション (デフォルト: true)
  * `reml::Bool`: 分散成分を推定するためのスキームのオプション (REML または ML による; デフォルト: false)
  * `assumption::String`: 各マーカーの分散成分を独立に推定するか ("alt")、または帰無モデルのために一度推定し、すべてのマーカーのテストに使用するか ("null") を示すキーワード引数 (デフォルト: "null")
  * `output_pvals::Bool`: LRT p 値を追加で報告するオプション (デフォルト: false)

## 追加の共変量のモデル化:

  * `Z::AbstractArray{Float64, 2}`: 追加の非遺伝的共変量の行列 (テストされたマーカーに対して独立であるべき)

## 順列検定:

  * `permutation_test::Bool`: 研究された単一の形質に対して順列検定を実施するオプション (デフォルト: false)
  * `nperms::Int64`: 必要な順列の数、整数 (デフォルト: 1024)
  * `rndseed::Int64`: 元の形質のランダムシャッフルを実行するために設定された整数の乱数シード (デフォルト: 0)

## 重み付き残差分散の構造:

  * `weights::Array{Float64, 1}`: 形質の残差分散の不均等で重み付けされた構造をモデル化するためのオプションの重み (デフォルト: Missing、すなわち等しい残差分散)

## 数値技術 - 遺伝率最適化ステップを安定させるため

  * `optim_interval::Int64`: 遺伝率の区間 [0, 1) を分割した領域の数 (ブレント法) に対して各数値最適化スキームを実行する (デフォルト: 1、すなわち全体の区間)
  * `prior_variance::Float64`: 事前のスケールパラメータのスケールされた逆カイ二乗分布の残差分散 (デフォルト: 0)
  * `prior_sample_size::Float64`: 事前のスケールされた逆カイ二乗分布の残差分散の自由度パラメータ (デフォルト: 0)

## プロファイル尤度の検査 - 遺伝率推定値の関数として

  * `ProfileLL::Bool`: 異なる h2 値の下でのプロファイル尤度関数の値を返すオプション (デフォルト: false)
  * `markerID::Int64`: 興味のあるマーカーの ID
  * `h2_grid::Array{Float64, 1}`: 対応するプロファイル尤度値を計算するための異なる h2 値 (デフォルト: 空の配列)

## その他の入力:

  * `method::String`: モデル評価のための行列因子分解スキームを示すキーワード; "qr" または "cholesky" 分解のいずれか (デフォルト: "qr")
  * `decomp_scheme::String`: 親族行列の分解スキームを示すキーワード; "eigen" または "svd" 分解のいずれか (デフォルト: "eigen")

# 返される値:

単一形質スキャン関数の出力はオブジェクトです。ユーザーの入力とオプションに応じて、出力オブジェクトのフィールドは異なります。たとえば、`out` という名前の返された出力について:

## Null-LMM: h2 値の "Null" 近似によって、すべてのマーカーのテストに適用:

  * `out.sigma2_e::Float64`: 帰無モデルから推定された残差未説明分散
  * `out.h2_null::Float64`: 帰無モデルから推定された遺伝率 (h2)
  * `out.lod::Array{Float64, 1}`: LOD スコアからなる 1 次元配列

## Exact-LMM: 各マーカーをテストしながら h2 と sigma2_e を独立に再推定:

  * `out.sigma2_e::Float64`: 帰無モデルから推定された残差未説明分散
  * `out.h2_null::Float64`: 帰無モデルから推定された遺伝率 (h2)
  * `out.h2_each_marker::Array{Float64, 1}`: 各マーカーのモデルに対する推定された遺伝率の 1 次元配列
  * `out.lod::Array{Float64, 1}`: LOD スコアからなる 1 次元配列

## Null-LMM および順列検定が必要な場合:

  * `out.sigma2_e::Float64`: 帰無モデルから推定された残差未説明分散
  * `out.h2_null::Float64`: 帰無モデルから推定された遺伝率 (h2)
  * `out.lod::Array{Float64, 1}`: LOD スコアからなる 1 次元配列
  * `out.L_perms::Array{Float64, 2}`: 順列検定からの LOD スコアの 2 次元配列; 各列は、各順列コピーの p の LOD スコアの長さ p のベクトルです。

## p 値を報告するオプションがオンの場合、p 値の結果は次のように返されます:

  * `out.log10pvals::Array{Float64, 1}`: -log10(p 値) からなる 1 次元配列
  * `out.log10Pvals_perms::Array{Float64, 2}`: 各テストの -log10(p 値) からなる 2 次元配列

(各マーカーと各順列形質との関連をテストするため)。

## さらに、ユーザーが指定された h2 値のセットの下でプロファイル尤度値を検査したい場合:

  * `out.ll_list_null::Array{Float64, 1}`: 各 h2 値の下での帰無モデルの下での値を提供
  * `out.ll_list_alt::Array{Float64, 1}`: 各 h2 値の下でのユーザー指定のマーカーモデルの下での値を提供
```
