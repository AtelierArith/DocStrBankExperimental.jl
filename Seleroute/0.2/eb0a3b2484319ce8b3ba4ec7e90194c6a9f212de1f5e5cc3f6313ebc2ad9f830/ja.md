ネットワーク `g` のトポロジーとルーティングする需要 `k` に基づいて、不透明な `RoutingData` オブジェクトを作成します。この関数を呼び出すには時間がかかる場合があります。これは、使用するモデルのタイプに基づいて、後で使用される多くのものを事前に計算するためです。すべてのパラメータがすべてのケースで使用されるわけではありません。

常に使用されるパラメータ（最初の3つは必須で位置指定）：

  * `g` は注釈付きの有向グラフです（したがって、タイプは `MetaDiGraph` です）。各エッジは、その容量を示すプロパティ `capacity` を持つ必要があります（単位はパッケージによって課せられませんが、一貫性が必要です）。各ノードは、出力生成に使用される `name` プロパティを持っている必要があります。
  * `k` は別の有向グラフで、必ずしも注釈が必要ではありません（したがって、タイプは `AbstractSimpleGraph` です）。
  * `solver` は、この問題に使用する最適化ソルバーです（例： `CPLEX.Optimizer`）。
  * `model_type` は、無知のルーティングを計算するために使用される最適化モデルのタイプです。そのタイプは `ModelType` です。
  * `name` はモデルのオプションの名前です。

ほとんどのパラメータは常に適用され、解決性能に大きな影響を与える可能性があります：

  * `model_simplifications` は、モデル内の簡略化を有効にします。これらは、いかなる種類の近似も意味しません。モデルのどの部分を簡略化できるかを計算するのにかかる時間は、簡略化が最適化部分の実行時間を改善するのにかかる時間よりも長くなる場合があります（特に小さなネットワークや非常に高い接続性を持つネットワークの場合）。
  * `remove_unreachable_nodes` は、トポロジー `g` 内の孤立したノード、すなわち隣接ノードを持たないノードを削除するかどうかを決定します。
  * `remove_unsatisfiable_demands` は、ルーティングできない需要（すなわち、ソースから宛先への `g` 内のパスが存在しない、トポロジー `g` がこれらの2つのノード間に接続性を提供しない）を削除するかどうかを決定します。
  * `timeout`: 計算の最大時間。 `Second(0)` は制限がないことを示します。時間制限に達した場合、結果の解は `MOI.TIME_LIMIT` ステータスコードを持ち、現在の解を持ちます：最適性や実現可能性の保証はありません！
  * `enable_variable_constraint_names`: 変数と制約に名前を付けるべきかどうか。 このオプションを有効にすると（デフォルト）、モデルのデバッグが容易になります。無効にすると、特に大規模なモデルの場合、性能が向上します。

いくつかのモデルはこれらのパラメータを使用する場合があります：

  * `sub_model_type` は、カッティングプレーンを使用した無知のルーティングのように、サブプロブレムを使用するアルゴリズムによってのみ使用されます。以下のすべてのパラメータはサブプロブレムに再利用されます： `model_simplifications`、 `npaths`。
  * `npaths` は、パスベースの定式化のために事前に計算されるべき最短パスの数です。これは列生成を使用するかどうかにかかわらずです。このパスの数は*各需要*について考慮されます：生成されるパスはおそらく `npaths` より多くなりますが、需要の数の `npaths` 倍を超えることはありません。デフォルトでは、各需要に対して最大20のパスが生成されます。列生成ベースの定式化の場合、これは列の開始セットを提供します：このセットは解決プロセス中にサイズが増加する可能性があります。そうでなければ、これは問題を解決するために使用されるパスの総数です。

これらのパラメータは無知のルーティングのみに使用されます：

  * `model_all_traffic_matrices` は、無知のルーティング制約に違反するすべてのトラフィック行列を、マスタープロブレムの各イテレーションで追加するかどうかを示します（元のアルゴリズムは1つの行列のみを追加しますが、一度に複数を追加することで、実行時間を改善し、実行する必要のある総イテレーション数を減らすことができます）。
  * `model_exact_opt_d` は、追加された制約において、生成されたトラフィック行列の最適混雑が計算されるかどうかを示します。理論的には、この値は常に1.0です。
  * `model_robust_reformulation_traffic_matrices` は、ロバスト再定式化のためのトラフィック行列を計算することを可能にします。このオプションを使用すると、正しい双対値を得るために解決すべき問題の制約の数が増加します。

これらのパラメータは不確実性のない問題にのみ使用されます。

  * `traffic_matrix` は、考慮される唯一のトラフィック行列です。

これらのパラメータは解決プロセスの出力を制御するだけです：

  * `locs_f` は、グラフを2Dでプロットする際にノードの位置を計算する関数です。グラフを入力として受け取り、最初にx位置、次にy位置の2つのベクトルを出力します。
  * `logmessage` は、パッケージが任意のテキスト出力を生成するたびに呼び出される関数です。デフォルトでは、テキストはシェルにリダイレクトされます（ `println` ）。この関数は、印刷するメッセージとして単一の文字列引数を受け取る必要があります。
  * `verbose` は、この関数（パッケージ全体ではなく）が何をしているかを明示的に示すべきかどうかを示します（たとえば、需要を削除する場合）。このオプションには、長時間の操作のための通常の進行状況ログは含まれません。
  * `plot_final_results`: 解決プロセスが完了したときにプロットを生成するかどうか。
  * `plot_each_iteration`: 反復アルゴリズムの場合、各イテレーションでプロットを生成するかどうか。
  * `export_lps`: 解決されるすべての（サブ）問題のLPファイルを（可能であれば）エクスポートします。マスタープロブレムが反復的に構築される場合、各イテレーションがエクスポートされます。LP形式はMILP問題のみを表現できるため、問題のタイプと解決アルゴリズムのすべての組み合わせがこのパラメータの恩恵を受けるわけではありません。
  * `export_lps_on_error`: エラーが発生したときに解決されている（サブ）問題のLPファイルを（可能であれば）エクスポートします。LP形式はMILP問題のみを表現できるため、問題のタイプと解決アルゴリズムのすべての組み合わせがこのパラメータの恩恵を受けるわけではありません。
  * `output_folder`: すべてのファイル出力が行われるべきフォルダーです。このフォルダーは事前に存在する必要があるか、すべての出力を無効にするために空の文字列である必要があります。
