不透明データ構造は、ルーティングを計算するために使用されるすべてのパラメータのセットを保持します。

# 内部構造

これらは実装の詳細であり、いつでも進化する可能性があります。ここにある多くのパラメータは、`RoutingData`の主要な公開コンストラクタで既に文書化されています。

最初の4つのフィールドは、すべての中で最も信頼できるものです（つまり、長期間変更されない可能性が高いです）：

  * `g`: トポロジー。
  * `k`: 需要。
  * `solver`。
  * `name`。

いくつかのフィールドは、解決プロセスを構成します。

  * いくつかのパラメータは常に使用されます：

      * `model_type`。
      * `model_simplifications`。TODO: 再導入する。
      * `timeout`。
  * いくつかのパラメータは時々使用されます：

      * `sub_model_type`。
  * いくつかのパラメータは、無知のルーティングにのみ役立ちます：

      * `model_all_traffic_matrices`: カッティングプレーン実装のみに使用。
      * `model_exact_opt_d`: カッティングプレーン実装のみに使用。
      * `model_robust_reformulation_traffic_matrices`: デュアル再定式化実装のみに使用。
  * いくつかのパラメータは、不確実性のない問題にのみ役立ちます。

      * `traffic_matrix`。

いくつかのフィールドは、出力プロセスを構成します。

  * `logmessage`
  * `plot_final_results`: TODO: 再導入。
  * `plot_each_iteration`: TODO: 再導入。
  * `export_lps`
  * `export_lps_on_error`
  * `output_folder`

これらのグラフから、いくつかのデータ構造が派生します。それらのいくつかは、必要に応じて遅延計算されます（したがって、この構造の`mutable`な側面）。

  * パスベースの定式化の場合、パスは保存され、一意に識別されます：

      * `paths_edges`: すべてのパスは、エッジのリスト（Edges）として表されます。パスインデックスは常に`paths`と一貫しています。使用方法は次のとおりです：`paths_edges[path_id]`はエッジのリストです。
      * `demand_to_path_ids`: 需要（ソースから宛先へのアーク）をそのパスIDにマッピングします。
      * `path_id_to_demand`: パスIDを対応する需要にマッピングします。
  * グラフを描画するために、ノードの位置は最大1回計算されます：

      * `locs_x`: 各ノードの、グラフを描画する際のx座標（遅延作成）。
      * `locs_y`: 各ノードの、グラフを描画する際のy座標（遅延作成）。
      * `locs_f`: 要求されたときに前の2つのフィールドを計算する関数。グラフを入力として受け取り、`locs_x`と`locs_y`の2つのベクトルを出力します。

`RoutingData`オブジェクトを作成するのにかかる時間は、`time_precompute_ms`フィールドに記録されます。
