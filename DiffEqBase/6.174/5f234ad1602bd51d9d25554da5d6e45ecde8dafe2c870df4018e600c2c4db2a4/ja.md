```julia
solve(prob::AbstractDEProblem, alg::Union{AbstractDEAlgorithm,Nothing}; kwargs...)
```

## 引数

唯一の位置引数は `alg` で、これはオプションです。デフォルトでは `alg = nothing` です。`alg = nothing` の場合、`solve` は DifferentialEquations.jl の自動アルゴリズム選択にディスパッチします（`using DifferentialEquations` が行われている場合、そうでなければ `MethodError` が発生します）。

## キーワード引数

DifferentialEquations.jl の宇宙には、`solve` 関数に利用可能な一般的な引数の大規模なセットがあります。これらの引数は、任意の問題タイプの `solve` に適用され、特定の実装の制限によってのみ制限されます。

多くのデフォルトは、アルゴリズムまたはアルゴリズムが派生するパッケージに依存します。すべてのインターフェースがすべてのアルゴリズムによって提供されるわけではありません。デフォルトや特定のアルゴリズム/パッケージの利用可能なオプションに関する詳細情報については、特定の問題のソルバーのマニュアルページを参照してください。特定のパッケージが特定のオプションの使用と互換性があるかどうかを確認するには、[ソルバー互換性チャート](https://docs.sciml.ai/DiffEqDocs/stable/basics/compatibility_chart/#Solver-Compatibility-Chart)を参照してください。

### デフォルトアルゴリズムヒント

デフォルトのアルゴリズムを選択するのを助けるために、キーワード引数 `alg_hints` が `solve` に提供されています。`alg_hints` は、ソルバーに対して問題を高レベルで説明する `Vector{Symbol}` です。オプションは次のとおりです：

  * `:auto` vs `:nonstiff` vs `:stiff` - 方程式を非剛性/剛性として示します。`:auto` はデフォルトの処理アルゴリズムに剛性検出アルゴリズムを選択させます。デフォルトの処理は `:auto` を使用することにデフォルト設定されています。

現在未使用のオプションには次のものが含まれます：

  * `:interpolant` - 高精度の補間が重要であることを示します。
  * `:memorybound` - ソルバーがメモリに制約されることを示します。

この機能は、[SciMLBenchmarks.jl](https://github.com/SciML/SciMLBenchmarks.jl) のベンチマークを通じて導出されています。

#### SDE特有のアルゴリズムヒント

  * `:additive` - 基本的なSDEが加法的ノイズを持つことを示します。
  * `:stratonovich` - 解がストラトノビッチ解釈に従うべきであることを示します。

### 出力制御

これらの引数はソルバーの出力動作を制御します。デフォルトでは、最良のインタラクティブユーザーエクスペリエンスを提供するために最大出力に設定されていますが、最終的な時間点での解のみを保存するように減らすことができます。

以下のオプションはすべて出力制御に関連しています。このページの最後の「例」セクションでいくつかの使用例を参照してください。

  * `dense`: 密な（連続的な）出力に必要な追加の部分を保存するかどうかを示します。デフォルトは `save_everystep && isempty(saveat)` で、密な出力を生成する能力を持つアルゴリズムの場合、すなわちデフォルトでは `true` です。ユーザーがステップの保存をオフにしたり、`saveat` 値を選択した場合は除きます。`dense=false` の場合でも、解は関数のように動作し、`sol(t)` は保存された時間点の間の線形補間です。
  * `saveat`: 解を保存する特定の時間を示します。ソルバーは、この配列内の各時間点で最も効率的な方法で保存します。`saveat` のみが指定された場合、引数 `save_everystep` と `dense` はデフォルトで `false` になります。`saveat` に数値が指定された場合、自動的に `tspan[1]:saveat:tspan[2]` に展開されます。補間が不可能なメソッドの場合、`saveat` は `tstops` と同等になる場合があります。デフォルト値は `[]` です。
  * `save_idxs`: 保存する方程式の成分のインデックスを示します。デフォルトではすべてのインデックスが保存されます。たとえば、3次元ODEを解いている場合、`save_idxs = [1, 3]` が指定されていると、解の最初と3番目の成分のみが出力されます。この場合、出力される解は2次元になります。
  * `tstops`: タイムステッピングアルゴリズムがステップを踏む必要がある*追加の*時間を示します。これは、ソルバーが不連続性や特異点に対処するのを助けるために使用されるべきです。不連続性の正確な時間でステップを踏むことは精度を向上させます。メソッドがタイムステップを変更できない場合（固定タイムステップの多段階メソッド）、`tstops` は補間を使用し、`saveat` の動作に一致します。メソッドがタイムステップを変更できず、補間もできない場合、`tstops` は `dt` の倍数でなければならず、そうでない場合はエラーが発生します。`tstops` はまた、パラメータオブジェクトと `tspan` を受け取り、停止する時間点のベクトルを返す関数 `tstops(p, tspan)` である場合もあります。デフォルトは `[]` です。
  * `d_discontinuities:` 低次導関数における不連続性の位置を示します。これは、導関数の連続性を仮定するFSALアルゴリズムに不連続性のポイントで導関数を再評価させることになります。デフォルトは `[]` です。
  * `save_everystep`: すべてのステップで結果を保存します。デフォルトは `isempty(saveat)` が `true` の場合です。
  * `save_on`: 中間解が保存されるかどうかを示します。これは `dense`、`saveat`、`save_everystep` の設定をオーバーライドし、一部のアプリケーションで一時的に保存を手動でオフにするために使用されます。ソルバーの通常の使用では、これを変更しないでください。デフォルトは `true` です。
  * `save_start`: 初期条件が最初の時間点として解のタイプに含まれるべきかどうかを示します。デフォルトは `true` です。
  * `save_end`: 最終時間点が他の保存設定に関係なく保存されるよう強制されるかどうかを示します。デフォルトは `true` です。
  * `initialize_save`: コールバック初期化フェーズ（`u_modified=true` のとき）の後に保存するかどうかを示します。デフォルトは `true` です。

`dense` は `save_everystep=true` と `saveat=false` を必要とします。密な出力を維持しながら追加の保存が必要な場合は、[コールバックライブラリのSavingCallback](https://docs.sciml.ai/DiffEqCallbacks/stable/output_saving/#DiffEqCallbacks.SavingCallback)を参照してください。

### ステップサイズ制御

これらの引数はタイムステッピングルーチンを制御します。

#### 基本的なステップサイズ制御

これらはステッピング動作を制御するための標準オプションです。誤差推定は比較を行います

$$
err_{scaled} = err/(abstol + max(uprev,u)*reltol)
$$

スケーリングされた誤差は、与えられた局所誤差推定に対して `<1` であることが保証されています（注：誤差推定は、メソッドが別途指定しない限り局所的です）。`abstol` は非スケーリング誤差を制御し、したがってゼロ周辺の誤差と考えることができます。`reltol` は従属変数のサイズにスケールし、したがって `reltol=1e-3` はおおよそ（局所的に）3桁正しいと解釈できます。許容誤差は、`u0` に一致するサイズのベクトルを渡すことで要素ごとに指定できます。

  * `adaptive`: 適切なメソッドのために適応的タイムステッピングをオンにします。デフォルトは `true` です。
  * `abstol`: 適応的タイムステッピングにおける絶対許容誤差。これは局所誤差推定に対する許容誤差であり、必ずしもグローバル誤差ではありません（ただし、これらの量は関連しています）。決定論的方程式（ODEs/DDEs/DAEs）ではデフォルトが `1e-6`、確率方程式（SDEs/RODEs）では `1e-2` です。
  * `reltol`: 適応的タイムステッピングにおける相対許容誤差。これは局所誤差推定に対する許容誤差であり、必ずしもグローバル誤差ではありません（ただし、これらの量は関連しています）。決定論的方程式（ODEs/DDEs/DAEs）ではデフォルトが `1e-3`、確率方程式（SDEs/RODEs）では `1e-2` です。
  * `dt`: 初期ステップサイズを設定します。これは固定タイムステップメソッドのステップサイズでもあります。メソッドが適応的である場合、デフォルトは自動選択です。
  * `dtmax`: 適応的タイムステッピングの最大 `dt`。デフォルトはパッケージ依存です。
  * `dtmin`: 適応的タイムステッピングの最小 `dt`。デフォルトはパッケージ依存です。
  * `force_dtmin`: 最小 `dt` の使用を強制するかどうかを宣言します。デフォルトは `false` で、最小 `dt` に遭遇したときにソルバーが警告を出して早期に終了します。これを `true` に設定すると、ソルバーは `dt` が `dtmin` を下回らないように続行し（その場合の誤差許容を無視します）、ほとんどの相互運用パッケージとは互換性がありません。

#### 固定ステップサイズの使用

適応性がないメソッドの場合、次のルールが適用されることに注意してください：

  * `dt` が設定されている場合、アルゴリズムは各反復でサイズ `dt` でステップを踏みます。
  * `tstops` と `dt` の両方が設定されている場合、アルゴリズムはサイズ `dt` でステップを踏むか、`tstops` ポイントに到達するために小さいステップを使用します。
  * `dt` なしで `tstops` が設定されている場合、アルゴリズムは `tstops` の各値に直接ステップを踏みます。
  * `dt` も `tstops` も設定されていない場合、ソルバーはエラーをスローします。

#### [高度な適応ステップサイズ制御](https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/)

これらの引数は、適応的タイムステッピングの内部のより高度な部分を制御し、特定の問題に対してより効率的にするために主に使用されます。タイムステッピングアルゴリズムの詳細な説明については、[タイムステッピングの説明](https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#timestepping)を参照してください。

  * `internalnorm`: 誤差推定が計算されるノルム関数 `internalnorm(u,t)`。必要なのは、状態変数用の1つのディスパッチと、状態変数の要素用のもう1つのディスパッチ（スカラーのノルム）です。デフォルトはパッケージ依存です。
  * `controller`: 可能な例には [`IController`](https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.IController)、[`PIController`](https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.PIController)、[`PIDController`](https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.PIDController)、[`PredictiveController`](https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.PredictiveController) があります。デフォルトはアルゴリズム依存です。
  * `gamma`: コントローラーの適応的タイムステッピングにおけるリスクファクター γ。デフォルトはアルゴリズム依存です。
  * `beta1`: Lund安定化の α パラメータ。デフォルトはアルゴリズム依存です。
  * `beta2`: Lund安定化の β パラメータ。デフォルトはアルゴリズム依存です。
  * `qmax`: 適応的 q の最大値を定義します。デフォルトはアルゴリズム依存です。
  * `qmin`: 適応的 q の最小値を定義します。デフォルトはアルゴリズム依存です。
  * `qsteady_min`: タイムステップが一定に保たれる範囲の最小値を定義します。デフォルトはアルゴリズム依存です。
  * `qsteady_max`: タイムステップが一定に保たれる範囲の最大値を定義します。デフォルトはアルゴリズム依存です。
  * `qoldinit`: 安定化ステッピングにおける初期 `qold`。デフォルトはアルゴリズム依存です。
  * `failfactor`: 暗黙的メソッドのニュートン反復が失敗した場合にタイムステップを減少させる量。デフォルトは 2 です。

### メモリ最適化

  * `calck`: 中間補間（中間密度とも呼ばれる）の内部能力をオン/オフします。これは、解後の補間である `dense` とは異なります。デフォルトは `dense || !isempty(saveat) ||  "no custom callback is given"` です。カスタムコールバックが使用されている場合に補間を使用していない場合、メモリを節約するために補間をオフにするために使用できます。カスタムコールバックが使用されていない場合でも、統合インターフェースでの使用のために補間をオンにするために使用される場合があります。これは、アルゴリズムが自由または遅延補間（`DP8()`）を持たない場合にのみ必要です。`calck = false` の場合、`saveat` は使用できません。珍しいキーワード `calck` はイベント処理で役立つ場合があります。
  * `alias`: 解決時にエイリアスする変数を指定するフィールドを持つ `AbstractAliasSpecifier` オブジェクトです。たとえば、ODEソルバーに `u0` 配列をエイリアスするように指示するには、`ODEAliases` オブジェクトと `alias_u0` キーワード引数を使用できます。たとえば、`solve(prob,alias = ODEAliases(alias_u0 = true))` のようにします。各問題タイプに対して何がエイリアスできるかについての詳細は、その問題タイプに関連する `AbstractAliasSpecifier` のドキュメントを参照してください。すべての変数を可能な限りエイリアスするには `true` に設定し、エイリアスを無効にするには `false` に設定します。デフォルトは、すべてのフィールドが `nothing` の `AbstractAliasSpecifier` インスタンスであり、ソルバーにデフォルトの動作を使用するように指示します。

### その他

  * `maxiters`: 停止する前の最大反復回数。デフォルトは 1e5 です。
  * `callback`: コールバックを指定します。デフォルトは保存ルーチンを実行するコールバック関数です。詳細については、[イベント処理とコールバック関数のマニュアルページ](https://docs.sciml.ai/DiffEqCallbacks/stable/)を参照してください。
  * `isoutofdomain`: `isoutofdomain(u,p,t)` という関数を指定します。これが `true` を返すと、タイムステップが拒否されます。デフォルトでは無効です。
  * `unstable_check`: `unstable_check(dt,u,p,t)` という関数を指定します。これが `true` を返すと、ソルバーが終了し、警告が表示されます。デフォルトは `any(isnan,u)` で、すなわち任意の値が NaN であるかどうかをチェックします。
  * `verbose`: ソルバーが早期に終了したときに警告が表示されるかどうかを切り替えます。デフォルトは `true` です。
  * `merge_callbacks`: `prob.callback` を `solve` キーワード引数 `callback` とマージするかどうかを切り替えます。デフォルトは `true` です。
  * `wrap`: `prob.problem_type` に解のための好ましい代替ラッパータイプがある場合、解をラップするかどうかを切り替えます。速度が重要で、解の形状が重要でない場合に便利です。デフォルトは `Val(true)` です。`Val(false)` は解のラッピングをキャンセルします。
  * `u0`: 初期条件で、問題構造体で定義されたものをオーバーライドします。デフォルトは `nothing`（オーバーライドなし、`prob` で定義された `u0` を使用）です。
  * `p`: パラメータで、問題構造体で定義されたものをオーバーライドします。デフォルトは `nothing`（オーバーライドなし、`prob` で定義された `p` を使用）です。

### 進捗モニタリング

これらの引数は、ProgressLogging.jl 互換環境でのプログレスバーの使用を制御します。

  * `progress`: Juno プログレスバーをオン/オフします。デフォルトは `false` です。
  * `progress_steps`: プログレスバーの更新間のステップ数。デフォルトは 1000 です。
  * `progress_name`: プログレスバーの名前を制御します。デフォルトは問題タイプの名前です。
  * `progress_message`: プログレスバーのメッセージを制御します。デフォルトは `dt`、`t`、`u` の最大値を表示します。
  * `progress_id`: 同時シミュレーションを区別するためのプログレスログメッセージの ID を制御します。

### 誤差計算

テスト問題（例：`ODETestProblem`）を使用している場合、次のオプションは計算される誤差を制御します：

  * `timeseries_errors`: 取られたステップでの誤差の計算をオン/オフします。たとえば、`l2` 誤差など。デフォルトは `true` です。
  * `dense_errors`: 密な出力を必要とするステップでの誤差の計算をオン/オフします。`tspan` 全体で100の均等に分配されたポイントで誤差を計算します。例として `L2` 誤差があります。デフォルトは `false` です。

### 感度アルゴリズム（`sensealg`）

`sensealg` は自動微分がどのように行われるかを選択するために使用されます。詳細については、SciMLSensitivity のドキュメントを参照してください: https://docs.sciml.ai/SciMLSensitivity/stable/

## 例

以下の行は、`solve()` の構成をどのように使用できるかの例です。これらの例では、3次元ODE問題が想定されていますが、他のタイプへの拡張は簡単です。

1. `solve(prob, AlgorithmName())` : ユーザー指定のアルゴリズム（`AlgorithmName()` によって与えられる）を使用した「デフォルト」設定です。すべてのパラメータはデフォルト値を取得します。これは、解がアルゴリズムが内部で停止するステップで保存され、選択されたアルゴリズムが許可する場合は密な出力が有効になることを意味します。

他のすべての統合パラメータ（例：ステップサイズ）は自動的に選択されます。

2. `solve(prob, saveat = 0.01, abstol = 1e-9, reltol = 1e-9)` : 指定された（および等間隔の）時間間隔での正確な出力のための標準設定で、例としてフーリエ変換に使用されます。解は `tspan[1]` から始まり、0.01時間単位ごとに与えられます。キーワード `alg_hits` が指定されていないため、使用されるソルバーは `Tsit5()` です。
3. `solve(prob, maxiters = 1e7, progress = true, save_idxs = [1])` : 与えられた `tspan` が非常に長い場合、ソルバーの最大反復回数を長くすることが有用です。この例では、システムの変数の最初のもののみが保存され、サイズを保存するか、ユーザーが他の変数を気にしない場合です。最後に、`progress = true` によりプログレスバーが有効になります。
