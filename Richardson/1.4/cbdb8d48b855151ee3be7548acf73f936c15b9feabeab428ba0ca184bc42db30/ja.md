```
extrapolate(f, h; contract=0.125, x0=zero(h), power=1,
                  atol=0, rtol=atol>0 ? 0 : sqrt(ε),
                  maxeval=typemax(Int), breaktol=2)
```

`f(x)`を`f₀ ≈ f(x0)`に外挿し、`x > x0`の点（または`h < 0`の場合は`x < x0`）でのみ`f`を評価し、`x=x₀+h`からリチャードソン外挿を使用します。 これは、推定された`f(x0)`と誤差推定のタプル`(f₀, err)`を返します。

`f`の返り値は、`±`および`norm`操作をサポートする任意の型であることができます（すなわち、ノルム付きベクトル空間）。同様に、`h`と`x0`も任意のノルム付きベクトル空間にあることができ、その場合`extrapolate`は`f(x0+s*h)`のリチャードソン外挿を`s=0⁺`に対して行います（すなわち、`x`が`h`方向に沿って`x0`に近づくときの極限を取ります）。

リチャードソン外挿の各ステップでは、`x-x0`を`contract`の因子で縮小し、推定誤差が`< max(rtol*norm(f₀), atol)`になるとき、推定誤差が`breaktol`を超えて増加するとき（例えば、`f`の計算における数値誤差のため）、`f`が非有限値（`NaN`または`Inf`）を返すとき、または`f`が`maxeval`回評価されたときに停止します。関数がゼロに収束する可能性がある場合、非ゼロの`atol`を指定することをお勧めします（これは`f`のスケール/単位に依存するため、デフォルトでは設定できません）。あるいは、そのような場合、`extrapolate`は浮動小数点精度に制限されると停止します。（`breaktol=Inf`を渡すことは、初めての多項式外挿が収束しない場合でも`extrapolate`が`h`を縮小し続けることを強制するのに役立ちますが、余分な関数評価のコストがかかる可能性があります。）

`x0 = ±∞`（`±Inf`）の場合、`extrapolate`は`h`の幾何学的に*増加*する値を使用して、`x ⟶ ±∞`のときの`f(x)`の極限を計算します（`1/contract`の因子によって）。

一般に、開始`h`は`f(x0+h)`が正確かつ効率的に計算できるのに十分大きく（例えば、深刻なキャンセル誤差なしに）、`f`が`x0`と`h`の間であまり振動しないように十分小さくする必要があります。すなわち、`h`は関数`f`が大きく変化する典型的なスケールであるべきです。

技術的には、リチャードソン外挿は`f(x0+h)`が`h^power`の冪級数に展開できると仮定します。デフォルトの`power=1`は通常のテイラー級数に対応します（すなわち、`f`が`x0`で解析的であると仮定します）。これが真でない場合、`extrapolate`からの収束が遅くなる可能性がありますが、`f`に異なる（プイセウ級数）展開がある場合は、異なる値の`power`（例えば、`power=0.5`）を渡すことができます。逆に、`f`が`x0`の周りで*偶数*関数である場合、すなわち`f(x0+h) == f(x0-h)`であり、そのテイラー級数が`h`の*偶数*冪のみを含む場合、`power=2`を渡すことで収束を加速できます。
