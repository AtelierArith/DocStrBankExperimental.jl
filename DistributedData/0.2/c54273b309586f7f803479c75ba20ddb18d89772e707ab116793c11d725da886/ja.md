```
dmapreduce(val, map, fold, workers; prefetch = :all)
```

標準の `mapreduce` の分散版：関数 `map`（データに対する非修正変換）と `fold`（`map` の結果の2対1の縮約）を取り、`workers` に分散された `val` で説明されるデータに対して体系的に実行し、最終的な縮約結果を返します。

fold 操作は結合的であると仮定されていますが、可換的ではありません（半群のように）。ワーカーが存在しない場合、操作は `nothing` を返します（ゼロ要素を魔法のように呼び出すモノイドはありません :[ ）。

現在のバージョンでは、reduce ステップはメインプロセスで実行される逐次的な左折り畳みです。パラメータ `prefetch` は、いくつの未来を事前に `fetch` すべきかを示します。prefetch を増やすとスループットが向上しますが、`map` の結果が大きい場合はメモリ使用量が増加します。

# 例

```
# 分散データの平均を計算する
sum,len = dmapreduce(:myData,
    (d) -> (sum(d),length(d)),
    ((s1, l1), (s2, l2)) -> (s1+s2, l1+l2),
    workers())
println(sum/len)
```

# 複数の引数の処理（いわゆる "zipWith"）

ここでの `val` は必ずしもシンボルを指す必要はなく、引用されたタプルを簡単に渡すことができ、関数パラメータ内でアンコーテッドされます。たとえば、分散値 `:a` と `:b` は次のように結合できます：

```
dmapreduce(:((a,b)),
    ((a,b)::Tuple) -> [a b],
    vcat,
    workers())
```
