```
isgroebner(polynomials; options...)
```

Checks if `polynomials` forms a Groebner basis.

## Arguments

  * `polynomials`: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.

## Returns

  * `flag`: a bool, whether `polynomials` is a Groebner basis of the ideal generated by `polynomials`.

## Possible Options

  * `ordering`: Specifies the monomial ordering. Available monomial orderings are: 

      * `InputOrdering()` for inferring the ordering from the given `polynomials` (default),
      * `Lex()` for lexicographic,
      * `DegLex()` for degree lexicographic,
      * `DegRevLex()` for degree reverse lexicographic,
      * `WeightedOrdering(weights)` for weighted ordering,
      * `ProductOrdering(args...)` for block ordering,
      * `MatrixOrdering(matrix)` for matrix ordering.

    For details and examples see the corresponding documentation page.
  * `certify`: a bool, whether to use a deterministic algorithm. Default is `false`.
  * `seed`: The seed for randomization. Default value is `42`.

## Example

Using `DynamicPolynomials`:

```@example
using Groebner, DynamicPolynomials
@polyvar x y;
isgroebner([x*y^2 + x, y*x^2 + y])
```

Using `AbstractAlgebra`:

```@example
using Groebner, AbstractAlgebra
R, (x, y) = QQ["x", "y"]
isgroebner([x*y^2 + x, y*x^2 + y])
```

## Notes

  * The function is thread-safe.
  * For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over `GF(p)`, `Native.GF(p)`, and `QQ`.
  * The default algorithm is probabilistic (with `certify=false`). Results are   correct with high probability, however, no precise bound on the probability   is known.
