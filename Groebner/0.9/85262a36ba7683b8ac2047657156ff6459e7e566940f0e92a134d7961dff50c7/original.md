```
groebner(polynomials; options...)
```

Computes a Groebner basis of the ideal generated by `polynomials`.

## Arguments

  * `polynomials`: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.

## Returns

  * `basis`: an array of polynomials, a Groebner basis.

## Possible Options

  * `reduced`: A bool, if the returned basis must be autoreduced and unique. Default is `true`.
  * `ordering`: Specifies the monomial ordering. Available monomial orderings are: 

      * `InputOrdering()` for inferring the ordering from the given `polynomials` (default),
      * `Lex(args...)` for lexicographic,
      * `DegLex(args...)` for degree lexicographic,
      * `DegRevLex(args...)` for degree reverse lexicographic,
      * `WeightedOrdering(args...)` for weighted ordering,
      * `ProductOrdering(args...)` for block ordering,
      * `MatrixOrdering(args...)` for matrix ordering.

    For details and examples see the corresponding documentation page.
  * `certify`: A bool, whether to certify the obtained basis. When this option is   `false`, the algorithm is randomized and the result is correct with high   probability. When this option is `true`, the result is guaranteed to be   correct in case the ideal is homogeneous. Default is `false`.
  * `linalg`: A symbol, linear algebra backend. Available options are: 

      * `:auto` for the automatic choice (default),
      * `:deterministic` for deterministic sparse linear algebra,
      * `:randomized` for probabilistic sparse linear algebra.
  * `threaded`: The use of multi-threading. Available options are: 

      * `:auto` for the automatic choice (default),
      * `:no` never use multi-threading,
      * `:yes` allow the use of multi-threading.

    Additionally, it is possible to set the environment variable   `GROEBNER_NO_THREADED` to `1` to disable all multi-threading in Groebner.jl.   In this case, the environment variable takes precedence over the `threaded`   option.
  * `monoms`: Monomial representation used in the computations. Available options are: 

      * `:auto` for the automatic choice (default),
      * `:dense` for classic dense exponent vectors,
      * `:packed` for packed representation.
  * `modular`: Modular computation algorithm. Only has effect when computing basis   over rational numbers. Available options are:

      * `:auto` for the automatic choice (default),
      * `:classic_modular` for the classic multi-modular algorithm,
      * `:learn_and_apply` for the learn & apply algorithm.
  * `seed`: The seed for randomization. Default is `42`.
  * `homogenize`: Controls the use of homogenization in the algorithm. Available options are:

      * `:auto`, for the automatic choice (default).
      * `:yes`, always homogenize the input ideal,
      * `:no`, never homogenize the input ideal,

## Example

Using DynamicPolynomials.jl:

```@example
using Groebner, DynamicPolynomials
@polyvar x y
groebner([x*y^2 + x, y*x^2 + y])
```

Using AbstractAlgebra.jl:

```@example
using Groebner, AbstractAlgebra
R, (x, y) = QQ["x", "y"]
groebner([x*y^2 + x, y*x^2 + y])
```

Using Nemo.jl:

```@example
using Groebner, Nemo
R, (x, y) = GF(2^30+3)["x", "y"]
groebner([x*y^2 + x, y*x^2 + y])
```

Or, say, in another monomial ordering:

```@example
# lex with y > x
groebner([x*y^2 + x, y*x^2 + y], ordering=Lex(y, x))

# degree reverse lexicographic
groebner([x*y^2 + x, y*x^2 + y], ordering=DegRevLex())
```

## Notes

  * The function is thread-safe.
  * For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over `GF(p)`, `Native.GF(p)`, and `QQ`.
  * The default algorithm is probabilistic (with `certify=false`). Results are   correct with high probability, however, no precise bound on the probability   is known.
