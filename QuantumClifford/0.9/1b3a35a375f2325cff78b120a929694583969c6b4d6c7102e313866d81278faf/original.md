```julia
project!(
    state,
    pauli::QuantumClifford.PauliOperator;
    keep_result,
    phases
) -> Tuple{QuantumClifford.MixedStabilizer, Int64, Any}

```

Project the state of a Stabilizer on the two eigenspaces of a Pauli operator.

Assumes the input is a valid stabilizer. The projection is done inplace on that stabilizer and it does not modify the projection operator.

It returns

  * a stabilizer that might not be in canonical form
  * the index of the row where the non-commuting operator was (that row is now equal to `pauli`; its phase is not updated and for a faithful measurement simulation it needs to be randomized by the user)
  * and the result of the projection if there was no non-commuting operator (`nothing` otherwise)

If `keep_result==false` that result of the projection in case of anticommutation is not computed, sparing a canonicalization operation. This canonicalization operation is the only one potentially of cubic complexity. The rest of the calculations are of quadratic complexity.

If you need to measure a single qubit instead of a multiqubit Pauli operator, the faster [`projectX!`](@ref), [`projectY!`](@ref), and [`projectZ!`](@ref) are available.

For less boilerplate and automatic randomization of the phase use [`projectrand!`](@ref).

Here is an example of a projection destroying entanglement:

```jldoctest
julia> ghz = S"XXXX
               ZZII
               IZZI
               IIZZ";


julia> canonicalize!(ghz)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ

julia> state, anticom_index, result = project!(ghz, P"ZIII");


julia> state
+ Z___
+ Z__Z
+ _Z_Z
+ __ZZ

julia> canonicalize!(state)
+ Z___
+ _Z__
+ __Z_
+ ___Z

julia> anticom_index, result
(1, nothing)
```

And an example of projection consistent with the stabilizer state.

```jldoctest
julia> s = S"ZII
             IXI
             IIY";


julia> canonicalize!(s)
+ _X_
+ __Y
+ Z__

julia> state, anticom_index, result = project!(s, P"-ZII");


julia> state
+ _X_
+ __Y
+ Z__

julia> anticom_index, result
(0, 0x02)
```

While not the best choice, `Stabilizer` can be used for mixed states, simply by providing an incomplete tableau. In that case it is possible to attempt to project on an operator that can not be generated by the provided stabilizer operators. In that case we have `anticom_index==rank` and `result===nothing`, where `rank` is the the new rank of the tableau, one more than the number of rows in the initial tableau. However, if `keep_result` was set to `false`, then `anticom_index` would stay at zero.

```jldoctest
julia> s = S"XZI
             IZI";


julia> project!(s, P"IIX")[1]
+ X__
+ _Z_
```

If we had used [`MixedStabilizer`](@ref) we would have added the projector to the list of stabilizers.

```jldoctest
julia> s = one(MixedStabilizer, 2, 3)
+ Z__
+ _Z_

julia> project!(s, P"IIX")[1]
+ Z__
+ _Z_
+ __X
```

However, [`MixedDestabilizer`](@ref) would be an even better choice as it has $\mathcal{O}(n^2)$ complexity instead of the $\mathcal{O}(n^3)$ complexity of `*Stabilizer`.

```jldoctest
julia> s = one(MixedDestabilizer, 2, 3)
𝒟ℯ𝓈𝓉𝒶𝒷
+ X__
+ _X_
𝒳ₗ━━━
+ __X
𝒮𝓉𝒶𝒷━
+ Z__
+ _Z_
𝒵ₗ━━━
+ __Z

julia> project!(s, P"IIX")[1]
𝒟ℯ𝓈𝓉𝒶𝒷
+ X__
+ _X_
+ __Z
𝒮𝓉𝒶𝒷━
+ Z__
+ _Z_
+ __X
```

See the "Datastructure Choice" section in the documentation for more details.

See also: [`projectX!`](@ref), [`projectY!`](@ref), [`projectZ!`](@ref), [`projectrand!`](@ref)
