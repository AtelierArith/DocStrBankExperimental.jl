`A` と `B` が `N` 次元の配列であると仮定します：

```
common_indices(A, B) -> inds
```

は、`A` と `B` の両方に対して有効なすべてのインデックスの集合を返します。結果は `axes(A)` または `axes(B)` に似ており、整数値の単位範囲の `N` タプルです。

符号付きのオフセット `k` を指定することができます：

```
common_indices(A, B, ±, k)
```

これにより、`A[i]` と `B[i ± k]` が有効であるすべてのインデックス `i` の集合を取得します。ここで、`±` は `+` または `-` のいずれかです。オフセット `k` は整数のタプルまたはカートesianインデックスであることができます。

引数 `A` と `B` は、インデックスのタプルまたはインデックス範囲の両方、またはスカラーまたはインデックス範囲であり、インデックス付けされる配列のサイズまたは軸を指定します。これは次の例で使用され、オフセット `k` を考慮して、すべての有効なインデックス `i` に対して `A[i] = B[i]*C[i + k]` を行います：

```
I = common_indices(same_axes(A, B), axes(C), +, k)
@inbounds @simd for i in CartesianIndices(I)
   A[i] = B[i]*C[i + k]
end
```

`same_axes(A,B)` が呼び出されて `A` と `B` の軸が同じであることを確認し、結果として境界チェックが不要になり、ループがベクトル化のために最適化されることに注意してください。
