```
MiniLogger(; <キーワード引数>)
```

MiniLogger コンストラクタは、通常の `@info`、`@debug` コマンドで使用できるカスタムロガーを作成します。

サポートされているキーワード引数には以下が含まれます：

  * `io` (デフォルト `stdout`): `errlevel` レベル未満のログメッセージを出力するために使用される IO ストリーム。`IO` または `String` のいずれかで、後者の場合は出力ファイルの名前として扱われます。
  * `ioerr` (デフォルト `stderr`): `errlevel` レベル以上のログメッセージを出力するために使用される IO ストリーム。`IO` または `String` のいずれかで、後者の場合は出力ファイルの名前として扱われます。
  * `errlevel` (デフォルト `Error`): ログメッセージに使用する出力 IO を決定します。すべてのメッセージを `io` に送信したい場合は、このパラメータを `MiniLoggers.AboveMaxLevel` に設定します。すべてのメッセージを `ioerr` に送信したい場合は、このパラメータを `MiniLoggers.BelowMinLevel` に設定します。
  * `minlevel` (デフォルト: `Info`): このレベル未満のメッセージは無視されます。たとえば、デフォルト設定では `@debug "foo"` は無視されます。
  * `append` (デフォルト: `false`): 出力ストリームに追加するか、最初にファイルを切り詰めるかを定義します。`io` または `ioerr` がファイルパスの場合にのみ使用されます。
  * `message_mode` (デフォルト: `:squash`): メッセージが出力される前にどのように変換されるかを選択します。サポートされているモードは以下の通りです：

      * `:notransformations`: メッセージはそのまま出力され、追加の変換は行われません
      * `:squash`: メッセージは1行に圧縮され、すべての `\n` は `squash_delimiter` に変更され、`\r` は削除されます。
      * `:fullsquash`: エラースタックトレースを含むすべてのメッセージが1行に圧縮され、すべての `\n` は `squash_delimiter` に変更され、`\r` は削除されます
      * `:markdown`: メッセージはマークダウンで書かれているかのように扱われます
  * `squash_delimiter`: (デフォルト: "\t"): 圧縮モードで使用する区切り文字を定義します。
  * `flush` (デフォルト: `true`): 各ログメッセージのために IO ストリームを `flush` するかどうか。フラッシュの動作は `flush_threshold` 引数にも影響されます。
  * `flush_threshold::Union{Integer, TimePeriod}` (デフォルト: 0): この引数が非ゼロで `flush` が `true` の場合、`io` は `flush_threshold` ミリ秒ごとに1回だけフラッシュされます。つまり、2つの連続したログメッセージの間の時間が `flush_threshold` より短い場合、2つ目のメッセージはフラッシュされず、次のログイベントを待つ必要があります。
  * `dtformat` (デフォルト: "yyyy-mm-dd HH:MM:SS"): `format` 引数で `datetime` パラメータが使用される場合、この日付形式が出力タイムスタンプに適用されます。
  * `levelname` (デフォルト `string`): ログレベル名の出力を再定義することを許可します。形式は `levelname(level::LogLevel)::String` の関数である必要があります。
  * `format` (デフォルト: "[{timestamp:func}] {level:func}: {message}"): 出力ログメッセージのフォーマット。以下のキーワードを受け入れ、波括弧内に提供する必要があります：

      * `timestamp`: ログメッセージのタイムスタンプ
      * `level`: ログレベルの名前 (Debug, Info など)
      * `filepath`: ログメッセージを生成したファイルのファイルパス
      * `basename`: ログメッセージを生成したファイルのファイルパスのベース名
      * `line`: ログメッセージを生成したファイル内のログコマンドの行番号
      * `group`: ロググループ
      * `module`: ログコマンドを含むモジュールの名前
      * `id`: ログメッセージ ID
      * `message`: メッセージ自体

各キーワードは、コロンの後に波括弧内に追加される色情報を受け入れます。色は `Base.text_colors` からのものであるか、特別なキーワード `func` からのもので、後者の場合は自動的な色付けが使用されます。さらに、`bold` 修飾子は `format` 引数によって受け入れられます。たとえば: `{line:red}`、`{module:cyan:bold}`、`{group:func}` はすべてフォーマットコマンドの有効な部分です。

色情報は再帰的に適用され、上書きされないため、`{{line} {module:cyan} {group}:red}` は `{line:red} {module:cyan} {group:red}` と同等です。

フォーマットの一部が認識されたキーワードでない場合、それはそのまま使用されます。たとえば `{foo:red}` は、出力ログメッセージに "foo" という単語が赤で印刷されることを意味します。 ```
