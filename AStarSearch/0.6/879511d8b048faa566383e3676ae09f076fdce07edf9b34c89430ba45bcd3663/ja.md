astar(neighbours, start, goal;         heuristic=defaultheuristic, cost=defaultcost, isgoal=defaultisgoal, hashfn=hash, timeout=Inf, maxcost=Inf)

A*アルゴリズムを実行して、開始状態から目標条件に到達する最良のパスを取得します。最初の3つの引数のみが必須で、他はすべてオプションです。

返される構造体には、`status`フィールドがあり、これは次のいずれかのシンボルです：

  * `:success`: アルゴリズムが開始から目標までのパスを見つけた
  * `:timeout`: アルゴリズムがタイムアウトし、最良の状態への部分的なパスが`path`フィールドに返される
  * `:nopath`: アルゴリズムが目標へのパスを見つけられなかったが、最良の状態へのパスは依然として返される

他のフィールドは次のとおりです：

  * `path`: 開始状態から目標または見つかった最良の状態までの状態の配列
  * `cost`: 返されたパスのコスト
  * `closedsetsize`: アルゴリズムが目標かどうかをテストした状態の数（クローズドセットのサイズ）
  * `opensetsize`: アルゴリズムが終了したときにオープンセットにまだ残っていた状態の数

# 引数

  * `neighbours`: 状態を受け取り、隣接状態を配列（または反復可能なもの）として返す関数
  * `start`: 開始状態、状態の型は完全に制限されていない
  * `goal`: 目標状態、型は制限されておらず、通常は開始と同じ
  * `heuristic`: 状態と目標を与えられたときに、目標に到達するためのコストの推定値を返す関数。この推定値は、最良のパスを確実に得たい場合は楽観的であるべきです。最良のパスを見つけるのが非常に高価である可能性があるため、良いが保証された最適パスではないパスを望む場合は、ヒューリスティックに定数を掛けることができます。アルゴリズムは通常、はるかに速くなります。
  * `cost`: 現在の状態と隣接状態を受け取り、その状態遷移を行うコストを返す関数。デフォルトでは、すべての遷移のコストは1です。
  * `isgoal`: 状態と目標を受け取り、目標が達成されたかどうかを評価する関数（デフォルトは==）。
  * `hashfn`: 状態を受け取り、辞書のキーとして使用するコンパクトな表現を返す関数（通常はUInt、Int、Stringのいずれか）、デフォルトでは基本ハッシュ関数です。これは、重複を避けるために合成状態にとって非常に重要なフィールドです。*警告* 配列をフィールドとして持つ状態は、毎回異なるハッシュを返す可能性があります！この場合、同じ状態に対して常に同じ値を返すhashfnを渡してください！
  * `timeout`: アルゴリズムが停止するまでの秒数のタイムアウト、最も低いヒューリスティックを持つ状態への最良の部分的なパスを返します。デフォルトでは制限されていません。アルゴリズムは指定された時間を*少なくとも*実行することに注意してください。
  * `maxcost`: パスの累積コストの最大制限、これにより、目標へのパス（より大きなコストを持つ）が存在しても、:nopathの結果になる可能性があります。デフォルトではInfです。
  * `enable_closedset`: すでに訪れたノードを追跡して再訪問を避ける、状態空間グラフにループがないことがわかっている場合は、これを無効にすることをお勧めします（デフォルトはtrue）。
