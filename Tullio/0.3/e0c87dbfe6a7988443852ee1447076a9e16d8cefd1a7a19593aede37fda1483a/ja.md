```
@tullio C[i,k] := A[i,j] * B[j,k]
@tullio F[i,k] := $α * D[i].field[j] * E[col=k, row=j] + $β
```

これは、もう少し構文を理解する`@einsum`の置き換えです。右側の式は、自由インデックス`k`のすべての可能な値にわたって合計され、`:=`は新しい配列`C`を作成します。一方、`=`や`+=`は既存の配列に書き込みます。スカラー引数にはドル記号が必要です。例えば、`$α`や`A[i,$γ]`のように。

```
@tullio G[i,j] := M[i+x+1, j+y+1] * K[x,y]
@tullio H[i,j] := M[2i+x, 2j+y]  (x in -1:1, y in -1:1)
```

インデックスのシフトやスケーリングが許可されており、他のインデックスによるシフトも含まれます。範囲は、過不足のあるインデックスに対して示されるように提供できます。過剰制約がある場合、シフトされたインデックスはすべての制約によって許可される交差点を走り、シフトされていないインデックスはそれらの間の一致を要求します（例：`axes(A,2) == axes(B,1)`上記のように）。

```
@tullio (*) L[i] := A[J[k]+2, i] / B[k]^2
```

これは合計の代わりに積であり、`L[i] *= ...`（インプレース）と書くことで有効にすることもできます。`@tullio (max) M[i,j] := ...`のように、任意の還元関数を使用できます。ここで`J[k]+2`によるインデックス付けは、`issubset(J, axes(A,1) .- 2)`を要求します。

```
@tullio N[j] := sqrt <| M[i,j]^2
```

パイプ演算子`|>`と`<|`は、合計の後に関数を適用します。ここでは`N ≈ map(norm, eachcol(M))`です。アンダースコアは関数を作成します。例えば、`|> sqrt(_ / V[i])`のように、明らかに`i`は合計されてはいけません。

詳細なオプションについては、readmeを参照してください。
