```
pclqofc_hr(psys, Q, R, nh = 0; K = 1, sdeg = 0, G = I, vinit, optimizer, stabilizer,
           maxiter, vtol, Jtol, gtol, show_trace, solver, reltol, abstol, 
           N = 128, quad = false ) -> (Fopt,info)
```

最適な周期的安定化ゲイン行列 `Fopt(t)` を計算します。これは、次の形式の連続時間周期状態空間モデル `psys` に対して

```
  .
  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)  
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,
```

出力フィードバック制御則

```
u(t) = Fopt(t)*y(t),
```

が二次インデックスの期待値を最小化するようにします。

```
         ∞
 J = E{ Int [x(t)'*Q(t)*x(t) + u(t)'*R(t)*u(t)]dt },
        t=0
```

ここで `Q(t)` と `R(t)` は周期的重み行列です。システム `psys` の行列は `HarmonicArray` 型です。制御入力 `u(t)` の次元 `m` と測定可能な出力 `y(t)` の次元 `p` を持つ次数 `n` のシステムに対して、`Q(t)` と `R(t)` はそれぞれ `n×n` および `m×m` の対称周期行列であり、`HarmonicArray` 型です。`u(t)` の次元 `m` は `R(t)` の次元から推測されます。`Q` と `R` は定数実行列としても提供できます。

得られる `m×p` の周期的出力フィードバックゲイン `Fopt(t)` は `HarmonicArray` 型であり、次のように計算されます。`Fopt(t) = inv(I+F(t)D(t))*F(t)` で、`F(t)` は調和表現形式で次のように表されます。

```
              nh
 F(t) = F0 +  ∑ ( Fc_i*cos(i*t*2*π/T)+Fs_i*sin(i*2*π*t/T) ) ,
             i=1
```

ここで `T` はシステムの周期、`F0` は定数項、`Fc_i` は `i` 番目のコサイン係数行列、`Fs_i` は `i` 番目のサイン係数行列です。デフォルトでは、調和数は `nh = 0` です（すなわち、定数出力フィードバックが使用されます）。

初期状態 `x(0)` の共分散行列はキーワード引数 `G` を介して指定できます（デフォルト: `G = I`）。閉ループ特性指数の望ましい安定度はキーワード引数 `sdeg` を使用して指定できます（デフォルト: `sdeg = 0`）。

最適フィードバックゲイン `F0`、`Fc_i` および `Fs_i` を `i = 1, ...., nh` のために決定するために、最適化パッケージ [`Optim.jl`](https://github.com/JuliaNLSolvers/Optim.jl) で利用可能なツールを使用した最適化ベースのアプローチが採用されます。デフォルトでは、制約のない最小化のために勾配ベースの制限付きメモリ準ニュートン法（`L-BFGS` とも呼ばれる）が使用され、キーワード引数 `optimizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))` で設定されます。ここで、ラインサーチアルゴリズムの初期ステップ長はキーワード引数 `alphaguess` を使用して選択されます（代替オプションについては [`LineSearches.jl`](https://github.com/JuliaNLSolvers/LineSearches.jl) パッケージを参照してください）。使用されるデフォルトのラインサーチアルゴリズムは `HagerZhang()` であり、代替手法はキーワード引数 `linesearch` を使用して指定できます（例: `linesearch = LineSearches.MoreThuente()`）。勾配ベースの他の手法も選択できます。例えば、準ニュートン法 `BFGS` を `optimizer = Optim.BFGS()` で使用するか、小規模最適化問題の場合は、勾配フリー法のネルダー・ミードを `optimizer = Optim.NelderMead()` で使用します。関数 `J` とその勾配 `∇J` の計算には、[1] で開発された安定システム用の式が使用されます。各評価には、[2] で提案された単一または複数のシューティング法を使用して、周期的リャプノフ微分方程式のペアの解法が含まれます。元のシステム `psys` が不安定な場合、安定化フィードバックの計算は、`A(t)-αI` の形式の状態行列を修正したシステムに対して同じ最適化技術を反復的に適用することによって行われます。ここで `α ≥ 0` は `A(t)-αI` が安定であるように選択され、安定化が達成されるまで `α` の値は順次減少されます。安定化のための最適化手法はキーワード引数 `stabilizer` を使用して独立して選択でき、デフォルト設定は `stabilizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))` です。安定化のみが望ましい場合は、`optimizer = nothing` を使用します。

内部最適化変数 `v` は、`m*p*(2*nh+1)` 次元のベクトル `v := [vec(F0); vec(Fc_1); vec(Fs_1), ... ; vec(Kc_nh); vec(Ks_nh)]'` として形成されます。デフォルトでは、`v` は `v = 0`（すなわち、適切な次元のゼロベクトル）として初期化されます。キーワード引数 `vinit = v0` を使用して、任意のベクトル `v0` で `v` を初期化できます。

最適化プロセスは、いくつかのキーワードパラメータを使用して制御されます。キーワードパラメータ `maxiter = maxit` を使用して、実行される最大反復回数を指定できます（デフォルト: `maxit = 1000`）。キーワード引数 `vtol` は、最適化変数 `v` の変化における絶対許容誤差を指定するために使用できます（デフォルト: `vtol = 0`）。キーワード引数 `Jtol` は、最適化基準 `J` の変化における相対許容誤差を指定するために使用できます（デフォルト: `Jtol = 0`）、`gtol` は勾配 `∇J` の絶対許容誤差を無限ノルムで指定するために使用できます（デフォルト: `gtol = 1e-5`）。キーワード引数 `show_trace = true` を使用すると、最適化アルゴリズムの状態のトレースが `stdout` に表示されます（デフォルト `show_trace = false`）。安定化の目的のために、値 `Jtol = 1.e-3`、`gtol = 1.e-2`、`maxit = 20` が使用され、より速い収束が促進されます。

返される名前付きタプル `info` には `(fopt, sdeg0, sdeg, vopt, optres)` が含まれます。ここで：

`info.fopt` は最適な性能 `J` の結果値です。

`info.sdeg0` は閉ループ特性指数の初期安定度です。

`info.sdeg` は閉ループ特性指数の結果的な安定度です。

`info.vopt` は最適化変数 `v` の結果値です。

`info.optres` は [`Optim.jl`](https://github.com/JuliaNLSolvers/Optim.jl) パッケージの `Optim.optimize(...)` 関数によって返される結果です。このパッケージによって提供されるいくつかの関数を使用して、最適化結果に関連するさまざまな情報を照会できます（このパッケージのドキュメントを参照してください）。

いくつかのキーワード引数を使用して、関数および勾配評価のための周期的リャプノフ方程式の解法に関与するODEの統合を制御できます。

`K = 1`（デフォルト）の場合、周期的生成器を計算するために単一シューティング法が使用されます [1]。`K > 1` の場合、[2] の複数シューティング法が最初に使用され、連続時間周期リャプノフ微分方程式を `K` グリッドポイントで生成器解を満たす離散時間周期リャプノフ方程式に変換し、その後、周期的シュール法 [3] を使用して適切な離散時間周期リャプノフ方程式を解くことによって解を計算します。`quad = true` の場合、勾配の評価には [1] で提案された積分に基づく評価が使用され、補間技術と組み合わせて使用されます。補間に使用するサンプル値の数はキーワードパラメータ `N` で指定できます（デフォルト: `N = 128`）。

連続時間問題を離散時間問題に変換するために使用されるODEソルバーは、キーワード引数 `solver` を使用して指定でき、必要な相対精度 `reltol`（デフォルト: `reltol = 1.e-4`）、絶対精度 `abstol`（デフォルト: `abstol = 1.e-7`）、およびステップサイズ `dt`（デフォルト: `dt = 0`、`solver = "symplectic"` の場合のみ使用）を指定できます。望ましい相対精度 `reltol` に応じて、`reltol >= 1.e-4` の場合は低次のソルバーが使用され、一般的に非常に効率的ですが、精度は低くなります。`reltol < 1.e-4` の場合は、高精度要求に対応できる高次のソルバーが使用されます。

次のソルバーは [OrdinaryDiffEq.jl](https://github.com/SciML/OrdinaryDiffEq.jl) パッケージから選択できます：

`solver = "non-stiff"` - 非剛性問題用のソルバーを使用します（`Tsit5()` または `Vern9()`）。

`solver = "stiff"` - 剛性問題用のソルバーを使用します（`Rodas4()` または `KenCarp58()`）。

`solver = "auto"` - 剛性問題を自動的に検出するデフォルトソルバーを使用します（`AutoTsit5(Rosenbrock23())` または `AutoVern9(Rodas5())`）。

離散時間問題の行列の並列計算は、複数の実行スレッドでJuliaを起動することによっても実行できます。実行スレッドの数は、`-t/--threads` コマンドライン引数を使用するか、`JULIA_NUM_THREADS` 環境変数を使用して制御されます。

[1] L. Vigano, M. Bergamasco, M. Lovera, and A. Varga. 最適周期出力フィードバック制御：連続時間アプローチとケーススタディ。 Int. J. Control, Vol. 83, pp. 897–914, 2010。

[2] A. Varga. 周期的微分行列方程式の解法と周期システムノルム計算への応用について。 Proc. IEEE CDC/ECC, Seville, 2005。

[3] A. Varga. 周期的リャプノフ方程式：いくつかの応用と新しいアルゴリズム。 Int. J. Control, vol, 67, pp, 69-87, 1997。 ```
