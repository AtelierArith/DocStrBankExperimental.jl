applycolourmap/applycolormap: Applies colourmap to a single channel image to obtain an RGB result

```
Usage: rgbimg = applycolourmap(img, cmap, rnge)

Arguments:  img - Single channel image to apply colourmap to.
                  ::ImageMeta{T,2} or ::Array{Float64,2}
           cmap - RGB colourmap as generated by cmap().
                  ::Array{ColorTypes.RGBA{Float64},1}
           rnge - Optional 2-vector specifying the min and max values in
                  the image to be mapped across the colour map.  Values
                  outside this range are mapped to the end points of the
                  colour map.  If range is omitted the full range
                  of image values are used.

Returns: rgbimg - RGB image of floating point values in the range 0-1.
                  NaN values in the input image are mapped to black.
                  ::ImageMeta{Float64,3} or ::Array{Float64,3}
```

Why use this function when you can simply set a colour map?

Well, actually you probably want to use the functions applycycliccolourmap() and applydivergingcolourmap() which make use of this function.

Many visualisation packages may automatically apply an offset and perform some scaling of your data to normalise it to a range of, say, 0-255 before applying a colour map and rendering it on your screen. In many cases this is useful. However, if you are wanting to render your data with a diverging or cyclic colour map then this behaviour is definitely not appropriate because these types of colour maps requires that data values are honoured in some way to make any sense.

By providing a 'range' parameter this function allows you to apply a colour map in a way that respects your data values.

See also: cmap, applycycliccolourmap, applydivergingcolourmap
