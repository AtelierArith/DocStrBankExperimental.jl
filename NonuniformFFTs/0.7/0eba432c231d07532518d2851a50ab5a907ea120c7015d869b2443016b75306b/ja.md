```
PlanNUFFT([T = ComplexF64], dims::Dims; ntransforms = Val(1), backend = CPU(), kwargs...)
```

非一様FFT（NUFFT）を実行するためのプランを構築します。

作成されたプランには、型 `T`（デフォルトは `ComplexF64`）の非一様データと、次元 `dims` の一様データに対してNUFFTを実行するために必要なすべてのデータが含まれています。

# 拡張ヘルプ

## オプションのキーワード引数

  * `ntransforms = Val(1)`: 同時に実行する変換の数。これは、同じ非一様点で複数のスカラー量を変換したい場合に便利です。
  * `backend::KernelAbstractions.Backend = CPU()`: すべてが実行されるデバイスタイプに対応します。これは、CUDA.jlが読み込まれている場合、例えば `CUDABackend()` になる可能性があります。

### NUFFTパラメータ

次のパラメータは変換の精度を制御します。デフォルト値は、`Float64` または `ComplexF64` データに対して $10^{-7}$ のオーダーの相対精度を提供します。

  * `m = HalfSupport(4)`: 畳み込みカーネルの半支持。大きな値は性能のコストで精度を向上させます。
  * `σ = 2.0`: NUFFTのオーバーサンプリング係数。典型的な値は2.0（より正確）と1.25（より速い）ですが、1.5のような他の値も機能するはずです。
  * `kernel::AbstractKernel = BackwardsKaiserBesselKernel()`: NUFFTに使用される畳み込みカーネル。

### 主な性能パラメータ

  * `kernel_evalmode`: カーネル評価に使用されるメソッド。デフォルトはCPU上での [`FastApproximation`](@ref) で、カーネル評価を大幅に高速化するための高速近似メソッドを使用しようとします。GPUではデフォルトは [`Direct`](@ref) で、高速近似メソッドが必ずしも速いわけではありません。
  * `block_size`: ブロック分割を使用する場合やソートが有効な場合のブロックサイズ（要素数）。これにより、`sort_points = False()` の場合でもポイントの空間ソートが可能になります（これは実際にはポイントデータを並べ替えて、より速いメモリアクセスを可能にします）。ブロックサイズは最大の性能を得るために調整できます。これは `Int`（線形ブロックサイズ）として渡すことも、各直交方向のブロックサイズを指定するタプル `(B₁, …, Bₙ)` として渡すこともできます。現在のデフォルトはCPUで4096、GPUで約1024ですが（次元数によって異なります）、将来的に変更される可能性があります。CPUでは、複数のスレッドで実行するためにはブロック分割を使用する必要があります。GPUでは、`gpu_method = :shared_memory` の場合、このオプションは無視されます。ブロッキング/空間ソートは、`block_size = nothing` を渡すことで完全に無効にできます（ただし、これは一般的に遅くなります）。
  * `gpu_method`: GPU変換の異なる実装の間で選択を可能にします。可能なオプションは：

      * `:global_memory`（デフォルト）: グローバルメモリ内の配列に直接読み書きし、スプレッド（タイプ1）および補間（タイプ2）操作を行います。
      * `:shared_memory`: グローバルメモリと共有メモリ（各GPUワークグループにローカル）間でデータをコピーし、ほとんどの操作を後者で実行します。これはより速く、タイプ1変換での一部のアトミック操作を回避するのに役立ちます。現在のGPUで通常利用可能な共有メモリをできるだけ使用しようとします（通常、CUDAでは48 KiB、AMDGPUでは64 KiBです）。このメソッドは `block_size` パラメータを完全に無視します。なぜなら、実際のブロックサイズは共有メモリの使用を最大化するように調整されるからです。このメソッドが有効な場合、`gpu_batch_size` パラメータ（以下を参照）を調整して性能をさらに調整できます。

    非常に密な問題（非一様点の数が全体のグリッドサイズに匹敵する場合）では、`:shared_memory` メソッドがはるかに速くなることがあります。特に `HalfSupport` が4以下の場合（`σ = 2` の場合、精度は `1e-7` まで）。
  * `fftw_flags = FFTW.MEASURE`: `backend = CPU()` の場合にFFTWプランナーに渡されるパラメータ。

### その他の性能パラメータ

これらはより高度な性能パラメータで、将来的に消えるか、動作が変更される可能性があります。

  * `sort_points = False()`: 非一様点の順序を内部的に並べ替えるかどうか。これは `sort_points = True()` を渡すことで有効にできます。これにより、入力ポイントを新しいコンテナにコピーする必要があるため、一般的に追加の割り当てが必要になります。これが有効な場合、[`set_points!`](@ref) に費やされる時間が増え、実際の変換に費やされる時間が減ります。これは、同じ非一様点で複数の変換を実行する場合に性能を向上させることができます。なお、有効にしても、これは `set_points!` に渡された `points` 引数を変更しません。このオプションは、`block_size = nothing` の場合（空間ソートを無効にします）には無視されます。
  * `gpu_batch_size = Val(Np)`: `gpu_method = :shared_memory` の場合にタイプ1変換で使用される最小バッチサイズ。アイデアは、共有メモリ配列での非効率的なアトミック操作を避けるために、非一様点を `Np` ポイントのバッチで処理することです。実際の `Np` の値は、各GPUワークグループ内で共有メモリの使用を最大化するために、通常は入力の値よりも大きくなります。大きな `Np` は、ローカルブロックのために利用可能な共有メモリのスペースが少なくなることを意味し、効果的なブロックサイズが小さくなる可能性があります（これは必ずしも性能に悪いわけではなく、実際には有益であることもあります）。性能を調整する際には、プランを印刷（`println(plan)` のように）して、実際のブロックサイズとバッチサイズを確認することが役立ちます。

### その他のパラメータ

  * `fftshift = false`: 一様空間における波数の順序を決定します。`false`（デフォルト）の場合、FFTWが使用するのと同じ順序が使用され、正の波数が最初に来ます（偶数サイズの変換の場合、`[0, 1, 2, …, N÷2-1]`）および負の波数がその後に来ます（`[-N÷2, …, -1]`）。そうでない場合、波数は増加順にあることが期待されます（`[-N÷2, -kmax, …, -1, 0, 1, …, N÷2-1]`）、これはNFFT.jlの出力と互換性があり、データに `AbstractFFTs.fftshift` 関数を適用することに対応します。このオプションは、FINUFFTの `modeord` パラメータにも対応します。これは複素数から複素数への変換にのみ影響します。
  * `timer = TimerOutput()`: タイミング情報が書き込まれる `TimerOutput`（[TimerOutputs.jl](https://github.com/KristofferC/TimerOutputs.jl) パッケージから）を指定できます。デフォルトでは、プランは独自のタイマーを作成します。`p.timer` を使用してNUFFT計算のさまざまな部分に費やされた時間を視覚化できます。
  * `synchronise = false`: `true` の場合、GPUカーネルの呼び出し間に同期バリアを追加します。これを有効にすることで、GPU上で計算する際に `p.timer` での正確なタイミングが必要ですが、性能が低下する可能性があります。

## FFTサイズと性能

性能上の理由から、FFTを行う際には、通常、各次元に沿った入力のサイズが2の累乗（理想的には）であるか、小さな素数の累乗の積（2, 3, 5, …）であることを望みます。問題は、NUFFTではオーバーサンプリング係数 $σ$ によってFFTサイズを直接制御できないことです。$σ$ は任意の実数 $σ > 1$ であり得ます。つまり、サイズ $N$ の入力に対して、FFTはサイズ $Ñ ≈ σN$ のオーバーサンプリンググリッドで実行されます。$σN$ は一般に整数ではないため、$≈$ となります。

このセクションの目的は、$Ñ$ が実際にどのように選択されるかを明確にし、与えられた入力 $N$ と $σ$ に対してその値を予測できるようにすることです。これは実際のコードでよりよく理解できます：

```julia
Ñ = nextprod((2, 3, 5), floor(Int, σ * N))
```

基本的に、$σN$ を整数に切り捨て、その後、2, 3, 5 の累乗の積として書ける次の整数を $Ñ$ として選択します（[`nextprod`](https://docs.julialang.org/en/v1/base/math/#Base.nextprod)を参照）。ほとんどの場合、結果は $σN$ 以上になります。

## 実数の非一様データの使用

いくつかのアプリケーションでは、変換される非一様データが純粋に実数です。この場合、最初の引数として `Float64` または `Float32` を渡すことができます。これは、特にFFTWからの実数から複素数へのFFTが変換を計算するために使用されるため、データを複素数型に変換するよりも速い場合があります。この場合、一様データ配列の次元は正確には `dims` ではなく、最初の次元のサイズが約2で割られるため（エルミート対称性を利用）、便利のために、構築されたプランに対して [`size(::PlanNUFFT)`](@ref) を呼び出して、一様データ配列の次元を事前に知ることができます。 ```
