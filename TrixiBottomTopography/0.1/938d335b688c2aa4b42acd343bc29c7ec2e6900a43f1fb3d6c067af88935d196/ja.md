```
BicubicBSpline(x::Vector, y::Vector, z::Matrix; end_condition = "free", smoothing_factor = 0.0)
```

この関数は、構造体 [`BicubicBSpline`](@ref) の入力を計算します。入力値は次のとおりです。

  * `x`: x方向に等間隔の値を含むベクトル
  * `y`: y方向に等間隔の値を含むベクトルで、y値間の間隔はx値間の間隔と同じでなければなりません
  * `z`: z方向の対応する値を含む行列。値は次のように順序付けられています：

$$
\begin{aligned}
    \begin{matrix}
        & & x_1 & x_2 & ... & x_n\\
        & & & & &\\
        y_1 & & z_{11} & z_{12} & ... & z_{1n}\\
        y_1 & & z_{21} & z_{22} & ... & z_{2n}\\
        \vdots & & \vdots & \vdots & \ddots & \vdots\\
        y_m & & z_{m1} & z_{m2} & ... & z_{mn}
    \end{matrix}
\end{aligned}
$$

  * `end_condition`: "free" または "not-a-knot" のいずれかの文字列で、考慮すべき端条件を定義します。デフォルトでは "free" に設定されています。
  * `smoothing_factor`: Float64 $\geq$ 0.0 で、`z` 値の平滑化の度合いを指定します。デフォルトではこの値は 0.0 に設定されており、平滑化は行われません。

バイキュービックBスプライン補間は、ベクトル `x` と `y` の次元が行列 `z` の次元と一致する場合にのみ可能です。

最初に、データは [`sort_data`](@ref) を介してソートされ、`x` および `y` 値が対応する行列 `z` とともに昇順であることが保証されます。

パッチサイズ `Delta` は、最初の `x` 値から2番目の `x` 値を引くことによって計算されます。これは、連続する `x` および `y` 値の間に等間隔しか考慮しないため可能です。パッチは、2つの連続する `x` および `y` 値の間の領域です。

`smoothing_factor` が $>$ 0.0 に設定されている場合、関数 [`calc_tps`](@ref) は、曲率が少ない結果のパラメトリックBスプライン曲面を保証するために `z` の新しい値を計算します。

バイキュービックBスプラインの係数行列 `IP` は次のように固定されています。

$$
\begin{aligned}
    \begin{pmatrix}
        -1 & 3 & -3 & 1\\
        3 & -6 & 3 & 0\\
        -3 & 0 & 3 & 0\\
        1 & 4 & 1 & 0
    \end{pmatrix}
\end{aligned}
$$

補間関数を設定するために必要な制御点の行列 `Q` を取得するには、制御点をベクトル `P` にマッピングする行列 `Phi` を定義する必要があります。これは、次の線形方程式の系を `Q` に対して解くことによって行うことができます。

$$
\underbrace{
    \begin{bmatrix}
        z_{1,1} \\ z_{1,2} \\ \vdots \\ z_{1,n} \\ z_{2,1} \\ \vdots \\ z_{m,n} \\ 0 \\ \vdots \\ 0
    \end{bmatrix}
    }_{\text{:=P} \in \mathbb{R}^{(m+2)(n+2)\times 1}} = \frac{1}{36}
    \Phi \cdot
    \underbrace{\begin{bmatrix}
        Q_{1,1} \\ Q_{1,2} \\ \vdots \\ Q_{1,n+2} \\ Q_{2,1} \\ \vdots \\ Q_{m+2,n+2}
    \end{bmatrix}}_{\text{:= Q} \in \mathbb{R}^{(m+2) \times (n+2)}}
$$

最初の `n` $\cdot$ `m` 行について、行列 `Phi` は "free" エンド条件と "not-a-knot" エンド条件で同じです。これらの行は次の条件に対処する必要があります：

$$
\begin{align*}
    z_{j,i} = \frac{1}{36} \Big( &Q_{j,i} + 4Q_{j+1,i} + Q_{j+2,i} + 4Q_{j,i+1} + 16Q_{j+1,i+1}\\
    &+ 4Q_{j+2,i+1} + Q_{j,i+2} + 4Q_{j+1,i+2} + Q_{j+2,i+2} \Big)
\end{align*}
$$

i = 1,...,n および j = 1,...,m の場合。

"free" エンド条件には、`x` および `y` ベクトルに対して少なくとも2つの値が必要です。"free" エンド条件には、`Phi` によって対処される必要がある制御点に対する追加の要件があります：

  * $$
    Q_{j,1} - 2Q_{j,2} + Q_{j,3} = 0
    $$

    for j = 2,...,m+1
  * $$
    Q_{j,n} - 2Q_{j,n+1} + Q_{j,n+2} = 0
    $$

    for j = 2,...,m+1
  * $$
    Q_{1,i} - 2Q_{2,i} + Q_{3,i} = 0
    $$

    for i = 2,...,n+1
  * $$
    Q_{m,i} - 2Q_{m+1,i} + Q_{m+2,i} = 0
    $$

    for i = 2,...,n+1
  * $$
    Q_{1,1} - 2Q_{2,2} + Q_{3,3} = 0
    $$
  * $$
    Q_{m+2,1} - 2Q_{m+1,2} + Q_{m,3} = 0
    $$
  * $$
    Q_{1,n+2} - 2Q_{2,n+1} + Q_{3,n} = 0
    $$
  * $$
    Q_{m,n} - 2Q_{m+1,n+1} + Q_{m+2,n+2} = 0
    $$

"not-a-knot" エンド条件には、`x` および `y` ベクトルに対して少なくとも4つの値が必要です。

  * 最も左のパッチと2番目に左のパッチの間の3番目の `x` 微分の連続性
  * 最も右のパッチと2番目に右のパッチの間の3番目の `x` 微分の連続性
  * 上のパッチと下のパッチの間の3番目の `y` 微分の連続性
  * 下のパッチと上のパッチの間の3番目の `y` 微分の連続性
  * $$
    Q_{1,1} - Q_{1,2} - Q_{2,1} + Q_{2,2} = 0
    $$
  * $$
    Q_{m-1,1} + Q_{m,1} + Q_{m-1,2} - Q_{m,2} = 0
    $$
  * $$
    Q_{1,n-1} + Q_{2,n} + Q_{1,n-1} - Q_{2,n} = 0
    $$
  * $$
    Q_{m-1,n-1} - Q_{m,n-1} - Q_{m-1,n} + Q_{m,n} = 0
    $$

このスクリプトの計算に関する参考文献は、次の書籍の第2章にあります。

  * Quentin Agrapart & Alain Batailly (2020), Cubic and bicubic spline interpolation in Python. [hal-03017566v2](https://hal.archives-ouvertes.fr/hal-03017566v2)

```
