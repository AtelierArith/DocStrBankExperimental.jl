```
Thunk(()->v)
```

サンクは遅延計算です。これは、呼び出されると接線を返すゼロ引数クロージャをラップします。 `@thunk(v)` は、 `Thunk(()->v)` に展開されるマクロです。

ラップされたクロージャを評価するには、引数が `Thunk` でない場合は何もしない [`unthunk`](@ref) を呼び出します。

```jldoctest
julia> t = @thunk(3)
Thunk(var"#4#5"())

julia> unthunk(t)
3
```

### いつ `@thunk` を使うべきか？

`rrule`（およびそれほどでもないが `frule`）を書くときは、適切に `@thunk` を使用することが重要です。複数の導関数を返す伝播ルールでは、すべての導関数が使用されるわけではありません。各導関数に必要な作業を `@thunk` することで、必要なものだけを計算します。

#### サンクはどのように作業を防ぐのか？

もし `res = pullback(...) = @thunk(f(x)), @thunk(g(x))` であれば、 `dx + res[1]` を行った場合、 `f(x)` のみが評価され、 `g(x)` は評価されません。また、 `ZeroTangent() * res[1]` を行った場合、結果は `ZeroTangent()` となり、 `f(x)` は評価されません。

#### では、なぜすべてをサンクにしないのか？

`@thunk` は式に対してクロージャを作成し、（実質的に）式で使用される各変数のフィールドを持つ `struct` を作成し、オーバーロードされた呼び出しを行います。

式自体を実際に評価するのと同じかそれ以上の作業になる場合は、 `@thunk` を使用しないでください。これはスカラー演算子に一般的に当てはまります。

詳細については、マニュアルのセクション [サンクを効果的に使用する](https://juliadiff.org/ChainRulesCore.jl/dev/rule_author/writing_good_rules.html#Use-Thunks-appropriately) を参照してください。
