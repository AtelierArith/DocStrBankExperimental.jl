```
@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)
```

提供された偏導関数を使用して、単純なスカラー前方または逆方向のルールを生成する便利なマクロ。具体的には、`frule` と `rrule` の対応するメソッドを生成します：

```julia
function ChainRulesCore.frule((NoTangent(), Δx₁, Δx₂, ...), ::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (
            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
            ...
        )
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, ((ΔΩ₁, ΔΩ₂, ...)) -> (
            NoTangent(),
            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
            ...
        )
end
```

`@scalar_rule` の呼び出し内で `f(x₁, x₂, ...)` に型制約が提供されていない場合、結果の `frule`/`rrule` 定義の各パラメータには `Number` の型制約が与えられます。制約は、`f(x₁::Complex, x₂)` のように明示的に提供して `Number` 制約を上書きすることもできます。この場合、`x₁` は `Complex` に、`x₂` は `Number` に制約されます。

現在のところ、クロージャやファンクタの定義はサポートされていません。したがって、逆モードでは、関数自体に関する導関数を表す最初に返される偏導関数は常に `NoTangent()` です。そして前方モードでは、返される伝播器への最初の入力は常に無視されます。

`f(x₁, x₂, ...)` の結果は自動的に `Ω` にバインドされます。これにより、導関数/セットアップ式内でプライマル結果を便利に参照することができます（`Ω` として）。

このマクロは、複雑な関数が正則であると仮定しています。一般に、非正則関数の場合、`frule` と `rrule` は手動で定義する必要があります。

導関数が1の場合（例えば、恒等関数の場合）、`true` を最も一般的な乗法単位として使用できます。

`@setup` 引数は、セットアップコードが必要ない場合は省略できます。言い換えれば：

```julia
@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)
```

は次のように等価です：

```julia
@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)
```

例については、ChainRules の `rulesets` ディレクトリを参照してください。

参照： [`frule`](@ref), [`rrule`](@ref).
