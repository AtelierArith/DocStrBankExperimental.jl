```
qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})
```

**二次カルマンフィルタ（QKF）**を長さ`T̄`の時系列に対して実行します。

# 説明

この関数は、状態ベクトル`Z_t`が通常の平均成分`xₜ`だけでなく、二次モーメントの項`(x xᵀ)ₜ`も含むカルマンのような再帰フィルタを実装しています。各時間ステップで、次の処理を行います：

1. **状態予測**（`predict_Z_ttm1` / `predict_P_ttm1`）
2. **測定予測**（`predict_Y_ttm1` / `predict_M_ttm1`）
3. **カルマンゲイン計算**（`compute_K_t`）
4. **状態と共分散の更新**（`update_Zₜₜ!`, `update_Pₜₜ!`）
5. **PSD補正**：負の固有値を`correct_Zₜₜ!`を通じてクリンピングすることで、暗示された共分散が半正定値であることを保証します。
6. **対数尤度**の計算を現在のイノベーションに対して行います。

フィルタは、フィルタリングされた状態、共分散、予測された測定、および関連する配列の全履歴を保存し、返します。

# 引数

  * `data::QKData{T1,1}`   次の情報を保持する構造体：

      * 長さ`T_bar+1`の`Y::Vector{T1}`、観測値を含みます（`Y[1]`は未使用または初期のプレースホルダで、`Y[2..end]`が実際の測定値です）。
      * `T_bar::Int` 時間ステップの総数（インデックス0を除く）。
      * `M::Int` 各時間ステップでの測定の次元。
  * `model::QKModel{T,T2}`   次の情報を保持するパラメータ構造体：

      * `N::Int`: 状態次元（平均部分用）。
      * `P::Int`: 拡張された「二次」状態ベクトルの次元（`P = N + N(N+1)/2`）。
      * `aug_mean, aug_cov`: 初期化に使用される無条件の平均と共分散。
      * 追加のモデル行列または関数（例：`Phi_aug`, `B_aug`, `A`, `V`）、通常は別の予測/更新サブルーチンを介してアクセスされます。

# 戻り値

フィールドを持つ名前付きタプル：

  * `ll_t::Vector{Float64}`   イノベーションの各時間ステップの対数尤度（サイズ = `T_bar`）。
  * `Z_tt::Matrix{T}`   各時間ステップでの更新された（「フィルタリングされた」）状態。次元：`(P, T_bar+1)`、列`k`は時間インデックス`k-1`に対応します。
  * `P_tt::Array{T,3}`   各時間ステップでの更新された（「フィルタリングされた」）状態共分散配列（または拡張された二次モーメント表現）。次元：`(P, P, T_bar+1)`。
  * `Y_ttm1::Vector{T}`   各時間ステップでの予測された測定（サイズ = `T_bar`）。
  * `M_ttm1::Array{T,3}`   各時間ステップでの予測された測定共分散（次元：`(M, M, T_bar)`）。
  * `K_t::Array{T,3}`   各時間ステップでのカルマンゲイン（次元：`(P, M, T_bar)`）。
  * `Z_ttm1::Matrix{T}`   一歩先の予測された状態（次元：`(P, T_bar)`）。
  * `P_ttm1::Array{T,4}`   一歩先の予測された共分散（次元：`(P, P, T_bar)`）。
  * `Σ_ttm1::Array{T,4}`   予測中に追加された任意の中間状態依存共分散項（次元：`(P, P, T_bar)`）。

# 詳細

1. **初期化**：  

      * `Z_tt[:,1] .= aug_mean` および `P_tt[:,:,1] .= aug_cov`、時間0での状態を表します。
2. **時間ループ**（`for t in 1:T_bar`）：  

      * **予測**ステップ： 

          * `predict_Z_ttm1`が`Z_ttm1[:,t]`を`Z_tt[:,t]`から設定します。
          * `predict_P_ttm1`が`P_ttm1[:,:,t]`を`P_tt[:,:,t]`から設定します。
      * **測定**ステップ： 

          * `predict_Y_ttm1`が`Y_ttm1[t]`を`Z_ttm1[:,t]`から計算します。
          * `predict_M_ttm1`が`M_ttm1[:,:,t]`を更新します。
      * **ゲインと更新**：

          * `compute_K_t`がカルマンゲイン`K_t[:,:,t]`を取得します。
          * `update_Z_tt`と`update_P_tt`が次の`Z_tt[:,t+1]`と`P_tt[:,:,t+1]`を生成します。
      * **補正**：  

          * `correct_Z_tt`が`Z_tt`の暗示された共分散部分の負の固有値をクリンピングしてPSDを確保します。
      * **尤度**：

          * `compute_loglik`がイノベーションに基づく対数尤度を`ll_t[t]`に追加/記録します。
3. **半正定値補正**：

      * フィルタが`[X Xᵀ] - X Xᵀᵀ`を共分散ブロックとして追跡するため、線形化や数値的問題により不定になる可能性があります。`correct_Z_tt`で負の固有値をゼロにすることでPSDを強制します。
      * このステップは、固有値がゼロを越えるときに厳密には微分可能ではありません。フィルタを通じてADが必要な場合は、代替の補正またはカスタムアジョイントを検討してください。

# 例

```julia
data = QKData(Y, M=measurement*dim, T*bar=length(Y)-1)
model = QKModel( ... )   # モデルを設定します

result = qkf_filter!(data, model)

@show result.ll*t
@show result.Z*tt[:, end]   # 最終状態ベクトル
```
