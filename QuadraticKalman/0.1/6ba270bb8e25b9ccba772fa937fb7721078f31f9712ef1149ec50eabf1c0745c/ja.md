```
qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})
```

**二次カルマンフィルタ（QKF）**を長さ `T̄` の時系列に対して実行し、結果をインプレースで修正します。

# 説明

この関数は、状態ベクトル `Zₜ` が通常の平均成分 `xₜ` だけでなく、二次モーメント `(x xᵀ)ₜ` の項も含むカルマンのような再帰フィルタを実装しており、*二次*拡張となっています。各時間ステップで、次の処理を行います：

1. **状態予測** (`predict_Z_ttm1!` / `predict_P_ttm1!`)
2. **測定予測** (`predict_Y_ttm1!` / `predict_M_ttm1!`)
3. **カルマンゲイン計算** (`compute_K_t!`)
4. **状態と共分散の更新** (`update_Z_tt!`, `update_P_tt!`)
5. **PSD補正** (`correct_Z_tt!`)
6. 現在のイノベーションに対する**対数尤度**の計算。

非ミューテーション版（`qkf_filter`）とは異なり、この関数は内部配列とデータ構造をインプレースで再利用し、変更するため、パフォーマンスが向上し、メモリ割り当てが削減される可能性があります。

# 引数

  * `data::QKData{T1,1}`   次の情報を保持する構造体：

      * `Y::Vector{T1}` の長さ `T̄+1`、観測値を含む。通常、`Y[1]` は初期プレースホルダーで、`Y[2..end]` は実際の測定値です。
      * `T_bar::Int` 時間ステップの総数（インデックス0を除く）。
      * `M::Int` 各時間ステップでの測定の次元。
  * `model::QKModel{T,T2}`   次の情報を保持するパラメータ構造体：

      * `N::Int`: 状態次元（平均部分用）。
      * `P::Int`: 拡張された「二次」状態の次元（`P = N + N(N+1)/2`）。
      * `μ_aug, Σ_aug`: 初期化に使用される無条件の平均と共分散。
      * サブルーチンを介してアクセスされる追加のモデル行列または関数（例：`Φ_aug`, `B_aug`, `A`, `V`）。

# 戻り値

フィールドを持つ名前付きタプル：

  * `ll_t::Vector{Float64}`   各時間ステップの対数尤度（サイズ = `T̄`）。
  * `Z_tt::Array{T,3}`   各時間ステップでのフィルタリングされた状態。次元：あなたの特定のコードでは `(T, P, T̄+1)`（またはより一般的なバージョンでは `(P, T̄+1)`）。
  * `Pₜₜ::Array{T,4}`   フィルタリングされた状態共分散配列。次元は通常あなたのコードでは `(T, P, P, T̄+1)`。
  * `Yₜₜ₋₁::Vector{T}`   各時間ステップでの予測測定（サイズ = `T̄`）。
  * `M_ttm1::Array{T,4}`   予測測定共分散、次元 `(T, M, M, T̄)`。
  * `K_t::Array{T,4}`   各時間ステップのカルマンゲイン、次元 `(T, P, M, T̄)`。
  * `Zₜₜ₋₁::Array{T,3}`   一歩先の予測状態。
  * `Pₜₜ₋₁::Array{T,4}`   一歩先の予測共分散。
  * `Σ_ttm1::Array{T,4}`   予測に使用される任意の中間共分散項。

# 詳細

1. **初期化**：

      * `Z_tt[:, 1] .= μ̃ᵘ` および `P_tt[:,:,1] .= Σ̃ᵘ`。
2. **再帰ステップ** (`for t in 1:T̄`):

      * **予測**： `predict_Z_ttm1!` / `predict_P_ttm1!`。
      * **測定**： `predict_Y_ttm1!` / `predict_M_ttm1!`。
      * **ゲインと更新**： `compute_K_t!`、次に `update_Z_tt!` / `update_P_tt!`。
      * **補正**： `correct_Z_tt!` はPSDのために負の固有値を制限します。
      * **尤度**： `compute_loglik!` は対数尤度を追加します。
3. **正定値補正**：

      * 近似によって導入された負の固有値はゼロに設定されます。

# 例

```julia
data = QKData(Y, M=measurement_dim, T̄=length(Y)-1)
model = QKModel(...)
result = qkf_filter!(data, model)

@show result.ll_t
@show result.Z_tt[:, end]   # 最終状態
```
