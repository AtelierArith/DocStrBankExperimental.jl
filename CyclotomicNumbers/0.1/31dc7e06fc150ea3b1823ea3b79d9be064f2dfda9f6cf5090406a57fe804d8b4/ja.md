このパッケージは、ユニティの根の線形結合である複素数、通常は有理数または整数の係数を持つサイクロトミック数を扱いますが、任意の係数 `<:Real` を使用することも可能です。サイクロトミック数は `Complex` 数に変換できます。

有理数係数を持つサイクロトミック数は、サイクロトミック体を形成します。これは、アーベルガロア群を持つ有理数の最大拡張です。その整数環は、整数係数を持つサイクロトミック数（サイクロトミック整数と呼ばれる）です。

サイクロトミック数は有限群にとって非常に重要です。なぜなら、有限群のキャラクタ値はサイクロトミック整数だからです。

このパッケージは、`ModuleElt` と `Primes` のパッケージのみに依存しています。これは、GAPのサイクロトミックの実装を移植したもので、Zumbroich基底で書くことによって与えられる標準形を使用しています。この形は、与えられた数を含む最小のサイクロトミック体を見つけることを可能にし、特にサイクロトミックがゼロであるかどうかを判断します。`ζₙ=exp(2im*π/n)` とします。Zumbroich基底は、1, ζₙ, ζₙ²,…, ζₙⁿ⁻¹ のサイズ φ(n) の特定の部分集合であり、ℚ (ζₙ) の基底を形成します。参考文献は以下の通りです。

T. Breuer, Integral bases for subfields of cyclotomic fields AAECC 8 (1997)

私はこのファイルを、GAPのCコードよりも理解しやすいChristian StumpのSageコードを移植することから始めました。

GAPが行うように、私は各計算の後に自動的に数を下げ、つまり、それらを属する最小のサイクロトミック体に減少させます。現在のところ、コードはGAPのCコードよりもやや遅い（操作によっては同じ速度か最大50%遅い）ですが、最適化の機会があるかもしれません。

GAPが自動的に行うことは、サイクロトミックを有理数に、整数を整数に、ビッグインテジャーを小さい整数に変換することですが、これは非常に重要な最適化です。しかし、Juliaの型の安定性のために、新しいタイプの数をJuliaに追加する必要があり、私はそれを試す能力が十分ではありません。

このパッケージは、Marek Kalubaのパッケージ `Cyclotomics` と似ており（ほとんど互換性があります）、その存在はこのパッケージを書いた後に発見しました。私たちはそれらを統合することについて議論しましたが、現在のところ明確な利益がないため、多くの作業が必要であると結論しました。いくつかの違いは次のとおりです。

  * このパッケージでは2つのタイプを定義しています：`Root1` はユニティの根を表し、`Cyc` はサイクロトミック数を表します。ユニティの根のために別のタイプを持つ利点は、計算が非常に高速であることであり、私はその利点を持つ `CycPol` パッケージで利用しています。
  * Kalubaのパッケージでは、数は体系的に下げられるのではなく、要求に応じてのみ下げられます（印刷のように）。これにより、一部の計算が約2倍速くなりますが、次のような計算が実行不可能になることもあります。これは、下げない場合にはあまりにも大きな体を含むためです。答えは `-36ζ₃²` です：

```julia-rep1
julia> prod(x->1-x,[E(3),E(3,2),E(6),E(6,5),E(8),E(8),E(8,5),E(8,7),E(9,2),
E(9,5),E(9,8),E(12,7),E(12,11),E(16),E(16,3),E(16,5),E(16,9),E(16,11),E(16,13),
E(18,5),E(18,5),E(18,11),E(18,11),E(18,17),E(18,17),E(21,2),E(21,5),E(21,8),
E(21,11),E(21,17),E(21,20),
E(27,2),E(27,5),E(27,8),E(27,11),E(27,14),E(27,17),E(27,20),E(27,23),E(27,26),
E(32,7),E(32,15),E(32,23),E(32,31),E(39),E(39,4),E(39,7),E(39,10),E(39,16),
E(39,19),E(39,22),E(39,25),E(39,28),E(39,31),E(39,34),E(39,37),E(42),E(42,13),
E(42,19),E(42,25),E(42,31),E(42,37),E(48,11),E(48,19),E(48,35),E(48,43),E(60,7),
E(60,19),E(60,31),E(60,43),E(78,5),E(78,11),E(78,17),E(78,23),E(78,29),E(78,35),
E(78,41),E(78,47),E(78,53),E(78,59),E(78,71),E(78,77),E(80,7),E(80,23),E(80,31),
E(80,39),E(80,47),E(80,63),E(80,71),E(80,79),E(88,3),E(88,19),E(88,27),E(88,35),
E(88,43),E(88,51),E(88,59),E(88,67),E(88,75),E(88,83),E(90),E(90,7),E(90,13),
E(90,19),E(90,31),E(90,37),E(90,43),E(90,49),E(90,61),E(90,67),E(90,73),
E(90,79),E(96,5),E(96,13),E(96,29),E(96,37),E(96,53),E(96,61),E(96,77),E(96,85),
E(104),E(104,9),E(104,17),E(104,25),E(104,33),E(104,41),E(104,49),E(104,57),
E(104,73),E(104,81),E(104,89),E(104,97),E(144),E(144,17),E(144,25),E(144,41),
E(144,49),E(144,65),E(144,73),E(144,89),E(144,97),E(144,113),E(144,121),
E(144,137),E(152,5),E(152,13),E(152,21),E(152,29),E(152,37),E(152,45),
E(152,53),E(152,61),E(152,69),E(152,77),E(152,85),E(152,93),E(152,101),
E(152,109),E(152,117),E(152,125),E(152,141),E(152,149),E(204,11),E(204,23),
E(204,35),E(204,47),E(204,59),E(204,71),E(204,83),E(204,95),E(204,107),
E(204,131),E(204,143),E(204,155),E(204,167),E(204,179),E(204,191),E(204,203)])
```

私のパッケージを `develop` すると、要求に応じてのみ下げる戦略を使用したり、密なベクトルや疎なベクトル（`Cyclotomics` のように）などの代替実装を使用することが簡単です。私は、コード内でさまざまな実装を選択するためのブールフラグを準備しました。現在、私は `ModuleElts` と体系的な下げを持つ実装を選択しており、最良の結果を得ています。

サイクロトミック数を構築する主な方法は、`E(n,k=1)` 関数を使用することで、これは `Root1` を `ζₙᵏ` に等しく構築し、そのような数の線形結合を作成します。

# 例

```julia-repl
julia> E(3,2) # ユニティの根
Root1: ζ₃²

julia> E(3)+E(4) # replでの美しい表示
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹
```

```julia-rep1
julia> print(E(3)+E(4)) # さもなければ、解析可能な出力を提供
E(12,4)-E(12,7)-E(12,11)
```

```julia-repl
julia> E(12,11)-E(12,7) # 整数の平方根が出力で認識される
Cyc{Int64}: √3

julia> repr(E(12,11)-E(12,7),context=(:limit=>true,:quadratic=>false)) # しかし、その認識を防ぐことができる
"-ζ₁₂⁷+ζ₁₂¹¹"

julia> a=E(3)+E(3,2)
Cyc{Int64}: -1

julia> conductor(a) # aはℚ (ζ₁)=ℚに下げられた
1

julia> typeof(Int(a))
Int64
```

```julia-rep1
julia> Int(E(4))
ERROR: InexactError: convert(Int64, E(4))
```

```julia-repl
julia> inv(1+E(4)) # 整数のように逆数は浮動小数点を含む
Cyc{Float64}: 0.5-0.5ζ₄

julia> 1//(1+E(4))  # しかし、このようには書かれない
Cyc{Rational{Int64}}: (1-ζ₄)/2

julia> Cyc(1//2+im) # ガウス有理数をサイクロトミックに変換できる
Cyc{Rational{Int64}}: (1+2ζ₄)/2

julia> conj(1+E(4)) # 複素共役
Cyc{Int64}: 1-ζ₄

julia> real(E(3))  # 実部
Cyc{Rational{Int64}}: -1//2

julia> Rational{Int}(real(E(3)))
-1//2

julia> imag(E(3))  # 虚部
Cyc{Rational{Int64}}: √3/2

julia> c=Cyc(E(9))   # Zumbroich基底の標準形には2つの項がある
Cyc{Int64}: -ζ₉⁴-ζ₉⁷

julia> Root1(c) # しかし、可能であればRoot1に戻すことができる
Root1: ζ₉

julia> Root1(1+E(4)) # コンストラクタRoot1は非根の場合には何も返さない
```

ユニティの根の群は ℚ /ℤ に同型であり、したがって `Root1` は内部的に `[0,1[` の有理数で表されます。

```julia-repl
julia> Root1(;r=1//4) # このコンストラクタは分数が [0,1[ にあることを保証します
Root1: ζ₄

julia> c=E(4)*E(3) # ユニティの根の内部に留まる場合は高速計算
Root1: ζ₁₂⁷
```

`Root1` は `Cyc` と同じ操作を持っていますが、`one, isone, *, ^, inv, conj, /, //` 以外のすべての操作のために最初に `Cyc` に変換されます。`Root1` は `Rational` の冪に上げることができ、必要に応じて根を抽出します。`Root1` は `order` と `exponent` を使用して分解することができます。もし `a` と `b` が互いに素であれば、`a` は `E(a,b)` の順序であり、`b`（`a` で取った剰余）は指数です。注意すべきは、`E(6)==-E(3)` は順序6であり、導体3であるため、順序は導体ではないということです。

```julia-repl
julia> c=Complex{Float64}(E(3))  # Complex{float} に変換することは時々便利です
-0.4999999999999999 + 0.8660254037844387im
```

`Cyc` が存在する場合、数 `<:Real` または `<:Complex{<:Real}` は `Cyc` に変換されます。

```julia-repl
julia> 0.0+E(3)
Cyc{Float64}: 1.0ζ₃

julia> E(3)+1//2
Cyc{Rational{Int64}}: √-3/2

julia> E(3)+im
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹
```

関数 `complex` は、導体が1または4の場合に `Cyc{T}` を `Complex{T}` に変換し、それ以外の場合は `Complex{float(T)}` に変換します。

```julia-repl
julia> complex(E(4))
0 + 1im

julia> complex(E(3))
-0.4999999999999999 + 0.8660254037844387im
```

`Cyc` には `copy, hash, ==, cmp, isless`（全順序）メソッドがあり、ハッシュのキー、集合の要素として使用でき、ソートも可能です。サイクロトミック数が整数または有理数である場合、`Real` と正しく比較されます（これは無理数の実数 `Cyc` には拡張されません）：

```julia-repl
julia> -1<Cyc(0)<1
true
```

`Cyc` には `+, -, *, /, //, inv, ^, conj, abs2, abs, image, real, reim, isinteger, isreal, one, isone, zero, iszero, complex, adjoint` の操作があります。有理数または整数係数を持つサイクロトミック数には、`numerator` と `denominator` メソッドがあります：`Cyc` `x` はサイクロトミック整数である場合、`denominator(x)==1` となり、その後 `numerator(x)` は対応する `Cyc{<:Integer}` を返します。

サイクロトミック数をさまざまな方法で分解できます。最も速いのは、イテレータ `pairs` を使用することで、導体 `e` のサイクロトミック数 `a` に対して、`a` が `ζₑⁱ` の非ゼロ係数 `c` を持つペア `(i,c)` を反復します。また、`a[i]` として `ζₑⁱ` の係数を取得することもできますが、この方法で係数を反復するのは遅くなります。最後に、`coefficients` を使用してすべての係数のベクトルを効率的に取得できます。

```julia-repl
julia> a=E(3)+E(4)
Cyc{Int64}: ζ₁₂⁴-ζ₁₂⁷-ζ₁₂¹¹

julia> collect(pairs(a))
3-element Vector{Pair{Int64, Int64}}:
  4 => 1
  7 => -1
 11 => -1

julia> a[6],a[7]
(0, -1)

julia> coefficients(a)
12-element Vector{Int64}:
  0
  0
  0
  0
  1
  0
  0
 -1
  0
  0
  0
 -1

julia> valtype(a) # aの係数の型
Int64
```

詳細については、Quadratic、galois、root、conjugates メソッドのドキュメントを参照してください。

最後に、ベンチマーク：

```benchmark
julia> function testmat(p)
         ss=[[i,j] for i in 0:p-1 for j in i+1:p-1]
         [(E(p,i'*reverse(j))-E(p,i'*j))//p for i in ss,j in ss]
       end
testmat (generic function with 1 method)

julia> @btime CyclotomicNumbers.testmat(12)^2;  # Julia 1.8.5で
  182.929 ms (2032503 allocations: 198.22 MiB)
```

GAPでの同等のもの：

```
testmat:=function(p)local ss;ss:=Combinations([0..p-1],2);
  return List(ss,i->List(ss,j->(E(p)^(i*Reversed(j))-E(p)^(i*j))/p));
end;
```

testmat(12)^2 はGAP3で0.31秒、GAP4で0.22秒かかります。
