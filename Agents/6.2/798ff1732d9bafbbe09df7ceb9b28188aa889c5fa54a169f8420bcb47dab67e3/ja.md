```
EventQueueABM <: AgentBasedModel
```

[`AgentBasedModel`](@ref) の具体的な実装で、[`StandardABM`](@ref) の離散時間の性質とは対照的に、連続時間で動作します。

このモデルの時間の進化がどのように機能するかの概要は次のとおりです。

モデルには作成可能なイベントのリストが提供されます。イベントには4つの情報があります。

1. トリガーされたときに実行されるアクション。アクションは、イベントに対応するエージェントに作用する汎用のJulia関数 `action!(agent, model)` です。同様に、[`StandardABM`](@ref) の `agent_step!` と同様に、この関数は何でも行うことができ、Agents.jl [API](@ref) やJuliaエコシステム全体の任意の関数を利用できます。`action!` 関数は、[`add_event!`](@ref) 関数を使用して新しいイベントを生成することができますが、デフォルトの動作は新しいイベントを自動的に生成することです。以下を参照してください。
2. イベントの傾向。傾向は、確率質量に似た概念です。エージェントのために新しいイベントを自動的に生成する際、まずそのエージェントに適用可能なすべてのイベントが収集されます。次に、それらの傾向が計算されます。生成されたイベントは、各可能なイベントをその傾向で重み付けしてランダムに選択されます。
3. イベントが適用されるエージェントのタイプ。デフォルトではすべてのタイプに適用されます。
4. イベントのタイミング、すなわち生成された後にいつトリガーされるべきか。デフォルトでは、これはイベントの傾向で割った指数分布のランダム変数です。すなわち、傾向を「レート」として持つポアソン過程に従います。したがって、イベントのタイミングはABMの自然な時間スケールを確立します。

イベントは時間的に順序付けられたキューにスケジュールされ、モデルの進化時間がイベントの時間に達すると、イベントが「トリガー」されます。これは、最初にイベントアクションが対応するエージェントに対して実行されることを意味します。デフォルトでは、イベントがアクションを完了すると、同じエージェントのために新しいイベントが生成されます（エージェントがまだ存在する場合）、上記で説明した傾向に基づいてランダムに選択されます。次に、新しいイベントのための時間が生成され、新しいイベントがキューに戻されます。このように、イベントはアクションを完了した後に常に新しいイベントを生成します（デフォルトでは、これは上書き可能です）。イベントのスケジューリングとトリガーは、イベントが実際に何をするかには無関係であることに注意してください。イベントが何もしなくても、スケジュールされていればエージェントの時間を「消費」します。これは、エージェントとモデルの状態に応じて、傾向関数でそのようなイベントに傾向0を割り当てることで回避できます。

`EventQueueABM` は「ギレスピー」様のシミュレーションの一般化であり、標準的なギレスピーシミュレーションよりも多くの力と柔軟性を提供し、デフォルト設定で「ギレスピー」様の構成も可能にします。

`EventQueueABM` を構築する方法は次のとおりです。

```
EventQueueABM(AgentType, events [, space]; kwargs...)
```

[`EventQueueABM`](@ref) のインスタンスを作成します。

モデルは、指定された `space` に存在する `AgentType(s)` 型のエージェントを期待します。`AgentType(s)` は、[`@agent`](@ref) または `@multiagent` またはエージェントタイプの `Union` の結果です。

`space` は `AbstractSpace` のサブタイプであり、利用可能なすべてのスペースについては [Space](@ref available_spaces) を参照してください。

`events` は、スケジュールされ、エージェントに影響を与える [`AgentEvent`](@ref) のインスタンスのコンテナです。`events` に対して `Tuple` または `NamedTuple` を使用すると、最適なパフォーマンスが得られます。`events` のキータイプは、[`add_event!`](@ref) にインデックスとして与えられるものでもあります。

デフォルトでは、[`add_agent!`](@ref) を介して新しいエージェントがモデルに追加されるたびに、そのエージェントに影響を与える可能性のあるイベントのプールに基づいて新しいイベントが生成されます。このようにして、エージェントがモデルに追加されると、シミュレーションはすぐに開始できます。この動作はキーワードで無効にできます。この場合、モデルが時間的に進化できるように、キューにイベントを追加するために手動で [`add_event!`](@ref) 関数を使用する必要があります（デフォルトのイベントスケジューリングの動作に関係なく、この関数は常に使用できます）。

## キーワード引数

  * `container, properties, rng, warn`: [`StandardABM`](@ref) と同じです。
  * `autogenerate_on_add::Bool = true`: エージェントがモデルに追加されたときに、新しいイベントを自動的に生成するかどうか。
  * `autogenerate_after_action::Bool = true`: イベントがトリガーされた後に、エージェントのために新しいイベントを自動的に生成するかどうか。

!!! warn "まだIOなし"
    このモデルは、[`save_checkpoint`](@ref AgentsIO.save_checkpoint) のようなIO操作をまだサポートしていません。これを実装するプルリクエストを歓迎します！

