```
run!(model::ABM, t::Union{Real, Function}; kwargs...)
```

モデルを実行します（[`step!`](@ref)`(model, t)`を介して進化させながら）、同時にキーワードで指定されたデータを収集します。データは、エージェントレベルのデータ用の`agent_df`とモデルレベルのデータ用の`model_df`の2つの`DataFrame`として返されます。

モデルを実行しながらデータをファイルに書き込むには、[`offline_run!`](@ref)も参照してください。

## データ決定キーワード

  * `adata::Vector`は「収集するエージェントデータ」を意味します。エントリが`Symbol`（例：`:weight`）の場合、このエントリのデータはエージェントのフィールド`weight`です。エントリが`Function`（例：`f`）の場合、このエントリのデータは各エージェント`a`に対して`f(a)`です。結果のデータフレームの列名は入力シンボル（ここでは`:weight, :f`）で名付けられます。
  * `adata::Vector{<:Tuple}`：`adata`がタプルのベクターである場合、データ集約はエージェントのプロパティに対して行われます。

    各2タプルについて、最初のエントリは「キー」（上記のようなエントリ、例：`:weight, f`）です。2番目のエントリはキーを集約する集約関数（例：`mean, maximum`）です。したがって、上記の例を続けると、`adata = [(:weight, mean), (f, maximum)]`となります。

    条件関数（`Bool`を返す）を持つ3タプルを提供することも可能です。これは、各エージェントが集約に含まれるべきかどうかを評価します。例えば：`x_pos(a) = a.pos[1]>5`で`(:weight, mean, x_pos)`は、x位置が5より大きいエージェントの平均体重を結果として得ます。

    結果のデータ名の列は、関数[`dataname`](@ref)を使用して作成されます。これにより、`:mean_weight`や`:maximum_f_x_pos`のようなものが作成されます。さらに、リスト内包表記を使用して配列の要素を異なる列に割り当てるために匿名関数を使用することもできます：`adata = [(a)->(a.interesting_array[i]) for i=1:N]`。データが収集された後、`DataFrames.rename!`を使用して列名を変更することもできます。

    **注意：** 集約は、集約されるエージェントが存在する場合にのみ機能します。モデルの実行中にエージェントを削除する場合は、集約関数を修正する必要があります。*例*：`mean`を渡す代わりに、`mymean(a) = isempty(a) ? 0.0 : mean(a)`を渡します。
  * `mdata::Vector`は「収集するモデルデータ」を意味し、`adata`とまったく同じように機能します。モデルの場合、集約は不可能です（集約するものがないため）。

    あるいは、`mdata`は関数であることもできます。これは「ジェネレータ」関数で、`model`を入力として受け取り、`mdata`を表す`Vector`を提供します。ジェネレータ関数を必要とする[`ensemblerun!`](@ref)呼び出しと組み合わせて使用するのに便利です。

デフォルトでは、両方のキーワードは`nothing`であり、つまり何も収集/集約されません。

## 混合モデル

混合モデルの場合、`adata`キーワードには追加のオプションとプロパティがあります。出力データフレームには追加の列`agent_type`が配置されます。

あるエージェントタイプに必要なデータが、別のエージェントタイプに存在しない場合、`missing`値がデータフレームに追加されます。

**警告：** このオプションは本質的に型が不安定であるため、パフォーマンスが重要な状況ではこれを避けるようにしてください。

`missing`値が明示的に処理されていない場合、集約関数は失敗します。`a1.weight`があるが`a2`（タイプ：Agent2）には`weight`がない場合、`a2(a) = a isa Agent2; adata = [(:weight, sum, a2)]`を使用して欠損結果をフィルタリングします。

## その他のキーワード

  * `when = 1`：データ収集と処理を行う時間。`when`のタイプに基づいて多くの柔軟性が提供されます。`t = abmtime(model)`（これは`run!`プロセス全体で更新されます）とします。

      * `when::Real`：モデルが少なくとも`when`単位の時間進化するたびにデータが収集されます。[`StandardABM`](@ref)のような離散時間モデルの場合、これは整数でなければならず、実質的には各データ収集の間に進化するステップ数を意味します。[`EventQueueABM`](@ref)のような連続時間モデルの場合、`when`はモデルを進化させる最小の時間です（最大は次のイベントがトリガーされるまで）。
      * `when::AbstractVector`：データは`t ∈ when`のときに収集されます。
      * `when::Function`：`when(model, t)`が`true`を返すときにデータが収集されます。
  * `when_model = when`：モデルデータ用の`when`と同じです。
  * `init = true`：ステップを踏む前の初期モデル状態でデータを収集するかどうか。
  * `dt = 0.01`：データ収集チェックの`when`と可能なデータ記録時間の間の連続時間モデルの最小ステッピング時間。`when isa Real`の場合、`dt ≤ minimum(when, when_model)`が成り立たなければなりません。このキーワードは、定義上1であるため、離散時間モデルには無視されます。
  * `obtainer = identity`：収集したデータを`DataFrame`に転送する方法。通常、進化中に変更される可変コンテナ（例：`Vector`）がある場合は[`copy`](https://docs.julialang.org/en/v1/base/base/#Base.copy)に変更し、ネストされた可変コンテナがある場合は[`deepcopy`](https://docs.julialang.org/en/v1/base/base/#Base.deepcopy)に変更します。これらのオプションはどちらもパフォーマンスペナルティがあります。
  * `showprogress=false`：進行状況を表示するかどうか。
