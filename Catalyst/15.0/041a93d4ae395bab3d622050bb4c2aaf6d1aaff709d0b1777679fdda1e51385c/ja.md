```
stability(u::Vector{T}, rs::ReactionSystem, p; tol = 10*sqrt(eps())
            ss_jac = steady_state_jac(u, rs, p))
```

定常状態の安定性を計算します（返される値は `Bool` で、`true` は安定性を示します）。

引数:

  * `u`: 安定性を計算したい定常状態。
  * `rs`: 安定性を計算したい `ReactionSystem` モデル。
  * `p`: 安定性を計算したいパラメータセット。
  * `tol = 10*sqrt(eps())`: 計算された固有値の実部が負/正と見なせるかどうかを判断するために使用される許容誤差。実際には、対応するヤコビ行列の最大固有値の実部が < 0 の場合、定常状態は安定と見なされます。ただし、この最大固有値が `-tol< eig < tol` の範囲にある場合、安定性を十分な確実性で保証できないと見なすため、エラーが発生します。選択された `tol = 10*sqrt(eps())` はあまり分析されていません。
  * `ss_jac = steady_state_jac(u, rs)`: 安定性計算に使用されるヤコビ行列を `steady_state_jac` を使用して事前に計算することが可能です。多くの状態の安定性を計算する場合、ヤコビ行列を事前に計算することで評価が速くなる可能性があります。

例:

```julia
# モデルを作成します。
rn = @reaction_network begin
    (p,d), 0 <--> X
end
p = [:p => 1.0, :d => 0.5]

# （自明な）定常状態を見つけ、その安定性を計算します。
steady_state = [2.0]
steady_state_stability(steady_state, rn, p)

注意:
- 入力 `u` は（現在）値のベクトル（例えば `[1.0, 2.0]`）とベクトルマップ（例えば `[X => 1.0, Y => 2.0]`）の両方であることができます。その理由は、安定性を計算するためのほとんどの方法が値のベクトルしか生成しないためです。ただし、可能であれば、マップの形式の値で作業することをお勧めします。
- Catalyst は現在、システムの最大固有値の実部が負であるかどうかを確認するという単純なアプローチを使用して定常状態の安定性を計算しています。より高度な安定性計算方法は存在します（そして Catalyst にとって歓迎される追加機能ですが）、これらを実装する直接的な計画はありません。さらに、Catalyst は計算された固有値が 0 から十分に離れているかどうかを判断するために許容誤差 `tol = 10*sqrt(eps())` を使用します。この選択された閾値は `tol` 引数を通じて変更できます。
```
