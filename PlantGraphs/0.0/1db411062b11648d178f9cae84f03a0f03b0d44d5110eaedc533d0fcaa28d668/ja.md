```
traverse(g::Graph; fun = () -> nothing, order = "any", ID = root_id(g))
```

グラフ内のすべてのノードを反復処理し、各ノードに対して関数 `fun` を実行します。

## 引数

  * `g::Graph`: 反復処理されるグラフオブジェクト。

## キーワード

  * `fun`: ユーザーによって定義された関数または関数のようなオブジェクトで、各ノードに適用されます。
  * `order`: グラフ内のノードが訪問される順序。デフォルトは "any"、"dfs"（深さ優先探索）または "bfs"（幅優先探索）です。
  * `ID`: 反復処理を開始するノードのID。デフォルトでは、反復処理はグラフのルートから始まります。

## 詳細

`order = "any"` の場合、反復処理はグラフ内にノードが格納されている順序で行われます。この順序は任意であり（ノードが作成される順序には対応しません）、再現可能であるべきです（すなわち、同じコードはノードを同じ順序で格納します）。アルゴリズムによっては `any = "dfs"` または `any = "bfs"` を使用する必要があります。

`order = "dfs"` の場合、反復処理は深さ優先の順序で行われます。つまり、グラフの枝のすべてのノードがリーフノードに到達するまで訪問され、その後次の枝に移動します。したがって、このアルゴリズムは同じグラフに適用されたときに常に同じ結果を生成するはずです（ユーザー定義の関数が確率的でないと仮定）。

`order = "bfs"` の場合、反復処理は幅優先の順序で行われます。つまり、グラフの特定の深さにあるすべてのノードが最初に訪問され、その後次のレベルに移動します。したがって、このアルゴリズムは同じグラフに適用されたときに常に同じ結果を生成するはずです（ユーザー定義の関数が確率的でないと仮定）。深さ優先の順序を使用するこの関数のバージョンについては、`traverse_dfs` を参照してください。

この関数は `fun` によって生成された結果を保存しません。したがって、ユーザーがそのような結果を追跡したい場合は、間接的に保存する必要があります（例：グローバル変数を介して、またはファンクタを作成して内部的に）。

ユーザーによって提供される関数または関数のようなオブジェクトは、グラフ内の各ノードに `data()` を適用することに対応する1つの引数のみを取る必要があります。このような関数のいくつかのメソッドは、グラフ内の異なるタイプのノードに対して定義される場合があります。関数はノードに格納されたデータを使用するため、ノード間の関係は入力として使用できません。ノード間の関係が重要なアルゴリズムの場合、ユーザーは代わりにクエリを使用する必要があります（`Query` および一般的な VPL ドキュメントを参照）。

## 戻り値

この関数は何も返しませんが、`fun` は副作用を持つ可能性があります。

## 例

```jldoctest
julia> struct A1 <: Node val::Int end;

julia> struct B1 <: Node val::Int end;

julia> struct Foo
         vals::Vector{Int}
       end;

julia> function (f::Foo)(x)
         push!(f.vals, x.val)
       end;

julia> f = Foo(Int[]);

julia> axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia> g = Graph(axiom = axiom);

julia> traverse(g, fun = f);

julia> traverse(g, fun = f, order = "dfs");

julia> traverse(g, fun = f, order = "bfs");
```
