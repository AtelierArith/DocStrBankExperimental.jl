@symbolic_model generates the free model of a theory, generated by symbols.

This is backwards compatible with the @syntax macro in Catlab.

One way of thinking about this is that for every type constructor, we add an additional term constructor that builds a "symbolic" element of that type from any Julia value. This term constructor is called "generator".

An invocation of `@symbolic_model` creates the following.

1. A module with a struct for each type constructor, which has a single type

parameter `T` and two fields, `args` and `type_args`. Instances of this struct are thought of as elements of the type given by the type constructor applied to `type_args`. The type parameter refers to the term constructor that was used to generate the element, including the special term constructor `:generator`, which has as its single argument an `Any`.

For instance, in the theory of categories, we might have the following elements.

```
using .FreeCategory
x = Ob{:generator}([:x], [])
y = Ob{:generator}([:y], [])
f = Hom{:generator}([:f], [x, y])
g = Hom{:generator}([:g], [y, x])
h = Hom{:compose}([f, g], [x, x])
```

2. Methods inside the module (not exported) for all of the term constructors and

field accessors (i.e. stuff like `compose, id, dom, codom`), which construct terms.

3. A default instance (i.e., without a model parameter) of the theory using the

types in this generated model. Methods in this instance can be overridden by the body of `@symbolic_model` to perform rewriting for the sake of normalization, for instance flattening associative and unital operations.

4. Coercion methods of the type constructors that allow one to introduce generators.

```
x = ThCategory.Ob(FreeCategory.Ob, :x)
y = ThCategory.Ob(FreeCategory.Ob, :y)
f = ThCategory.Hom(:f, x, y)
```

Note that in both the instance and in these coercion methods, we must give the expected type as the first argument when it cannot be infered by the other arguments. For instance, instead of

```
munit() = ...
```

we have

```
munit(::Type{FreeSMC.Ob}) = ...
```

and likewise instead of

```
ThCategory.Ob(x::Any) = ...
```

we have

```
ThCategory.Ob(::Type{FreeCategory.Ob}, x::Any) = ...
```

Example:

```julia
@symbolic_model FreeCategory{ObExr, HomExpr} ThCategory begin
  compose(f::Hom, g::Hom) = associate_unit(new(f,g; strict=true), id)
end
```

This generates:

```julia
module FreeCategory
export Ob, Hom
using ..__module__

module Meta
  const theory_module = ThCategory
  const theory = ThCategory.Meta.theory
  const theory_type = ThCategory.Meta.T
end

struct Ob{T} <: __module__.ObExpr{T} # T is :generator or a Symbol
  args::Vector
  type_args::Vector{GATExpr}
end

struct Hom{T} <: __module__.HomExpr{T}
  args::Vector
  type_args::Vector{GATExpr}
end

dom(x::Hom) = x.type_args[1]

codom(x::Hom) = x.type_args[2]

function compose(f::Hom, g::Hom; strict=true)
  if strict && !(codom(f) == dom(g))
    throw(SyntaxDomainError(:compose, [f, g]))
  end
  Hom{:compose}([f, g], [dom(f), codom(g)])
end

function id(x::Ob)
  Ob{:id}([x], [x, x])
end
end

# default implementations 

function ThCategory.dom(x::FreeCategory.Hom)::FreeCategory.Ob
  FreeCategory.dom(x)
end

function ThCategory.Ob(::Type{FreeCategory.Ob}, __value__::Any)::FreeCategory.Ob
  FreeCategory.Ob{:generator}([__value__], [])
end

function ThCategory.id(A::FreeCategory.Ob)::FreeCategory.Hom
  FreeCategory.id(A)
end

function ThCategory.compose(f::FreeCategory.Hom, g::FreeCategory.Hom; strict=true)
  associate_unit(FreeCategory.compose(f, g; strict), id)
end
```
