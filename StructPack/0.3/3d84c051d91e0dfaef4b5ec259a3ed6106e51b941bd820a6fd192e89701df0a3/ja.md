マップ / 辞書の値をパッキングするためのコアフォーマット。

`fixmap`、`map 16`、`map 32`のmsgpackフォーマットに基づいています。

## デフォルト

[`MapFormat`](@ref)は、`NamedTuple`および`Dict`のサブタイプのデフォルトフォーマットです。次のように使用します。

```
format(::Type{T}) = MapFormat()
```

または

```
@pack T in MapFormat
```

で、[`MapFormat`](@ref)を型`T`のデフォルトフォーマットにします。`T`が抽象型の場合は、すべてのサブタイプをカバーするために`{<: T}`を使用します。

## パッキング

[`MapFormat`](@ref)で型`T`の値をパッキングすることをサポートするには、次のように実装します。

```
destruct(val::T, ::MapFormat)::R
```

ここで、返される値`ret::R`は`Base.length(ret)`（エントリの数）を実装している必要があり、エントリとしてキーと値のペアを持つイテラブルでなければなりません。`val`のエントリのキー/値フォーマットは、[`keyformat`](@ref)および[`valueformat`](@ref)を介して決定され、`state`は線形インデックスです。

## アンパッキング

[`MapFormat`](@ref)でパッキングされた型`T`の値をアンパッキングすることをサポートするには、次のように実装します。

```
construct(::Type{T}, pairs::Generator{T}, ::MapFormat)::T
```

または、コンストラクタ`T(pairs::Generator{T})`が定義されていることを確認します（[`Generator`](@ref]を参照）。ここで、`pairs`はエントリとしてキーと値のペアを含みます。キーと値のそれぞれの型とフォーマットは、[`keytype`](@ref)、[`valuetype`](@ref)、[`keyformat`](@ref)、および[`valueformat`](@ref)を介してアンパッキング中に決定され、`state`は線形インデックスです。

!!! warning
    構築中は、ジェネレーター`pairs`のすべてのエントリをイテレートする必要があります。`Generator{T}`は、アンパックされるIOソースから読み取る遅延マップをラップしているため、次のオブジェクトが処理される前にイテレーションを行わないと、後続の値のアンパッキングに干渉します。同じ理由から、オブジェクト`pairs`を保存して後でアクセスすることは避けるべきです。

