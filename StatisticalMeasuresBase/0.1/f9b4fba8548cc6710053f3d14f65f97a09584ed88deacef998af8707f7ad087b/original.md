```
aggregate(itr; weights=nothing, mode=Mean(), skipnan=false)
```

Aggregate the values generated by the iterator, `itr`, using the specified aggregation `mode` and optionally specified numerical `weights`.

Any `missing` values in `itr` are skipped before aggregation, but will still count towards normalization factors. So, if the return type has a zero, it's as if we replace the `missing`s with zeros.

The values to be aggregated must share a type for which `+`, `*` `/` and `^` (`RootMean` case) are defined, or can be dictionaries whose value-type is so equipped.

# Keyword options

  * `weights=nothing`: An iterator with a `length`, generating `Real` elements, or `nothing`
  * `mode=Mean()`: Options include `Mean()` and `Sum()`; see [`StatisticalMeasuresBase.AggregationMode`](@ref) for all options and their meanings. Using `Mean()` in conjunction with weights returns the usual weighted mean scaled by the average weight value.
  * `skipnan=false`: Whether to skip `NaN` values in addition to `missing` values
  * `aggregate=true`: If `false` then `itr` is just multiplied by any specified weights, and collected.

# Example

Suppose a 3-fold cross-validation algorithm delivers root mean squared errors given by `errors` below, and that the folds have the specified `sizes`. Then `μ` below is the appropriate error aggregate.

```julia
errors = [0.1, 0.2, 0.3]
sizes = [200, 200, 150]
weights = 3*sizes/sum(sizes)
@assert mean(weights) ≈ 1
μ = aggregate(errors; weights, mode=RootMean())
@assert μ ≈ (200*0.1^2 + 200*0.2^2 + 150*0.3^2)/550 |> sqrt
```

---

```
aggregate(f, itr; options...)
```

Instead, aggregate the results of broadcasting `f` over `itr`. Weight multiplication is fused with the broadcasting operation, so this method is more efficient than separately broadcasting, weighting, and aggregating.

This method has the same keyword `options` as above.

# Examples

```julia
itr = [(1, 2), (2, 3), (4, 3)]

julia> aggregate(t -> abs(t[1] - t[2]), itr, weights=[10, 20, 30], mode=Sum())
60
```
