```
UnsafePtr{T}(r)
```

`r`の内容へのポインタで、`Ptr`、`Ref`、`Array`、`String`、または`pointer(r)`メソッドを持つ任意のものかもしれません。

`T`は要素の型を指定し、オプションです。

便利（しかし安全でない）なセマンティクスがあります：

  * `p[]`は要素をデリファレンスし、代入可能です。
  * `p[i]`は配列を指していると仮定して`i`番目の要素をデリファレンスします。
  * `p.name`は`p[]`の`name`フィールドへの`UnsafePtr`です。タプルの場合、`p._n`は`n`番目のフィールドを指します。
  * `p+i`は`i`番目の次の要素への`UnsafePtr`です。`(p+i-1)[]`と`p[i]`は同等です。
  * `p-q`は`p`と`q`の間の要素の数で、`p === q+(p-q)`となります。
  * イテレーションは`p[1]`、`p[2]`、... 永遠に続きます。
  * `Array(p, dims...)`は`p`が指す連続データの配列ビューです（`unsafe_wrap(Array, pointer(p), dims)`と同等です）。
  * `p[idxs]`/`view(p, idxs)`は各`i ∈ idxs`に対する`i`番目の要素の配列/ビューです。
  * `String(p, [length])`は`p`を文字列に変換します（`unsafe_string(pointer(p), length)`と同等です）。

最初の4つの操作には次のCの同等物があります：`*p`、`p[i-1]`、`&(p->name)`および`p+i`。

デリファレンスの結果がポインタのようなものであれば、代わりに`UnsafePtr`が返されます（[`doautowrap`](@ref）を参照）。元の値を取得するには`p[!,i]`または`unsafe_load(p,i)`を使用してください。

# 安全性

ポインタが有効であり続けることを保証するのは呼び出し元の責任です。例えば、`r`がガーベジコレクトされないようにすることです。

ビットタイプでない値に代入すると、Juliaがクラッシュする可能性があります。

# 例

ここでは、（不変の）名前付きタプルへの（可変の）参照の個々のフィールドにアクセスして変更します。

```julia
r = Ref((a=1, b=(2, 3)))
@show r[]            # (a = 1, b = (2, 3))
p = UnsafePtr(r)
p.a[] = 99
p.b._2[] *= 10
@show r[]            # (a = 99, b = (2, 30))
@show Array(p.a, 3)  # [99, 2, 30]
```
