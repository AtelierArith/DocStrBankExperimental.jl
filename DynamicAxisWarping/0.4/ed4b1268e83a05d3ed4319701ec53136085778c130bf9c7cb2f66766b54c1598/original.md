```
gdtw(
    x,
    y,
    ::Type{T}  = Float64;
    symmetric::Bool = true,
    M::Int     = 100,
    N::Int     = 100,
    t          = range(T(0), stop = T(1), length = N),
    cache::GDTWWorkspace = GDTWWorkspace(T, M, length(t)),
    λcum       = T(0.01),
    λinst      = T(0.01),
    η          = T(1 / 8),
    max_iters  = 3,
    metric     = (x, y) -> norm(x - y),
    Rcum       = abs2,
    smin::Real = T(0.001),
    smax::Real = T(5.0),
    Rinst      = symmetric  ?
                    ϕ′ -> ( (smin <= ϕ′ <= smax)
                        && (smin <= 2 - ϕ′ <= smax) ) ? (ϕ′-1)^2 : typemax(T)
                            :
                    ϕ′ -> (smin <= ϕ′ <= smax) ? (ϕ′-1)^2 : typemax(T),
    verbose    = false,
    warp       = zeros(T, length(t)),
    callback   = nothing,
) where T -> cost, ϕ, ψ
```

Computes a general DTW distance following [DB19](https://arxiv.org/abs/1905.12893).

Aims to find `ϕ(s)` to minimize

```
∫ metric(x(ϕ(s)), y(ψ(s))) + λinst*Rinst(ϕ'(s) - 1) + λcum*Rcum(ϕ(s) - s) ds
```

over the interval `s ∈ [0,1]`, where `ψ(s) = 2s - ϕ(s)` (if `symmetric=true`) or `ψ(s) = s` (if `symmetric = false`). The integral is discretized in time into `N` points (or according to the times `t`, if `t` is specified). Additionally, the possible values obtained by `ϕ` (and hence `ψ`) at each possible time `s` are discretized into `M` points.

If `max_iters > 1`, then after solving the doubly-discretized problem to obtain the optimal `ϕ`, the problem is solved again by choosing a new discretization of `M` possible values of `ϕ(s)` in an interval (whose width is governed by the parameter `η`) around the previous optimal value. This is repeated until the problem has been solved `max_iters` times in total. Setting `verbose=true` prints the cost at each iteration; a "high enough" value of `max_iters` can be chosen by inspecting when the cost stabilizes sufficiently.

The parameters are:

  * `x`: the continuous time signal to warp (see [`LinearInterpolation`](@ref) for generating such a signal from discrete data)
  * `y`: the continuous-time signal to warp to
  * `T`: the numeric type to be used in the problem
  * `symmetric`: if true, `ψ(s) = 2s - ϕ(s)`, otherwise `ψ(s) = s`.
  * `t`: the discretization of time on `[0,1]`; either `t` or `N` should be specified
  * `M`: the discretization of the values obtained by the warping path
  * `metric`:  a function `metric(u,v) -> ℝ` to compute differences between the signals at a time point (such as a Distances.jl distance)
  * `Rcum`: penalty function on the cumulative warp
  * `Rinst`: penalty function on the instantaenous warping. Should be infinite outside of `[smin, smax]`.
  * `smin`, `smax`: minimum and maximum allowed instantaenous warping. Should have `smin > 0` and `smin < smax`.
  * `λcum`, `λinst`: the regularization constants for `Rcum` and `Rinst`, respectively

The following may be pre-allocated and reused between distance computations with the same `M` and `N` (or `length(t)`).

  * `cache`: a cache of matrices and vectors, generated by `GDTW.GDTWWorkspace{T}(N,M)`
