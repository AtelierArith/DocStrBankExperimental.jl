ptcsol(F!, x0, FS, FPS, J! = diffjac!; rtol=1.e-6, atol=1.e-12,              maxit=20, delta0=1.e-6, dx=1.e-7, pdata = nothing, jfact = klfact,                printerr = true, keepsolhist = false, jknowsdt = false)

C. T. Kelley, 2022

私のSIAMの本からの非線形ソルバーのJuliaバージョン。ここに新しいものがあります ==> ptcsol

PTCはu' = -F(u)、u(0) = u_0の定常状態解を見つけます。-記号は慣例です。

関数とヤコビアンのストレージを事前に割り当てる必要があります –> 呼び出しプログラム内で <– つまり、FSとFPSで

入力:

  * F!: 関数評価、!はF!がFSを上書きすることを示し、関数のための事前に割り当てられたストレージです。

    したがって、FS=F!(FS,x)またはFS=F!(FS,x,pdata)はFS=F(x)を返します。

    あなたの関数は必ず –> FSを返す <– 必要があります。TestProblems/Systems/FBeam!.jlの例を参照してください。
  * x0: 初期反復値
  * FS: 関数のための事前に割り当てられたストレージ。サイズNのベクトルです。

    (N)として保存し、F!をサイズ(N)のベクトルを使用するように設計する必要があります。(N,1)を一貫して使用する場合、ソルバーは機能するかもしれませんが、保証はできません。
  * FPS: ヤコビアンのための事前に割り当てられたストレージ。N x Nの行列です。

    FPSがスパースの場合、対角線のためのストレージを**必ず**割り当てる必要があります。そうすれば、そこに1/dtを入れるスペースがあります。
  * J!: ヤコビアン評価、!はJ!がFPSを上書きすることを示し、ヤコビアンのための事前に割り当てられたストレージです。これを省略すると、デフォルトは有限差分ヤコビアンです。

    したがって、FP=J!(FP,FS,x)またはFP=J!(FP,FS,x,pdata)はFP=F'(x)を返します；(FP,FS,x)は引数リストでなければなりません。たとえFPがFSを必要としなくても。これには、有限差分ヤコビアンが必要であり、これはソルバーのデフォルトです。

    あなたのヤコビアン関数は必ず –> FPを返す <– 必要があります。TestProblems/Systems/FBeam!.jlの例を参照してください。

    あなたのヤコビアンに(1/dt) Iを追加するより良い方法があるかもしれません。これを自分で行いたい場合、あなたのヤコビアン関数はFP=J!(FP,FS,x,dt)またはFP=J!(FP,FS,x,dt,pdata)とし、F'(x) + (1.0/dt)*Iを返す必要があります。

    また、kwarg **jknowsdt**をtrueに設定する必要があります。
  * 精度: 精度についてお話ししましょう。このコードは、あなたが望む任意の精度で完全精度の関数と線形代数のために設計しました。FPSをFloat64、Float32、またはFloat16として宣言することができ、ptcsolはあなたがJ!関数内で宣言を破壊しない限り、正しいことを行います。これがこんなに簡単に機能することに驚いています。ヤコビアンが適切に条件付けされている場合、ヤコビアンの因子分解とストレージのコストを半分に削減できます。大きな密なヤコビアンと安価な関数の場合、これは良い取引です。

    しかし... Float64以外の直接スパースソルバーに対するサポートは非常に限られています。あなたが本当に何をしているのかを知っていない限り、直接スパースソルバーにはFloat64のみを使用することをお勧めします。ノートブックにいくつかの例がありますが、注意してください。

---

キーワード引数 (kwargs):

rtolおよびatol: 相対および絶対誤差許容値

delta0: 初期擬似時間ステップ。デフォルト値の1.e-3は少し保守的で、実際に試すべきオプションの1つです。私が1.0に設定した例を見てください！

maxit: 非線形反復の制限、デフォルト=100。

これはdelta0に結びついています。delta0の選択が小さすぎる（保守的）場合、収束するために多くの反復が必要になり、maxitの値を大きくする必要があります。

PTCでは、通常の非線形解法よりも多くの反復が必要です。これは安定した解を見つけるための代償の一部です。

dx: デフォルト = 1.e-7

有限差分導関数における差分増分       h=dx*norm(x)+1.e-6

pdata:

関数/ヤコビアンのための事前計算データ。このデータを使用すると、関数/ヤコビアン内のグローバル変数にデータを隠すよりも、うまくいきます。

jfact: デフォルト = klfact（最適な選択を見つけようとします）

ヤコビアンに特別な構造がある場合は、jfactを因子分解のための正しい選択に設定してください。

私はPTCUpdateを呼び出してヤコビアンを評価（あなたのJ!を使用）し、因子分解する際にjfactを使用します。デフォルトは、klfact（内部関数）を使用して合理的なことを行うことです。一般的な密行列の場合、klfactはlu!を選択してLU因子分解を計算し、ヤコビアンとストレージを共有します。たとえば、ヤコビアンがspdの場合、jfact = cholseky!に設定することでLUを別のものに変更できます。

klfactはバンド行列について知っており、qrを選択します。ただし、RTFMを行い、追加の2つの上部バンドを割り当て、jfact=qr!を使用してklfactをオーバーライドする必要があります。

klfactは一般的なスパース行列にluを使用します。

klfactがディスパッチ方法を知らないものを与えると、何も起こりません。私は元のヤコビアン行列を返し、ptcsolはニュートンステップを計算するためにバックスラッシュを使用します。

これはおそらくあなたの状況では最適ではないことを知っていますので、jfact = luのように他の何かを選ぶのが良いです。

printerr: デフォルト = true

ソルバーが失敗したときに役立つメッセージを印刷します。そのメッセージを抑制するには、printerrをfalseに設定します。

keepsolhist: デフォルト = false

これをtrueに設定すると、出力タプルに反復の履歴が得られます。これはスカラー方程式のデフォルトでオンになっており、システムではオフになっています。データが本当に大きくなる可能性があるため、データを使用する必要がある場合にのみオンにしてください。

jknowsdt: デフォルト = false

あなたのヤコビアン評価関数がF'(x) + (1/dt) Iを返す場合は、これをtrueに設定します。また、ヤコビアン評価関数に関する上記のルールに従う必要があります。私はこれをお勧めしませんし、ヤコビアンが行列以外のものである場合は何も保証できません。私はこれを行列出力のみに対してテストしました。

出力:

名前付きタプル(solution, functionval, history, stats, idid,                errcode, solhist) ここで

solution = 収束した結果 functionval = F(solution) history = 反復の残差ノルムのベクトル (||F(x)||)

nsol、nsoli、またはptcsoliとは異なり、ptcsolは反復ごとに1つの関数、1つのヤコビアン、および1つの因子分解の固定コストがあります。したがって、反復統計は興味深くなく、出力には含まれません。

idid=trueは反復が成功した場合、falseはそうでない場合です。

errcode = 反復が成功した場合は0         = 初期反復値が終了基準を満たす場合は-1         = maxit反復後に収束しない場合は10

solhist:

これは、keepsolhist=trueに設定した場合の反復の全履歴です。

solhistはN x Kの配列で、Nはxの長さ、Kは反復の数+1です。したがって、スカラー方程式の場合、行ベクトルになります。

### ptcsolの例

#### バッキングビーム問題。

これが機能するにはTestProblemsを使用する必要があります。

```jldoctest
julia> using SIAMFANLEquations.TestProblems

julia> n=63; maxit=1000; delta = 0.01; lambda = 20.0;

julia> bdata = beaminit(n, 0.0, lambda); x = bdata.x;

julia> u0 = x .* (1.0 .- x) .* (2.0 .- x);

julia> u0 .*= exp.(-10.0 * u0);

julia> FS = copy(u0); FPS = copy(bdata.D2);

julia> pout = ptcsol( FBeam!, u0, FS, FPS, BeamJ!; 
 rtol = 1.e-10, pdata = bdata, delta0 = delta, maxit = maxit);

julia> # そこに到達するまでにいくつかの反復が必要です。
       length(pout.history)
25

julia> [pout.history[1:5] pout.history[21:25]]
5×2 Array{Float64,2}:
 6.31230e+01  9.75412e-01
 7.52624e+00  8.35295e-02
 8.31545e+00  6.58797e-04
 3.15455e+01  4.12697e-08
 3.66566e+01  6.29295e-12

julia> # 非負の定常状態を得ます。
       maximum(pout.solution)
2.19086e+00
```
