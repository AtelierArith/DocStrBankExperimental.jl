`FINDBASINS` - 魅力の盆地を見つける

```
 seg, counts, counts0 = findbasins(sag)
```

  * `sag`: 最も急な上昇グラフ（有向かつ無重み）。 `sag[x,y,z]` は (x,y,z) から出ているエッジをエンコードする6ビットの数を含みます。
  * `seg`: 盆地へのセグメンテーション。 3D配列の各要素は *盆地ID* を含み、これは0から盆地の数までの非負整数です。
  * `counts`: 各盆地内のボクセルの数
  * `counts0`: 背景ボクセルの数

`seg` における値0は、最も急な上昇グラフにエッジが全くない背景ボクセルを示します。 このような単独のボクセルはすべて同じIDの0が与えられますが、技術的にはそれ自体が盆地です。

アルゴリズムは未割り当てのボクセルから始まり、幅優先探索（BFS）を通じてすべての下流ボクセルを特定します。 探索は2つの方法で終了します：

1. 以前に盆地IDが割り当てられた下流ボクセル =>

キューにあるボクセルにそのIDを割り当てます。

2. もう下流ボクセルがない => キューにあるボクセルに新しい盆地IDを割り当てます。

その後、キューは空になり、BFSは未割り当てのボクセルで新たに始まります。 アルゴリズムはすべてのボクセルが割り当てられると終了します。

7ビット目（0x40）は、ボクセルがBFS中に訪問されたかどうかを示すために使用されます。

MSBは、ボクセルに盆地IDが割り当てられたかどうかを示します。 MSBの定義は、ファイルの最後にあるUInt32およびUInt64の場合の関数で示されています。

`findbasins` は `divideplateaus!` によって修正された最も急な上昇グラフに適用されます。この時点で、すべてのパスは一意であり、最大の高原を除きます。

# `findbasins` が `steepestascent` の出力に直接適用された場合はどうなりますか？  結びつきは体系的でない方法で解決されます。  Coustyの流域カットとは異なるようで、DFSとBFSの間で交互に切り替わります。
