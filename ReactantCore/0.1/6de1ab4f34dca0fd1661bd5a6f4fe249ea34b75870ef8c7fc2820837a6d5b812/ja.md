```
@trace <expr>
```

特定の式を制御フローのようにReactantフレンドリーな形式に変換します。重要なことに、式の中にトレースされた値が見つからない場合、オーバーヘッドはありません。

## 現在サポートされているもの

  * `if` 条件（`elseif` やその他の便利な機能を含む） (`@trace if ...`)
  * 先行する代入を伴う `if` 文 (`@trace a = if ...`) （マクロの位置は代入の前であり、`if` の前ではないことに注意）
  * 整数の構文的 `StepRange` を反復する単一の誘導変数を持つ `for` 文。

## 特別な考慮事項

  * 最外層の `if` のみで `@trace` を適用してください。ネストされた `if` 文は自動的に正しい形式に展開されます。

# 拡張ヘルプ

## 注意事項（コアJuliaセマンティクスからの逸脱）

### 新しい変数の導入

```julia
@trace if x > 0
    y = x + 1
    p = 1
else
    y = x - 1
end
```

外部スコープでは `x ≤ 0` の場合 `p` は定義されません。しかし、トレースされたバージョンでは、`p` は定義され、ダミー値に設定されます。

### 短絡評価操作

```julia
@trace if x > 0 && z > 0
    y = x + 1
else
    y = x - 1
end
```

`&&` と `||` は短絡評価操作です。トレースされたバージョンでは、これらをそれぞれ `&` と `|` に置き換えます。

### 型不安定な分岐

```julia
@trace if x > 0
    y = 1.0f0
else
    y = 1.0
end
```

これはコンパイルされません。なぜなら、`y` は一方の分岐で `Float32` であり、もう一方で `Float64` だからです。すべての分岐が同じ型であることを確認する必要があります。

別の例として、反復間で `x` の型が変わる以下の `for` ループがあります。

```julia
x = ... # ConcreteRArray{Int64, 1}
for i in 1f0:0.5f0:10f0
    x = x .+ i # ConcreteRArray{Float32, 1}
end
```

### 特定のシンボルは予約されています

シンボル [:(:), :nothing, :missing, :Inf, :Inf16, :Inf32, :Inf64, :Base, :Core] は `@trace` 式の変数としては許可されていません。特定のケースでは動作するかもしれませんが、これらは動作することが保証されていません。例えば、以下は動作しません：

```julia
function fn(x)
    nothing = sum(x)
    @trace if nothing > 0
        y = 1.0
    else
        y = 2.0
    end
    return y, nothing
end
```
