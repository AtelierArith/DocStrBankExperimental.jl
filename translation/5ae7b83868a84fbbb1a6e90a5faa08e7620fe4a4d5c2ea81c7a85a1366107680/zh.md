`AbstractString` 类型是 Julia 中所有字符串实现的超类型。字符串是由 `AbstractChar` 类型表示的 [Unicode](https://unicode.org/) 代码点序列的编码。Julia 对字符串做了一些假设：

  * 字符串是以固定大小的“代码单元”进行编码的

      * 可以使用 `codeunit(s, i)` 提取代码单元
      * 第一个代码单元的索引为 `1`
      * 最后一个代码单元的索引为 `ncodeunits(s)`
      * 任何索引 `i` 满足 `1 ≤ i ≤ ncodeunits(s)` 都是有效的
  * 字符串索引是基于这些代码单元进行的：

      * 可以通过 `s[i]` 使用有效的字符串索引 `i` 提取字符
      * 字符串中的每个 `AbstractChar` 由一个或多个代码单元编码
      * 只有 `AbstractChar` 的第一个代码单元的索引是有效的索引
      * `AbstractChar` 的编码与其前后内容无关
      * 字符串编码是 [自同步](https://en.wikipedia.org/wiki/Self-synchronizing_code) 的 – 即 `isvalid(s, i)` 的时间复杂度为 O(1)

一些从字符串中提取代码单元、字符或子字符串的字符串函数，如果传入超出范围或无效的字符串索引，会报错。这包括 `codeunit(s, i)` 和 `s[i]`。进行字符串索引运算的函数对索引采取更宽松的处理方式，当在范围内时会给出最接近的有效字符串索引，或者在超出范围时，表现得好像字符串的每一侧都有无限数量的字符进行填充。通常这些虚构的填充字符的代码单元长度为 `1`，但字符串类型可以根据其实现选择不同的“虚构”字符大小（例如，子字符串可能将索引运算传递给它们提供视图的底层字符串）。宽松索引函数包括那些用于索引运算的函数：`thisind`、`nextind` 和 `prevind`。该模型允许索引运算与超出范围的索引作为中间值一起工作，只要不使用它们来检索字符，这通常有助于避免需要处理边缘情况。

另请参见 [`codeunit`](@ref)、[`ncodeunits`](@ref)、[`thisind`](@ref)、[`nextind`](@ref)、[`prevind`](@ref)。
