```
@r_str -> Regex
```

정규 표현식을 구성합니다. 예를 들어 `r"^[a-z]*$"`와 같이 보간 및 이스케이프 해제 없이 구성합니다(따옴표 `"`는 여전히 이스케이프해야 함). 정규 표현식은 동작을 변경하기 위해 끝나는 따옴표 뒤에 나열된 하나 이상의 플래그를 허용합니다:

  * `i`는 대소문자를 구분하지 않는 매칭을 활성화합니다.
  * `m`은 `^` 및 `$` 토큰이 전체 문자열이 아닌 개별 행의 시작과 끝을 매칭하도록 처리합니다.
  * `s`는 `.` 수정자가 줄 바꿈을 매칭하도록 허용합니다.
  * `x`는 "자유 간격 모드"를 활성화합니다: 정규 표현식 토큰 사이의 공백은 이스케이프된 `\`를 제외하고 무시되며, 정규 표현식의 `#`는 주석을 시작하는 것으로 간주되어 줄 끝까지 무시됩니다.
  * `a`는 ASCII 모드를 활성화합니다(UTF 및 UCP 모드를 비활성화). 기본적으로 `\B`, `\b`, `\D`, `\d`, `\S`, `\s`, `\W`, `\w` 등은 유니코드 문자 속성을 기반으로 매칭됩니다. 이 옵션을 사용하면 이러한 시퀀스는 ASCII 문자만 매칭합니다. 여기에는 `\u`도 포함되며, 이는 지정된 문자 값을 단일 바이트로 직접 출력하고 UTF-8로 인코딩하려고 시도하지 않습니다. 중요하게도, 이 옵션은 매처와 대상을 단순 바이트로 취급하여 유효하지 않은 UTF-8 문자열에 대해 매칭할 수 있도록 하며(마치 ISO/IEC 8859-1 / Latin-1 바이트인 것처럼) 문자 인코딩이 아닌 바이트로 취급합니다. 이 경우, 이 옵션은 종종 `s`와 결합됩니다. 이 옵션은 패턴을 (*UCP) 또는 (*UTF)로 시작하여 더 세분화할 수 있습니다.

보간이 필요한 경우 [`Regex`](@ref)를 참조하십시오.

# 예시

```jldoctest
julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
```

이 정규 표현식은 처음 세 개의 플래그가 활성화되어 있습니다.
