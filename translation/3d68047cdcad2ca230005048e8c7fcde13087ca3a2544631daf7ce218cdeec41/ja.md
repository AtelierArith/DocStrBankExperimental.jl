```
ReentrantLock()
```

再入可能なロックを作成し、[`Task`](@ref)sの同期を行います。同じタスクは必要に応じてロックを何度でも取得できます（これが「再入可能」という名前の意味です）。各[`lock`](@ref)は[`unlock`](@ref)と対になっている必要があります。

`lock`を呼び出すと、そのスレッド上でのファイナライザの実行が対応する`unlock`まで抑制されます。以下に示す標準的なロックパターンの使用は自然にサポートされるべきですが、try/lockの順序を逆にしたり、tryブロックを完全に欠落させたりすることには注意が必要です（例：ロックを保持したまま戻ろうとすること）。

これは、ロック/アンロック呼び出しに対して取得/解放のメモリ順序を提供します。

```
lock(l)
try
    <atomic work>
finally
    unlock(l)
end
```

[`!islocked(lck::ReentrantLock)`](@ref islocked)が成立する場合、[`trylock(lck)`](@ref trylock)は、他のタスクが「同時に」ロックを保持しようとしていない限り成功します。
