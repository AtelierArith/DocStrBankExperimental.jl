`AbstractChar` 타입은 Julia의 모든 문자 구현의 수퍼타입입니다. 문자는 유니코드 코드 포인트를 나타내며, [`codepoint`](@ref) 함수를 통해 정수로 변환하여 코드 포인트의 수치 값을 얻거나 동일한 정수로부터 생성할 수 있습니다. 이러한 수치 값은 문자가 `<` 및 `==`와 같은 연산자로 비교되는 방식을 결정합니다. 새로운 `T <: AbstractChar` 타입은 최소한 `codepoint(::T)` 메서드와 `T(::UInt32)` 생성자를 정의해야 합니다.

주어진 `AbstractChar` 서브타입은 유니코드의 하위 집합만 표현할 수 있으며, 이 경우 지원되지 않는 `UInt32` 값으로부터의 변환은 오류를 발생시킬 수 있습니다. 반대로, 내장된 [`Char`](@ref) 타입은 유니코드를 *포함하는* 집합을 나타내며(유효하지 않은 바이트 스트림을 손실 없이 인코딩하기 위해), 이 경우 비유니코드 값을 `UInt32`로 변환하면 오류가 발생합니다. [`isvalid`](@ref) 함수는 주어진 `AbstractChar` 타입에서 어떤 코드 포인트가 표현 가능한지를 확인하는 데 사용할 수 있습니다.

내부적으로, `AbstractChar` 타입은 다양한 인코딩을 사용할 수 있습니다. `codepoint(char)`를 통한 변환은 항상 문자의 유니코드 값을 반환하기 때문에 이 인코딩을 드러내지 않습니다. `print(io, c)`는 모든 `c::AbstractChar`에 대해 `io`에 의해 결정된 인코딩(모든 내장 `IO` 타입에 대해 UTF-8)을 생성하며, 필요할 경우 `Char`로 변환합니다.

반면에 `write(io, c)`는 `typeof(c)`에 따라 인코딩을 발생시킬 수 있으며, `read(io, typeof(c))`는 `write`와 동일한 인코딩을 읽어야 합니다. 새로운 `AbstractChar` 타입은 `write`와 `read`의 자체 구현을 제공해야 합니다.
