El tipo `AbstractChar` es el supertipo de todas las implementaciones de caracteres en Julia. Un carácter representa un punto de código Unicode y se puede convertir a un entero a través de la función [`codepoint`](@ref) para obtener el valor numérico del punto de código, o se puede construir a partir del mismo entero. Estos valores numéricos determinan cómo se comparan los caracteres con `<` y `==`, por ejemplo. Nuevos tipos `T <: AbstractChar` deben definir un método `codepoint(::T)` y un constructor `T(::UInt32)`, como mínimo.

Un subtipo dado de `AbstractChar` puede ser capaz de representar solo un subconjunto de Unicode, en cuyo caso la conversión de un valor `UInt32` no soportado puede lanzar un error. Por el contrario, el tipo incorporado [`Char`](@ref) representa un *superconjunto* de Unicode (para codificar sin pérdida flujos de bytes inválidos), en cuyo caso la conversión de un valor no Unicode *a* `UInt32` lanza un error. La función [`isvalid`](@ref) se puede usar para verificar qué puntos de código son representables en un tipo `AbstractChar` dado.

Internamente, un tipo `AbstractChar` puede usar una variedad de codificaciones. La conversión a través de `codepoint(char)` no revelará esta codificación porque siempre devuelve el valor Unicode del carácter. `print(io, c)` de cualquier `c::AbstractChar` produce una codificación determinada por `io` (UTF-8 para todos los tipos de `IO` incorporados), a través de la conversión a `Char` si es necesario.

`write(io, c)`, en contraste, puede emitir una codificación dependiendo de `typeof(c)`, y `read(io, typeof(c))` debería leer la misma codificación que `write`. Nuevos tipos `AbstractChar` deben proporcionar sus propias implementaciones de `write` y `read`.
