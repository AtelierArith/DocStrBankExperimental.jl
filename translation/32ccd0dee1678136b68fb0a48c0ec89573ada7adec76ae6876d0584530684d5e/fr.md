```
tree_hash([ prédicat, ] tarball;
          [ algorithme = "git-sha1", ]
          [ ignorer_vide = false ]) -> hash::String

    prédicat  :: Header --> Bool
    tarball    :: Union{AbstractString, AbstractCmd, IO}
    algorithme  :: AbstractString
    ignorer_vide :: Bool
```

Calculez une valeur de hachage d'arbre pour l'arborescence de fichiers que contient le tarball. Par défaut, cela utilise l'algorithme de hachage d'arbre de git avec la fonction de hachage sécurisée SHA1 (comme les versions actuelles de git). Cela signifie que pour tout tarball dont l'arborescence de fichiers peut être représentée par git—c'est-à-dire un tarball contenant uniquement des fichiers, des liens symboliques et des répertoires non vides—la valeur de hachage calculée par cette fonction sera la même que la valeur de hachage que git calculerait pour cette arborescence de fichiers. Notez que les tarballs peuvent représenter des arborescences de fichiers avec des répertoires vides, que git ne peut pas stocker, et cette fonction peut générer des hachages pour ceux-ci, qui, par défaut (voir `ignorer_vide` ci-dessous pour savoir comment changer ce comportement), différeront du hachage d'un tarball qui omet ces répertoires vides. En résumé, la fonction de hachage est d'accord avec git sur tous les arbres que git peut représenter, mais étend (de manière cohérente) le domaine des arbres hachables à d'autres arbres que git ne peut pas représenter.

Si une fonction `prédicat` est passée, elle est appelée sur chaque objet `Header` rencontré lors du traitement du `tarball` et une entrée n'est hachée que si `prédicat(hdr)` est vrai. Cela peut être utilisé pour hacher sélectivement uniquement certaines parties d'une archive, pour ignorer des entrées qui provoquent une erreur lors de l'extraction, ou pour enregistrer ce qui est extrait pendant le processus de hachage.

Avant d'être passée à la fonction prédicat, l'objet `Header` est quelque peu modifié par rapport à l'en-tête brut dans le tarball : le champ `path` est normalisé pour supprimer les entrées `.` et remplacer plusieurs barres obliques consécutives par une seule barre oblique. Si l'entrée a le type `:hardlink`, le chemin de la cible du lien est normalisé de la même manière afin qu'il corresponde au chemin de l'entrée cible ; le champ de taille est défini sur la taille du chemin cible (qui doit être un fichier déjà vu).

Les valeurs actuellement prises en charge pour `algorithme` sont `git-sha1` (la valeur par défaut) et `git-sha256`, qui utilise le même algorithme de base que `git-sha1` mais remplace la fonction de hachage SHA1 par SHA2-256, la fonction de hachage que git utilisera à l'avenir (en raison des attaques connues sur SHA1). Le support d'autres algorithmes de hachage d'arborescence de fichiers peut être ajouté à l'avenir.

L'option `ignorer_vide` contrôle si les répertoires dans le tarball qui ne contiennent récursivement aucun fichier ou lien symbolique sont inclus dans le hachage ou ignorés. En général, si vous hachez le contenu d'un tarball ou d'une arborescence de fichiers, vous vous souciez de tous les répertoires, pas seulement des non vides, donc les inclure dans le hachage calculé est la valeur par défaut. Alors pourquoi cette fonction fournit-elle même l'option d'ignorer les répertoires vides ? Parce que git refuse de stocker des répertoires vides et les ignorera si vous essayez de les ajouter à un dépôt. Donc, si vous calculez un hachage d'arbre de référence en ajoutant des fichiers à un dépôt git et en demandant ensuite à git le hachage d'arbre, la valeur de hachage que vous obtenez correspondra à la valeur de hachage calculée par `tree_hash` avec `ignorer_vide=true`. En d'autres termes, cette option permet à `tree_hash` d'imiter la façon dont git hacherait un arbre avec des répertoires vides. Si vous hachez des arbres qui peuvent contenir des répertoires vides (c'est-à-dire qui ne proviennent pas d'un dépôt git), il est cependant recommandé de les hacher à l'aide d'un outil (comme celui-ci) qui n'ignore pas les répertoires vides.
