```
gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)
```

Löst die lineare Gleichung `A * X = B` (`trans = N`), `transpose(A) * X = B` (`trans = T`) oder `adjoint(A) * X = B` (`trans = C`) unter Verwendung der `LU`-Faktorisierung von `A`. `fact` kann `E` sein, in diesem Fall wird `A` ausgeglichen und in `AF` kopiert; `F`, in diesem Fall sind `AF` und `ipiv` von einer vorherigen `LU`-Faktorisierung Eingaben; oder `N`, in diesem Fall wird `A` in `AF` kopiert und dann faktorisert. Wenn `fact = F`, kann `equed` `N` sein, was bedeutet, dass `A` nicht ausgeglichen wurde; `R`, was bedeutet, dass `A` von links mit `Diagonal(R)` multipliziert wurde; `C`, was bedeutet, dass `A` von rechts mit `Diagonal(C)` multipliziert wurde; oder `B`, was bedeutet, dass `A` von links mit `Diagonal(R)` und von rechts mit `Diagonal(C)` multipliziert wurde. Wenn `fact = F` und `equed = R` oder `B`, müssen alle Elemente von `R` positiv sein. Wenn `fact = F` und `equed = C` oder `B`, müssen alle Elemente von `C` positiv sein.

Gibt die Lösung `X` zurück; `equed`, das eine Ausgabe ist, wenn `fact` nicht `N` ist, und beschreibt die durchgeführte Ausgleichung; `R`, die Diagonale der Zeilenausgleichung; `C`, die Diagonale der Spaltenausgleichung; `B`, das mit seiner ausgeglichenen Form `Diagonal(R)*B` (wenn `trans = N` und `equed = R,B`) oder `Diagonal(C)*B` (wenn `trans = T,C` und `equed = C,B`) überschrieben werden kann; `rcond`, die reziproke Bedingungszahl von `A` nach dem Ausgleichen; `ferr`, die obere Fehlergrenze für jeden Lösungsvektor in `X`; `berr`, die obere Fehlergrenze für jeden Lösungsvektor in `X`; und `work`, der reziproke Pivot-Wachstumsfaktor.
