```
remote_do(f, id::Integer, args...; kwargs...) -> nothing
```

在工作节点 `id` 上异步执行 `f`。与 [`remotecall`](@ref) 不同，它不存储计算结果，也没有等待其完成的方法。

成功的调用表示请求已被接受在远程节点上执行。

虽然对同一工作节点的连续 `remotecall` 是按调用顺序序列化的，但在远程工作节点上的执行顺序是未确定的。例如，`remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2)` 将序列化对 `f1` 的调用，随后是 `f2` 和 `f3`。然而，并不能保证 `f1` 在工作节点 2 上的执行会在 `f3` 之前。

`f` 抛出的任何异常都会在远程工作节点的 [`stderr`](@ref) 上打印。

关键字参数（如果有的话）会传递给 `f`。
