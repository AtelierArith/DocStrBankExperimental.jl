```
@simd
```

`@simd for` 루프에서 반복되는 객체는 일차원 범위여야 합니다. `@simd`를 사용함으로써 루프의 여러 속성을 주장하는 것입니다:

  * 반복을 임의의 순서나 겹치는 순서로 실행하는 것이 안전하며, 축소 변수에 대한 특별한 고려가 필요합니다.
  * 축소 변수에 대한 부동 소수점 연산은 재배치되거나 축약될 수 있으며, 이는 `@simd` 없이와는 다른 결과를 초래할 수 있습니다.

많은 경우, Julia는 `@simd` 없이도 내부 for 루프를 자동으로 벡터화할 수 있습니다. `@simd`를 사용하면 컴파일러가 더 많은 상황에서 가능하도록 약간의 여유를 제공합니다. 어떤 경우든, 내부 루프는 벡터화를 허용하기 위해 다음과 같은 속성을 가져야 합니다:

  * 루프는 가장 안쪽 루프여야 합니다.
  * 루프 본문은 직선 코드여야 합니다. 따라서, 모든 배열 접근에 대해 현재 [`@inbounds`](@ref)가 필요합니다. 컴파일러는 때때로 짧은 `&&`, `||`, 및 `?:` 표현식을 모든 피연산자를 무조건적으로 평가하는 것이 안전할 경우 직선 코드로 변환할 수 있습니다. 안전하다면 루프에서 `?:` 대신 [`ifelse`](@ref) 함수를 사용하는 것을 고려하세요.
  * 접근은 보폭 패턴을 가져야 하며 "모으기" (무작위 인덱스 읽기)나 "흩뿌리기" (무작위 인덱스 쓰기)가 될 수 없습니다.
  * 보폭은 단위 보폭이어야 합니다.

!!! note
    기본적으로 `@simd`는 루프가 루프에 의해 전달되는 메모리 의존성이 완전히 자유롭다는 것을 주장하지 않으며, 이는 일반 코드에서 쉽게 위반될 수 있는 가정입니다. 비일반 코드를 작성하는 경우, `@simd ivdep for ... end`를 사용하여 다음을 주장할 수 있습니다:


  * 루프에 의해 전달되는 메모리 의존성이 존재하지 않습니다.
  * 어떤 반복도 이전 반복이 진행되기를 기다리지 않습니다.
