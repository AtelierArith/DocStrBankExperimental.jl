```
merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated}) -> analysis, preference
```

Führen Sie eine Analyse der Branches durch, auf die durch die annotierten Branch-Spitzen `anns` verwiesen wird, und bestimmen Sie, unter welchen Umständen sie zusammengeführt werden können. Wenn beispielsweise `anns[1]` einfach ein Vorfahre von `anns[2]` ist, wird `merge_analysis` berichten, dass ein Fast-Forward-Merge möglich ist.

Geben Sie zwei Ausgaben zurück, `analysis` und `preference`. `analysis` hat mehrere mögliche Werte:     * `MERGE_ANALYSIS_NONE`: Es ist nicht möglich, die Elemente von `anns` zusammenzuführen.     * `MERGE_ANALYSIS_NORMAL`: ein regulärer Merge, wenn HEAD und die Commits, die der Benutzer zusammenführen möchte, alle von einem gemeinsamen Vorfahren abgewichen sind. In diesem Fall müssen die Änderungen gelöst werden und Konflikte können auftreten.     * `MERGE_ANALYSIS_UP_TO_DATE`: Alle Eingabekommit, die der Benutzer zusammenführen möchte, können von HEAD erreicht werden, sodass kein Merge durchgeführt werden muss.     * `MERGE_ANALYSIS_FASTFORWARD`: Das Eingabekommit ist ein Nachkomme von HEAD, sodass kein Merge durchgeführt werden muss - stattdessen kann der Benutzer einfach das Eingabekommit(s) auschecken.     * `MERGE_ANALYSIS_UNBORN`: Der HEAD des Repositories verweist auf ein Commit, das nicht existiert. Es ist nicht möglich, zusammenzuführen, aber es kann möglich sein, die Eingabekommit auszuchecken. `preference` hat ebenfalls mehrere mögliche Werte:     * `MERGE_PREFERENCE_NONE`: Der Benutzer hat keine Präferenz.     * `MERGE_PREFERENCE_NO_FASTFORWARD`: Keine Fast-Forward-Merges zulassen.     * `MERGE_PREFERENCE_FASTFORWARD_ONLY`: Nur Fast-Forward-Merges zulassen und keine andere Art (die Konflikte einführen könnte). `preference` kann durch die Repository- oder globale Git-Konfiguration gesteuert werden.
