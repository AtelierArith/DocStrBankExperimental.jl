```
find_zeros(f, a, [b]; [no_pts=12, k=8, naive=false, xatol, xrtol, atol, rtol])
```

関数 `f` のゼロを区間 `[a,b]` でヒューリスティックアルゴリズムを用いて検索します。

  * `f`: 関数または呼び出し可能なオブジェクト
  * `a`, `b`: `b` が指定されている場合、区間 $[a,b]$ が使用されます。`a` のみが指定されている場合、それは `extrema` に渡され、検索する区間が定義されます。どちらの端点もゼロでないと仮定されます。

ソートされた順序でゼロのベクトルを返します。場合によっては空のベクトルになることもあります。

# 拡張ヘルプ

# 例

```jldoctest find_zeros
julia> using Roots

julia> find_zeros(x -> exp(x) - x^4, -5, 20)        # よく間隔を空けたゼロ
3-element Vector{Float64}:
 -0.8155534188089606
  1.4296118247255556
  8.613169456441398

julia> find_zeros(x -> sin(x^2) + cos(x)^2, 0, 2pi)  # 多くのゼロ
12-element Vector{Float64}:
 1.78518032659534
 2.391345462376604
 3.2852368649448853
 3.3625557095737544
 4.016412952618305
 4.325091924521049
 4.68952781386834
 5.00494459113514
 5.35145266881871
 5.552319796014526
 5.974560835055425
 6.039177477770888

julia> find_zeros(x -> cos(x) + cos(2x), (0, 4pi))    # 単純なゼロと非単純なゼロの混合
6-element Vector{Float64}:
  1.0471975511965976
  3.141592653589943
  5.235987755982988
  7.330382858376184
  9.424777960769228
 11.519173063162574

julia> f(x) = (x-0.5) * (x-0.5001) * (x-1)          # 近くのゼロ
f (generic function with 1 method)

julia> find_zeros(f, 0, 2)
3-element Vector{Float64}:
 0.5
 0.5001
 1.0

julia> f(x) = (x-0.5) * (x-0.5001) * (x-4) * (x-4.001) * (x-4.2)
f (generic function with 1 method)

julia> find_zeros(f, 0, 10)
3-element Vector{Float64}:
 0.5
 0.5001
 4.2

julia> f(x) = (x-0.5)^2 * (x-0.5001)^3 * (x-4) * (x-4.001) * (x-4.2)^2  # 特定が難しい
f (generic function with 1 method)

julia> find_zeros(f, 0, 10, no_pts=21)                # デフォルトでは難しすぎる
5-element Vector{Float64}:
 0.49999999999999994
 0.5001
 4.0
 4.001
 4.200000000000001
```

!!! note
    ゼロの数が過小報告される可能性のあるいくつかのケース：

      * 初期区間 `(a,b)` が広すぎる場合
      * ゼロが非常に近くにある場合
      * 関数が平坦な場合、例えば `x->0`。


---

基本的なアルゴリズムは、端点の間でゼロをチェックし、その後区間 `(a,b)` を `no_pts-1` の部分区間に分割し、二分法または導関数を使用しない方法でゼロを探します。ブレッキング区間をチェックするのは比較的安価であり、二分法は収束が保証されているため、各区間には `k` 組の中間点がブレッキングのためにチェックされます。

ゼロが見つかった場合、アルゴリズムはこれらを使用して `(a,b)` を部分区間に分割します。各部分区間は、端点がゼロでないように縮小され、プロセスは部分区間で繰り返されます。初期区間が大きすぎる場合、ゼロを単純にスキャンすることは無駄になる可能性があり、ゼロは報告されません。近くにゼロがある場合、区間の縮小がそれらを飛び越える可能性がありますが、例に見られるように、近くの根は正しく特定できます。ただし、本当に近い点や非常に平坦な関数の場合は、`no_pts` を増やすと役立つことがあります。

許容値は区間を縮小するために使用されますが、検索内でゼロを見つけるためには使用されません。検索の場合、二分法は指定された許容値なしで収束が保証されています。導関数を使用しない検索の場合、`Order0` メソッドの修正が使用され、最悪の場合 `|f(x)| <= 8*eps(x)` を比較してゼロを特定します。アルゴリズムは、浮動小数点の近似により、ゼロの値を複数特定する可能性があります。潜在的なゼロのペアが `isapprox(a,b,atol=sqrt(xatol), rtol=sqrt(xrtol))` を満たす場合、それらは統合されます。

アルゴリズムは多くの関数呼び出しを行う可能性があります。区間内でゼロが見つかった場合、単純な検索が各部分区間で実行されます。ただし、関数呼び出しを減らすために、いくつかのゼロを見逃す可能性が高まりますが、適応的な性質は `naive=true` 引数を使用するか、ポイントの数を減らすことでスキップできます。

このアルゴリズムは、@djsegal による [PR](https://github.com/JuliaMath/Roots.jl/pull/113) のものに由来しています。

!!! note
    `IntervalRootFinding` パッケージは、このヒューリスティックなものに対する厳密な代替手段を提供します。このパッケージは区間算術を使用しているため、`f` の下での区間の画像のサイズの上限を計算できます。この画像に `0` が含まれている場合、ゼロを探すことができます。一方、二分法は、2つの端点が異なる符号を持つ場合にのみゼロを探すため、潜在的なゼロに対する条件ははるかに厳格です。


!!! note "`IntervalRootFinding` 拡張"
    バージョン `1.9` から、`IntervalRootFinding` パッケージがロードされると、`find_zeros` 関数は `IntervalRootFinding.roots` を呼び出して隔離ブレッキングを見つけ、可能な場合は `find_zero` を呼び出します。**もし**区間が `-1..1` のように `Interval` オブジェクトとして指定されている場合です。


例えば、この関数（`@truculentmath` による）は特に厄介で、すべての浮動小数点数で正ですが、2つのゼロを持っています（垂直漸近線 `15//11` は隣接する浮動小数点値の間でのみ負です）：

```
julia> using IntervalArithmetic, IntervalRootFinding, Roots

julia> g(x) = x^2 + 1 +log(abs( 11*x-15 ))/99
g (generic function with 1 method)

julia> find_zeros(g, -3, 3)
Float64[]

julia> IntervalRootFinding.roots(g, -3..3, IntervalRootFinding.Bisection)
1-element Vector{Root{Interval{Float64}}}:
 Root([1.36363, 1.36364], :unknown)
```

極端でない使用法は次のようになります。ここで `unique` は二分法が有用である可能性を示し、実際に `find_zeros` はこれらの値を特定します：

```
julia> g(x) = exp(x) - x^5
g (generic function with 1 method)

julia> rts = IntervalRootFinding.roots(g, -20..20)
2-element Vector{Root{Interval{Float64}}}:
 Root([12.7132, 12.7133], :unique)
 Root([1.29585, 1.29586], :unique)

julia> find_zeros(g, -20, 20)
2-element Vector{Float64}:
  1.2958555090953687
 12.713206788867632
```
