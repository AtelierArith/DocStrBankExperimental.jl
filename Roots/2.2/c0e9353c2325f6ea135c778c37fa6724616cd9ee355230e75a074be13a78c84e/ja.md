```
secant_method(f, xs; [atol=0.0, rtol=8eps(), maxevals=1000])
```

`f(x) = 0` を解くためにセカント法を実行します。

セカント法は反復法で、更新ステップは `b - fb/m` で与えられ、ここで `m` は `(a,fa)` と `(b,fb)` の間のセカント線の傾きです。

初期値は、`(x₀, x₁)` または `[x₀, x₁]` のペアとして指定することも、単一の値 `x₁` として指定することもでき、その場合は `x₀` の値が選ばれます。

アルゴリズムは `abs(fm) <= max(atol, abs(m) * rtol)` のときに `m` を返します。これが `maxevals` ステップの前に発生しない場合やアルゴリズムが問題に遭遇した場合、`NaN` の値が返されます。ステップが多すぎる場合、現在の値が隣接する浮動小数点値の符号変化を持つかどうかがチェックされます。

`find_zero` の `Order1` メソッドもセカント法を実装しています。こちらはセットアップコストが少ないため、若干速くなるはずです。

例:

```julia
Roots.secant_method(sin, (3,4))
Roots.secant_method(x -> x^5 -x - 1, 1.1)
```

!!! note "特化"
    この関数は関数 `f` に特化するため、初回の呼び出しは `Order1()` メソッドへの呼び出しよりも時間がかかる場合がありますが、その後の呼び出しははるかに速くなります。 `FunctionWrappers.jl` を使用することで、初回の呼び出しもその後の呼び出しと同じくらい速くすることができます。

