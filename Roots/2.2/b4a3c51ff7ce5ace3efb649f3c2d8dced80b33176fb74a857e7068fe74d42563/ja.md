```
find_zero(f, x0, M, [N::AbstractBracketingMethod], [p=nothing]; kwargs...)
```

単変数関数のゼロを見つけるためのいくつかのメソッドへのインターフェース、例えば $f(x)=0$ を解くこと。

# 引数

## 位置引数

  * `f`: 関数（単変数または `f(x,p)` で `p` がパラメータを保持）
  * `x0`: 初期条件（値、初期値、またはブレッキング区間）
  * `M`: ソルバーを指定する `AbstractUnivariateZeroMethod`
  * `N`: 指定された場合、ハイブリッドメソッドを作成するブレッキングメソッド
  * `p`: `f` にパラメータを指定するため。キーワードとしても使用できますが、位置引数はブロードキャスティングに便利です。

## キーワード引数

  * `xatol`, `xrtol`: `xₙ₊₁ ≈ xₙ` を決定するための絶対および相対許容誤差
  * `atol`, `rtol`: `f(xₙ) ≈ 0` を決定するための絶対および相対許容誤差
  * `maxiters`: アルゴリズムが取ることができる最大反復回数を指定します。
  * `verbose::Bool`: アルゴリズムの詳細を表示するかどうかを指定します
  * `tracks`: `Tracks` オブジェクトの指定を可能にします

# 拡張ヘルプ

# 初期開始値

ほとんどのメソッドでは、`x0` は反復手続きにおける初期値を示すスカラー値です。（セカント法は初期値を指定するタプルを持つことができます。）値は `Number` のサブタイプであり、`float`、`real`、および `oneunit` のメソッドが定義されている必要があります。

ブレッキング区間の場合、`x0` はタプル、ベクター、または `extrema` が定義された任意の反復可能なオブジェクトを使用して指定されます。ブレッキング区間 $[a,b]$ は、$f(a)$ と $f(b)$ が異なる符号を持つ場合です。

# 戻り値

アルゴリズムが成功した場合、特定された近似根が返されます。アルゴリズムが失敗した場合は `ConvergenceFailed` エラーがスローされます。失敗した場合の代替形式 `solve(ZeroProblem(f,x0), M)` は `NaN` を返します。

# メソッドの指定

使用するアルゴリズムを示すためにメソッドが指定されます：

  * ブレッキングが指定されるメソッドがあります: [`Bisection`](@ref), [`A42`](@ref), [`AlefeldPotraShi`](@ref), [`Roots.Brent`](@ref) など。ブレッキングは基本的な浮動小数点型のデフォルトですが、`A42` は一般的にはるかに少ない反復を必要とします。
  * 複数の導関数を使用しないメソッドがあります: cf. [`Order0`](@ref), [`Order1`](@ref)（または [`Roots.Secant`](@ref)）、[`Order2`](@ref)（または [`Steffensen`](@ref)）、[`Order5`](@ref)、[`Order8`](@ref)、および [`Order16`](@ref) で、数は収束の次数を示します。
  * 導関数の指定が必要な古典的なメソッドがあります: [`Roots.Newton`](@ref), [`Roots.Halley`](@ref), [`Roots.Schroder`](@ref) など。
  * 重複を持つ問題に対して意図されたメソッドには [`Roots.Order1B`](@ref), [`Roots.Order2B`](@ref), および異なる `X` のための `Roots.ThukralXB` が含まれます。
  * 異なる `S` と `D` のためのファミリー [`Roots.LithBoonkkampIJzerman{S,D}`](@ref) は、線形多段法根探索器を使用します。`(2,0)` メソッドはセカント法で、`(1,1)` はニュートン法です。

詳細については、各メソッドのヘルプページを参照してください（例: `?Order1`）。非エクスポートメソッドは、`?Roots.Schroder` のようにモジュール名で修飾する必要があります。

メソッドが指定されていない場合、デフォルトのメソッドは `x0` に依存します：

  * `x0` がスカラーの場合、デフォルトはより堅牢な `Order0` メソッドです。
  * `x0` がタプル、ベクター、または `extrema` が定義された反復可能なオブジェクトで *ブレッキング* 区間を示す場合、`Float64`、`Float32` または `Float16` 型には `Bisection` メソッドが使用されます。それ以外の場合は `A42` メソッドが使用されます。

デフォルトのメソッドは堅牢であるように選ばれていますが、他のいくつかのメソッドほど効率的ではないかもしれません。

# 関数の指定

関数は最初の引数として渡されます。

導関数を1つ以上使用する数少ないメソッド（`Newton`、`Halley`、`Schroder`、`LithBoonkkampIJzerman(S,D)` など）では、関数のタプルが使用されます。古典的なアルゴリズムでは、`(f(x), f(x)/f'(x), [f'(x)/f''(x)])` を返す関数が使用される場合があります。

# オプション引数（許容誤差、評価の制限、トレース）

  * `xatol` - `x` 値の絶対許容誤差。
  * `xrtol` - `x` 値の相対許容誤差。
  * `atol`  - `f(x)` 値の絶対許容誤差。
  * `rtol`  - `f(x)` 値の相対許容誤差。
  * `maxiters`   - 最大反復回数の制限。
  * `strict` - `false`（デフォルト）の場合、アルゴリズムが停止するとき、可能なゼロは緩い許容誤差でチェックされます。
  * `verbose` - `true` の場合、成功した完了時にアルゴリズムのトレースが表示されます。このトレースを保存するために内部の [`Roots.Tracks`](@ref) オブジェクトを参照してください。

収束に関する詳細は `Roots.assess_convergence` のヘルプ文字列を参照してください。デフォルトの許容誤差の詳細は `Roots.default_tolerances(method)` のヘルプページを参照してください。

一般に、浮動小数点数を使用する場合、収束は絶対的な声明として理解されるべきです。数学的に `α` が答えであり、`xstar` が浮動小数点の実現である場合、`f(xstar) - f(α)  ≈ xstar ⋅  f'(α) ⋅ eps(α)` となる可能性があるため、許容誤差の役割を理解し、時には指定する必要があります。

`Bisection` メソッドでは、`Float64` 値に対して収束が保証されているため、許容誤差はデフォルトで $0$ に設定されています。

メソッド指定の後にブレッキングメソッドが渡されると、アルゴリズム中にブレッキングが特定されるたびに、メソッドはゼロを特定するためにブレッキングメソッドに切り替わります。（ブレッキングメソッドは数学的に収束が保証されており、非ブレッキングメソッドは収束する場合としない場合があります。）これは `Order0` がデフォルトで行うことで、初期のセカント法がブレッキングが遭遇した場合に `AlefeldPotraShi` メソッドに切り替わります。

注意: メソッドの順序は命名規則に示されています。スキームは順序 `r` であり、`eᵢ = xᵢ - α` の場合、`eᵢ₊₁ = C⋅eᵢʳ` です。誤差 `eᵢ` が十分に小さい場合、実質的に誤差は各ステップで `r` 倍の先頭ゼロを得ることになります。しかし、誤差が小さくない場合、これは当てはまりません。良い初期推測がない場合、高次メソッドは遅く収束するか、全く収束しない可能性があります。`OrderN` メソッドには、メソッドを忠実に実装する代わりに、収束のためのより広い範囲を確保するためにいくつかのヒューリスティックが使用されていますが、それらは非エクスポートメソッドを通じて利用可能です。

# 例:

デフォルトメソッド。

```jldoctest find_zero
julia> using Roots

julia> find_zero(sin, 3)  # Order0() を使用
3.141592653589793

julia> find_zero(sin, (3,4)) # Bisection() を使用
3.141592653589793
```

メソッドの指定、

```jldoctest find_zero
julia> find_zero(sin, (3,4), Order1())            # セカント法のために2つの開始点を指定できます
3.141592653589793

julia> find_zero(sin, 3.0, Order2())              # ステッフェンセン法を使用
3.1415926535897936

julia> find_zero(sin, big(3.0), Order16())        # 高速収束
3.141592653589793238462643383279502884197169399375105820974944592307816406286198

julia> find_zero(sin, (3, 4), A42())              # この場合、Bisection() よりも関数呼び出しが少ない
3.141592653589793

julia> find_zero(sin, (3, 4), FalsePosition(8))   # 偽位置法の12の可能なアルゴリズムの1つ
3.141592653589793

julia> find_zero((sin,cos), 3.0, Roots.Newton())  # ニュートン法を使用
3.141592653589793

julia> find_zero((sin, cos, x->-sin(x)), 3.0, Roots.Halley())  # ハレー法を使用
3.141592653589793
```

許容誤差の変更。

```jldoctest find_zero
julia> fn = x -> (2x*cos(x) + x^2 - 3)^10/(x^2 + 1);

julia> x0, xstar = 3.0,  2.9947567209477;

julia> fn(find_zero(fn, x0, Order2())) <= 1e-14  # f(xₙ) ≈ 0, しかし Δxₙ は大きくなる可能性があります
true

julia> find_zero(fn, x0, Order2(), atol=0.0, rtol=0.0) # エラー: x_n ≉ x_{n-1}; ただし f(x_n) ≈ 0
ERROR: Roots.ConvergenceFailed("アルゴリズムが収束しませんでした")
[...]

julia> fn = x -> (sin(x)*cos(x) - x^3 + 1)^9;

julia> x0, xstar = 1.0,  1.112243913023029;

julia> isapprox(find_zero(fn, x0, Order2()), xstar; atol=1e-4)
true

julia> find_zero(fn, x0, Order2(), maxiters=3)    # 収束するためにもっとステップが必要
ERROR: Roots.ConvergenceFailed("アルゴリズムが収束しませんでした")
[...]
```

# トレース

`verbose=true` を渡すと、アルゴリズムのステップの詳細が表示されます。`tracks` 引数は、アルゴリズムで使用される `x` と `f(x)` の値を記録するために [`Roots.Tracks`](@ref) オブジェクトを渡すことを可能にします。

!!! note
    代替インターフェースについては [`solve!`](@ref) と [`ZeroProblem`](@ref) を参照してください。


```
