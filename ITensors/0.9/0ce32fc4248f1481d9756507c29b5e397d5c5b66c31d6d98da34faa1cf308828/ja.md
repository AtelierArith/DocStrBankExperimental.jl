```
apply(A::ITensor, B::ITensor)
(A::ITensor)(B::ITensor)
product(A::ITensor, B::ITensor)
```

ITensor `A` と ITensor `B` の積を取得します。これは大まかに言えば、インデックス構造に応じて行列-行列積、行列-ベクトル積、またはベクトル-行列積です。

主に3つのモードがあります：

1. 行列-行列積。この場合、ITensor `A` と `B` は、プライムインデックスと非プライムインデックスのペアを持つ共有インデックスを持っています。次に、`A` と `B` は、非プライムインデックスからプライムインデックスへの行列として扱われ、掛け算され、プライムインデックスと非プライムインデックスの同じペアを持つ ITensor `C` が得られます。例えば：

```
s1'-<-----<-s1            s1'-<-----<-s1   s1'-<-----<-s1
      |C|      = product(       |A|              |B|      )
s2'-<-----<-s2            s2'-<-----<-s2 , s2'-<-----<-s2
```

本質的に、これは `C = mapprime(A', B, 2 => 1)` として実装されています。`A` と `B` の間で共有されていないダングリングインデックスがある場合は、「バッチ」行列乗算が行われます。すなわち：

```
       j                         j
       |                         |
s1'-<-----<-s1            s1'-<-----<-s1   s1'-<-----<-s1
      |C|      = product(       |A|              |B|      )
s2'-<-----<-s2            s2'-<-----<-s2 , s2'-<-----<-s2
```

さらに、共有されているダングリングインデックスがある場合、それらは合計されます：

```
                                    j                j
                                    |                |
s1'-<-----<-s1               s1'-<-----<-s1   s1'-<-----<-s1
      |C|      = Σⱼ product(       |A|              |B|      )
s2'-<-----<-s2               s2'-<-----<-s2 , s2'-<-----<-s2
```

ここで、合計は明示的な for ループとしてではなく、単一のテンソル収縮の一部として行われます。

2. 行列-ベクトル積。この場合、ITensor `A` はプライムインデックスと非プライムインデックスのペアを持ち、ITensor `B` は `A` と共有される非プライムインデックスを持っています。次に、`A` と `B` は行列-ベクトル積として掛け算され、結果 `C` は非プライムインデックスを持ちます。例えば：

```
s1-<----            s1'-<-----<-s1   s1-<----
     |C| = product(       |A|             |B| )
s2-<----            s2'-<-----<-s2 , s2-<----
```

再び、上記の行列-行列積のように、ダングリングインデックスを持って「バッチ」行列-ベクトル積を行ったり、行列-ベクトル積のバッチを合計したりすることができます。

3. ベクトル-行列積。この場合、ITensor `B` はプライムインデックスと非プライムインデックスのペアを持ち、ITensor `A` は `B` と共有される非プライムインデックスを持っています。次に、`B` と `A` は行列-ベクトル積として掛け算され、結果 `C` は非プライムインデックスを持ちます。例えば：

```
---<-s1            ----<-s1   s1'-<-----<-s1
|C|     = product( |A|              |B|      )
---<-s2            ----<-s2 , s2'-<-----<-s2
```

再び、上記の行列-行列積のように、ダングリングインデックスを持って「バッチ」ベクトル-行列積を行ったり、ベクトル-行列積のバッチを合計したりすることができます。

4. ベクトル-ベクトル積。この場合、ITensor `A` と `B` は非プライムインデックスを共有します。次に、`B` と `A` はベクトル-ベクトル積として掛け算され、結果 `C` はスカラー ITensor になります。例えば：

```
---            ----<-s1   s1-<----
|C| = product( |A|             |B| )
---            ----<-s2 , s2-<----
```

再び、上記の行列-行列積のように、ダングリングインデックスを持って「バッチ」ベクトル-ベクトル積を行ったり、ベクトル-ベクトル積のバッチを合計したりすることができます。
