```
eigen(A::ITensor[, Linds, Rinds]; <keyword arguments>)
```

ITensor `A` の固有分解で、提供された「左インデックス」`Linds` を行インデックスとして、残りの「右インデックス」`Rinds` を列インデックスとして扱うことによって計算されます（テンソルの行列化）。

インデックスが提供されていない場合、プライムインデックスと非プライムインデックスのペアが検索され、`Linds` はプライムインデックスとして、`Rinds` は非プライムインデックスとして扱われます。

返される引数は、固有値 `D` と固有ベクトル `U` で、これらはテンソルとして返され、`A * U ∼ U * D` となります（より正確には、インデックスの適切な置き換えを考慮すると、ほぼ等しいです。詳細は例を参照してください）。

`eigen` が切り捨てを行うかどうかは、提供されたキーワード引数に依存します。切り捨ては、正定値半行列に対してのみ明確に定義されていることに注意してください。

# 引数

```
- `maxdim::Int`: 保持する最大の特異値の数。
- `mindim::Int`: 保持する最小の特異値の数。
- `cutoff::Float64`: 固有値の望ましい切り捨て誤差を設定します。
   デフォルトでは、最小の固有値の二乗の合計として定義されます。
   現在、切り捨ては正定値半行列の固有スペクトルに対してのみ明確に定義されています。
- `ishermitian::Bool = false`: 行列がエルミートであるかどうかを指定します。
   この場合、特化した対角化ルーチンが使用され、実数の固有値が返されることが保証されます。
- `plev::Int = 0`: `D` のインデックスのプライムレベルを設定します。デフォルトのプライムレベルは変更される可能性があります。
- `leftplev::Int = plev`: `D` に固有のインデックスのプライムレベルを設定します。
   デフォルトのプライムレベルは変更される可能性があります。
- `rightplev::Int = leftplev+1`: `D` と `U` で共有されるインデックスのプライムレベルを設定します。
   デフォルトのタグは変更される可能性があります。
- `tags::String = "Link,eigen"`: `D` のインデックスのタグを設定します。
   デフォルトのタグは変更される可能性があります。
- `lefttags::String = tags`: `D` に固有のインデックスのタグを設定します。
   デフォルトのタグは変更される可能性があります。
- `righttags::String = tags`: `D` と `U` で共有されるインデックスのタグを設定します。
   デフォルトのタグは変更される可能性があります。
- `use_absolute_cutoff::Bool = false`: `cutoff` 値未満のすべての確率重みを破棄するかどうかを設定します。
   破棄された重みの合計ではなく。
- `use_relative_cutoff::Bool = true`: 切り捨てのために特異値を正規化するかどうかを設定します。
```

# 例

```julia
i, j, k, l = Index(2, "i"), Index(2, "j"), Index(2, "k"), Index(2, "l")
A = random_itensor(i, j, k, l)
Linds = (i, k)
Rinds = (j, l)
D, U = eigen(A, Linds, Rinds)
dl, dr = uniqueind(D, U), commonind(D, U)
Ul = replaceinds(U, (Rinds..., dr) => (Linds..., dl))
A * U ≈ Ul * D # true
```

参照: [`svd`](@ref), [`factorize`](@ref)
