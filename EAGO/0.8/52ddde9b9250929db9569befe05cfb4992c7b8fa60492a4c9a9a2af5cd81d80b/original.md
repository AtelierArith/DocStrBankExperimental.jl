```julia
mutable struct EAGOParameters
```

Storage for parameters that do not change during a global solve.

  * `presolve_scrubber_flag::Bool`: Should EAGO attempt to remove type-assert issues for user-defined functions (default = false)
  * `presolve_to_JuMP_flag::Bool`: Create and use DAG representations of user-defined functions (default = false)
  * `presolve_flatten_flag::Bool`: Rerrange the DAG using registered transformations (default = false)
  * `conic_convert_quadratic::Bool`: Attempt to bridge convex constraint to second-order cone (default = false)
  * `log_on::Bool`: Turn logging on; record global bounds, node count, and run time. Additional      options are available for recording information specific to subproblems (default = false)
  * `log_subproblem_info::Bool`: Turn on logging of times and feasibility of subproblems (default = false)
  * `log_interval::Int64`: Log data every `log_interval` iterations (default = 1)
  * `verbosity::Int64`: The amount of information that should be printed to console while solving.     Values range from 0 - 4: 0 is silent, 1 shows iteration summary statistics     only, 2-4 show varying degrees of detail about calculations within each     iteration (default = 1)
  * `output_iterations::Int64`: Display summary of iteration to console every `output_iterations` (default = 1000)
  * `header_iterations::Int64`: Display header for summary to console every `output_iterations` (default = 100000)
  * `branch_cvx_factor::Float64`: Convex coefficient used to select branch point. Branch point is given by     `branch_cvx_factor*xmid + (1-branch_cvx_factor)*xsol` (default = 0.25)
  * `branch_offset::Float64`: Minimum distance from bound to have branch point, normalized by width of     dimension to branch on (default = 0.15)
  * `branch_pseudocost_on::Bool`: Indicate that pseudocost branching should be used (default = false)
  * `branch_variable::Vector{Bool}`: Variables to branch on (default is all nonlinear)
  * `branch_max_repetitions::Int64`: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Number of times to repeat node     processing prior to branching (default = 4)
  * `branch_repetition_tol::Float64`: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Volume ratio tolerance required     to repeat processing the current node (default = 0.9)
  * `node_limit::Int64`: Maximum number of nodes (default = 1E7)
  * `time_limit::Float64`: Maximum CPU time in seconds (default = 3600)
  * `iteration_limit::Int64`: Maximum number of iterations (default 1E9)
  * `absolute_tolerance::Float64`: Absolute tolerance for termination (default = 1E-3)
  * `relative_tolerance::Float64`: Relative tolerance for termination (default = 1E-3)
  * `absolute_constraint_feas_tolerance::Float64`: Absolute constraint feasibility tolerance (default = 1E-8)
  * `cp_depth::Int64`: Depth in B&B tree above which constraint propagation should be disabled (default = 0)
  * `cp_repetitions::Int64`: Number of times to repeat forward-reverse pass routine (default = 0)
  * `cp_tolerance::Float64`: Disable constraint propagation if the ratio of new node volume to beginning node volume exceeds     this number (default = 0.99)
  * `cp_interval_only::Bool`: Use only valid interval bounds during constraint propagation (default = false)
  * `obbt_depth::Int64`: Depth in B&B tree above which OBBT should be disabled (default = 6)
  * `obbt_repetitions::Int64`: Number of repetitions of OBBT to perform in preprocessing (default = 3)
  * `obbt_aggressive_on::Bool`: Turn on aggresive OBBT (default = true)
  * `obbt_aggressive_max_iteration::Int64`: Maximum iteration to perform aggresive OBBT (default = 2)
  * `obbt_aggressive_min_dimension::Int64`: Minimum dimension to perform aggresive OBBT (default = 2)
  * `obbt_tolerance::Float64`: Tolerance to consider bounds equal (default = 1E-10)
  * `fbbt_lp_depth::Int64`: Depth in B&B tree above which linear FBBT should be disabled (default = 1000)
  * `fbbt_lp_repetitions::Int64`: Number of repetitions of linear FBBT to perform in preprocessing (default = 3)
  * `dbbt_depth::Int64`: Depth in B&B tree above which duality-based bound tightening should be disabled (default = 1E10)
  * `dbbt_tolerance::Float64`: New bound is considered equal to the prior bound if within dbbt_tolerance (default = 1E-8)
  * `relax_tag::McCormick.RelaxTag`: RelaxTag used to specify type of McCormick operator (default = NS())
  * `subgrad_tighten::Bool`: Perform tightening of interval bounds using subgradients at each factor in     each nonlinear tape during a forward pass (default = true)
  * `reverse_subgrad_tighten::Bool`: Perform tightening of interval bounds using subgradients at each factor in     each nonlinear tape during a reverse pass (default = false)
  * `subgrad_tol::Float64`: Outer-round computed subgradient bounds by this amount (default = 1E-10)
  * `mul_relax_style::Int64`: Select the type of relaxation to use for the bilinear term (multiplication): 0 corresponds to      a standard McCormick arithmetic approach. Settings 1-3 augment the standard McCormick relaxation      with implied apriori relaxations: (1) corresponds to a subgradient-based apriori relaxation approach; (2)      corresponds to an affine arithmetic-based apriori approach; and (3) corresponds to a enumerative apriori      relaxation-based approach (default = 0)
  * `cut_min_iterations::Int64`: Minimum number of cuts at each node to attempt (unsafe cuts not necessarily added) (default = 2)
  * `cut_max_iterations::Int64`: Maximum number of cuts at each node to attempt (default = 8)
  * `cut_tolerance_abs::Float64`: Absolute tolerance checked for continuing cut (default = 1E-6)
  * `cut_tolerance_rel::Float64`: Relative tolerance checked for continuing cut (default = 1E-3)
  * `cut_safe_on::Bool`: Use tolerances to determine safe cuts in a Khajavirad 2018 manner (default = true)
  * `cut_safe_l::Float64`: Lower tolerance for safe-lp cut, Khajavirad 2018 (default = 1E-7)
  * `cut_safe_u::Float64`: Upper tolerance for safe-lp cut, Khajavirad 2018 (default = 1E7)
  * `cut_safe_b::Float64`: Constant tolerance for safe-lp cut, Khajavirad 2018 (default = 1E9)
  * `upper_bounding_depth::Int64`: Solve upper problem for every node with depth less than `upper_bounding_depth`,     and otherwise solve upper problems with a probability of `(1/2)^(depth-upper_bounding_depth)`     (default = 8)
  * `domain_violation_guard_on::Bool`: (Unused) Protect against domain violation (default = false)
  * `domain_violation_Ïµ::Float64`: (Unused) Amount about a domain violation to ignore when propagating bounds (default = 1E-9)
  * `user_solver_config::Bool`: If true, EAGO forgoes its default configuration process for subsolvers (default = false)
  * `integer_abs_tol::Float64`: Absolute tolerance used to check for integrality of decision variables (default = 1E-9)
  * `integer_rel_tol::Float64`: Relative tolerance used to check for integrality of decision variables (default = 1E-9)
  * `force_global_solve::Bool`: Ignore EAGO's ability to parse problem types and force it to run global optimization (default = false)
  * `unbounded_check::Bool`: Check that all branching variables have finite bounds and set them to +/- 1E10 if not (default = true)
