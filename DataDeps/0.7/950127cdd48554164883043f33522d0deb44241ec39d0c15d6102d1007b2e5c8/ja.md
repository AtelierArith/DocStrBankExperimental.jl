```
DataDep(
    name::String,
    message::String,
    remote_path::Union{String,Vector{String}...},
    [hash::Union{String,Vector{String}...},]; # オプション、提供されない場合は生成されます
    # キーワード引数（オプション）:
    fetch_method=fetch_default # (remote_filepath, local_directory_path)->local_filepath
    post_fetch_method=identity # (local_filepath)->Any
)
```

### 必須フィールド

  * `name`: このデータ依存関係を参照するために使用される名前

      * データ依存関係が保存されるフォルダ名に対応します。
      * スペースやWindowsファイル文字列で許可されている他の任意の文字を含むことができます（これはUnixファイル名の制限の厳密なサブセットです）。
  * `message`: ユーザーに表示されるメッセージで、ダウンロードするかどうかを尋ねられます

      * 通常、データの元のソースへのリンク、引用すべき論文などを提供するために使用されます。
  * `remote_path`: データを取得する場所

      * これは通常、文字列または文字列のベクター（またはベクターのベクター... 開発者向けのドキュメントの[再帰構造](@ref)を参照）です。

### オプションフィールド

  * `hash`: ダウンロードしたファイルが正しく取得されたかどうかを確認するために使用されます

      * 最も一般的な使用法は、ファイルのSHA256サムを16進数文字列として提供することです。
      * 提供されない場合、SHA256サムを含む警告メッセージが表示されます。これは、パッケージ開発者が外部ツールを使用せずにファイルのサムを計算するのを助けるためです。開発者向けのドキュメントの[アップロード前チェック](@ref)を使用して計算することもできます。
      * 異なるハッシュアルゴリズムを使用したい場合は、タプル `(hashfun, targethex)` を提供できます。`hashfun` は `IOStream` を受け取り、`Vector{UInt8}` を返す関数である必要があります。たとえば、[SHA.jl](https://github.com/staticfloat/SHA.jl) の関数、例えば `sha3_384`、`sha1_512` または [MD5.jl](https://github.com/oxinabox/MD5.jl) の `md5` などです。
      * 異なるハッシュアルゴリズムを使用したいが、サムがわからない場合は、`hashfun` のみを提供すると、警告メッセージが表示され、登録ブロックに追加すべき `(hashfun, targethex)` の正しいタプルが示されます。
      * チェックサムを提供したくない場合、データが変更される可能性があるため、型 `Any` を渡すと警告メッセージが抑制されます。（ただし、「データが動的な場合はどうなるか」についての上記の警告を参照してください）。
      * 各ファイルごとに1つのチェックサムのベクターを取ることができるか、単一のチェックサムを取ることができ、その場合はファイルごとのハッシュが `xor` されてターゲットハッシュが得られます。（開発者向けのドキュメントの[再帰構造](@ref)を参照）。
  * `fetch_method=fetch_default`: ファイルをダウンロードするために実行する関数

      * 関数は2つのパラメータ `(remote_filepath, local_directorypath)` を受け取り、ダウンロードされたファイルのローカルファイルパスを返す必要があります。
      * デフォルト（`fetch_default`）は、HTTP[S] URLを含む文字列や、`Base.basename` と `Base.download` をオーバーロードする任意の `remote_path` タイプを正しく処理できます。例：[`AWSS3.S3Path`](https://github.com/JuliaCloud/AWSS3.jl/)。
      * 各ファイルごとに1つのメソッドのベクターを取ることができるか、単一のメソッドを取ることができ、その場合はそのメソッドがすべてのファイルのダウンロードに使用されます。（開発者向けのドキュメントの[再帰構造](@ref)を参照）。
      * これをオーバーロードすることで、ダウンロードの方法を変更できます - すなわち、トランスポートプロトコル。
      * デフォルトは、認証なしでHTTP[/S]に適しています。これを変更すると、認証を追加したり、まったく異なるプロトコル（例：git、Googleドライブなど）を追加できます。
      * この関数は、ローカルファイルがどのように呼ばれるべきかを決定する責任もあります（これはプロトコルに依存します）。
  * `post_fetch_method`: ファイルがダウンロードされた後に実行する関数

      * 最初の引数としてローカルファイルパスを受け取る必要があります。何でも返すことができます。
      * デフォルトは何もしないことです。
      * そこから何をするかは自由ですが、最も可能性が高いのは、データディレクトリにファイルを抽出することです。
      * この目的のために、DataDeps.jl には、圧縮フォルダを抽出し、元のものを削除する `unpack` というコマンドが含まれています。
      * `post_fetch_method` はデータディレクトリ内から実行されることに注意する必要があります。

          * これは、現在の作業ディレクトリに書き込むだけの操作（`rm` や `mv` や ```run(`SOMECMD`))``` がそのまま機能することを意味します。
          * 自分の関数のためにデータディレクトリを取得するには `cwd()` を呼び出すことができます。（または `dirname(local_filepath)`）。
      * 各ファイルごとに1つのメソッドのベクターを取ることができるか、単一のメソッドを取ることができ、その場合はその同じメソッドがすべてのファイルに適用されます。（開発者向けのドキュメントの[再帰構造](@ref)を参照）。
      * これは、開発者向けのドキュメントの[アップロード前チェック](@ref)の一部として確認できます。
