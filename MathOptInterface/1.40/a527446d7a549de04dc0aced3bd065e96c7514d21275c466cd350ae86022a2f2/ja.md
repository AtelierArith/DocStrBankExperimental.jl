```
TerminationStatusCode
```

[`TerminationStatus`](@ref) 属性の可能な値の列挙型です。

この属性は、最も最近の [`optimize!`](@ref) の呼び出しでオプティマイザが実行を停止した理由を説明します。

## 値

### [`OPTIMIZE_NOT_CALLED`](@ref)

アルゴリズムは開始されていません。

### [`OPTIMAL`](@ref)

アルゴリズムはグローバルに最適な解を見つけました。

### [`INFEASIBLE`](@ref)

アルゴリズムは、プライマルに実行可能な解が存在しないことを証明しました。

### [`DUAL_INFEASIBLE`](@ref)

アルゴリズムは、デュアルに実行可能な解が存在しないことを証明しました。

プライマル問題が実行可能かどうかを確認するには、目的の感覚を [`FEASIBILITY_SENSE`](@ref) に設定し、問題を再解決します。

プライマルに実行可能な点が存在しない場合、元の問題はプライマルおよびデュアルに実行不可能です。

プライマルに実行可能な解が存在する場合、このステータスは通常、問題が無限大であることを示唆しますが、いくつかの技術的例外があります（たとえば、問題が強双対性が成り立たない円錐最適化問題である場合など）。

技術的例外は線形プログラムには適用されません。 [`DUAL_INFEASIBLE`](@ref) とプライマルに実行可能な点の組み合わせは、プライマル線形プログラムが無限大であることを意味します。

### [`LOCALLY_SOLVED`](@ref)

アルゴリズムは定常点、局所最適解に収束しましたが、改善のための方向を見つけられなかったか、またはグローバルな保証なしに探索を完了しました。

### [`LOCALLY_INFEASIBLE`](@ref)

アルゴリズムは実行不可能な点に収束したか、または実行可能な解を見つけることなく探索を完了しましたが、実行可能な解が存在しない保証はありません。

プライマルに実行可能な解が存在することがわかっている場合は、[`VariablePrimalStart`](@ref) を使用してソルバーに実行可能な開始点を提供します。

### [`INFEASIBLE_OR_UNBOUNDED`](@ref)

アルゴリズムは、問題が実行不可能または無限大であることを証明したため停止しましたが、2つのケースを区別していません。

2つのケースを区別するには、目的の感覚を [`FEASIBILITY_SENSE`](@ref) に設定し、問題を再解決します。プライマルに実行可能な点が存在する場合、元の問題は無限大です。プライマルに実行可能な点が存在しない場合、元の問題は実行不可能です。

### [`ALMOST_OPTIMAL`](@ref)

アルゴリズムは緩和された許容範囲内でグローバルに最適な解を見つけました。

### [`ALMOST_INFEASIBLE`](@ref)

アルゴリズムは、緩和された許容範囲内で実行可能な解が存在しないと結論付けました。

### [`ALMOST_DUAL_INFEASIBLE`](@ref)

アルゴリズムは、緩和された許容範囲内で問題に対するデュアル境界が存在しないと結論付けました。

### [`ALMOST_LOCALLY_SOLVED`](@ref)

アルゴリズムは定常点、局所最適解に収束したか、または緩和された許容範囲内で改善のための方向を見つけられませんでした。

### [`ITERATION_LIMIT`](@ref)

反復アルゴリズムは、最大反復回数を実施した後に停止しました。

### [`TIME_LIMIT`](@ref)

アルゴリズムは、ユーザーが指定した計算時間の後に停止しました。

このステータスは、[`TimeLimitSec`](@ref) 属性または他のソルバー固有の属性に関連して返される場合があります。

### [`NODE_LIMIT`](@ref)

分枝限定アルゴリズムは、分枝限定木の最大ノード数を探索したため停止しました。

このステータスは、[`NodeLimit`](@ref) 属性または他のソルバー固有の属性に関連して返される場合があります。

### [`SOLUTION_LIMIT`](@ref)

アルゴリズムは、必要な数の解を見つけたため停止しました。これは、MIPでソルバーが最初に遭遇した実行可能な解を返すためにしばしば使用されます。

このステータスは、[`SolutionLimit`](@ref) 属性または他のソルバー固有の属性に関連して返される場合があります。

### [`MEMORY_LIMIT`](@ref)

アルゴリズムは、メモリが不足したため停止しました。

### [`OBJECTIVE_LIMIT`](@ref)

アルゴリズムは、ユーザーによって設定された最小限度を超える解を見つけたため停止しました。

このステータスは、[`ObjectiveLimit`](@ref) 属性または他のソルバー固有の属性に関連して返される場合があります。

### [`NORM_LIMIT`](@ref)

アルゴリズムは、反復のノルムが大きすぎたため停止しました。

これは通常、プライマル問題が無限大であることを意味しますが、ソルバーはそれを証明できませんでした。

### [`OTHER_LIMIT`](@ref)

アルゴリズムは、上記の `_LIMIT_` ステータスのいずれかでカバーされていない制限のために停止しました。

### [`SLOW_PROGRESS`](@ref)

アルゴリズムは、解に向けて進展を続けることができなかったため停止しました。

### [`NUMERICAL_ERROR`](@ref)

アルゴリズムは、回復不可能な数値エラーに遭遇したため停止しました。

### [`INVALID_MODEL`](@ref)

アルゴリズムは、モデルが無効であるため停止しました。

この戻りコードの理由はソルバー固有ですが、一般的な原因は、問題にゼロの変数または制約があるか、問題データに `NaN` のような無効な数が含まれていることです。

### [`INVALID_OPTION`](@ref)

アルゴリズムは、無効なオプションが提供されたため停止しました。

### [`INTERRUPTED`](@ref)

アルゴリズムは、割り込み信号のために停止しました。

これは通常、ソルバーがユーザーによって `CTRL+C` で中断されたことを意味します。

### [`OTHER_ERROR`](@ref)

アルゴリズムは、上記のいずれかのステータスでカバーされていないエラーのために停止しました。詳細についてはソルバーログを確認してください。
