```
data_colors(
    data::AbstractMatrix{<:Real};
    run_umap::Bool = true,
    minimal_saturation::Real = 33,
    minimal_lightness::Real = 20,
    maximal_lightness::Real = 80
)::AbstractVector{<:AbstractString}

data_colors(
    data::AbstractMatrix{<:Real};
    run_umap::Bool = true,
    groups::Union{AbstractVector{T}},
    minimal_saturation::Real = 33,
    minimal_lightness::Real = 20,
    maximal_lightness::Real = 80
)::Dict{T, <:AbstractString}
```

多次元データの色を計算します。

観察/要素の列と変数/測定の行からなる行列が与えられた場合、各列（または列のグループ）に対して色を計算し、色が異なるようにし、より類似した色がより類似したデータ列（または列のグループ）を大まかに示すようにします。

これは、未知のデータセットを調査する際の便利なデフォルトとして「任意の」データに「合理的な」色のセットを提供することを目的としています。特定のデータに合わせて手作業で選ばれた色（例えば、「悪い」列には赤色、「良い」列には緑色を使用する）を置き換えることを意図したものではありません。

これは、[`distinct_colors`](@ref)を使用して必要な数の球体を使ってCIELAB色空間の（可視部分）を詰め込むことによって、すべての色が異なることを保証します。データに色を割り当てるために、UMAPを使用してデータを3Dに縮小します。次に、主成分分析を使用して選択された色（3D球体の中心）と（3D UMAP）データを座標が0-1の範囲にある点群として表現し、最後に安定したマッチングアルゴリズムを使用してこれらの点群を互いにマッピングし、各データ列に色を割り当てます。データがグループ化されている場合は、各グループの重心を使用して各グループの色を生成します。

# 引数

  * `data`: 列が要素/観察を表し、行が変数/測定を表す行列。
  * `run_umap`: データを3Dに変換するためにUMAPを実行するかどうかを指定するブール値。`false`の場合、データ行列は正確に3列でなければならず、そのまま使用されます。
  * `groups`: 各列に対してその列が属するグループの識別子を含むエントリを持つオプションの配列。
  * `minimal_saturation`: この値未満の彩度（CIELAB色空間でのhypot(a, b)）を持つ色を除外します。
  * `minimal_lightness`: この値未満の明度（CIELAB色空間でのl）を持つ色を除外します。
  * `maximal_lightness`: この値を超える明度（CIELAB色空間でのl）を持つ色を除外します。

# 戻り値

`groups`が指定されている場合、グループ名を色にマッピングする辞書。そうでない場合、各列の色を含むエントリを持つベクター。色は通常の`#RRGGBB`16進数形式で名付けられます。

!!! note
    これはUMAPを呼び出すため、（時々）内部でランダム性を使用し、ランダム数生成器を渡す方法がないため、再現可能な結果が必要な場合は、`data_colors`を呼び出す直前に自分で`Random.seed!(...)`を呼び出す必要があります。UMAPがランダム数生成器をパラメータとして渡すことを許可する場合（そうあるべきです）、ここに同じパラメータを追加し、UMAPに渡す必要があります。

