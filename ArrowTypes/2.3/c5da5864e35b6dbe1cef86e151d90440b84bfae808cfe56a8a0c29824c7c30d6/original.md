```
ArrowTypes.arrowname(T) = Symbol(name)
```

Interface method to define the logical type "label" for a custom Julia type `T`. Names will be global for an entire arrow dataset, and conventionally, custom types will just use their type name along with a Julia-specific prefix; for example, for a custom type `Foo`, I would define `ArrowTypes.arrowname(::Type{Foo}) = Symbol("JuliaLang.Foo")`. This ensures other language implementations won't get confused and are safe to ignore the logical type label. When arrow stores non-native data, it must still be *stored* as a native data type, but can have type metadata tied to the data that labels the original *logical* type it originated from. This enables the conversion of native data back to the logical type when deserializing, as long as the deserializer has the same definitions when the data was serialized. Namely, the current Julia session will need the appropriate [`ArrowTypes.JuliaType`](@ref) and [`ArrowTypes.fromarrow`](@ref) definitions in order to know how to convert the native data to the original logical type. See the docs for those interface methods in order to ensure a complete implementation. Also see the accompanying [`ArrowTypes.arrowmetadata`](@ref) docs around providing additional metadata about a custom logical type that may be necessary to fully re-create a Julia type (e.g. non-field-based type parameters).
