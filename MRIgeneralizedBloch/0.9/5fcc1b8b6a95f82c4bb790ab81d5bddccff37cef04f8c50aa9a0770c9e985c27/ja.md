```
calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT[; grad_list=(undef,), rfphase_increment=[π], m0=:periodic, output=:complexsignal, isInversionPulse = [true; falses(length(α)-1)]])
```

信号または磁化の進化を、スーパー・ローレンツィアン線形近似の一般化されたブロッホモデルを用いて計算します。

シミュレーションは、異なるフリップ角αとRFパルスの持続時間TRFを持つ矩形RFパルスのシーケンスを仮定しますが、繰り返し時間TRは固定されています。さらに、バランスの取れた勾配モーメントを仮定します。

# 引数

  * `α::Vector{Real}`: ラジアン単位のフリップ角の配列
  * `TRF::Vector{Real}`: 秒単位のRFパルスの持続時間の配列
  * `TR::Real`: 秒単位の繰り返し時間
  * `ω0::Real`: ラジアン/秒単位のオフレゾナンス周波数
  * `B1::Real`: 正規化された送信B1フィールド、すなわちB1 = 1は適切にキャリブレーションされたB1フィールドに対応
  * `m0s::Real`: 半固体プールの分数サイズ; 0から1の範囲であるべき
  * `R1f::Real`: 自由プールの縦緩和率（1/秒）
  * `R2f::Real`: 自由プールの横緩和率（1/秒）
  * `Rx::Real`: 2つのスピンプール間の交換率（1/秒）
  * `R1f::Real`: 半固体プールの縦緩和率（1/秒）
  * `T2s::Real`: 半固体プールの横緩和時間（秒）
  * `R2slT::NTuple{3, Function}`: 3つの関数のタプル: R2sl(TRF, ω1, B1, T2s)、dR2sldB1(TRF, ω1, B1, T2s)、およびR2sldT2s(TRF, ω1, B1, T2s)。[`precompute_R2sl`](@ref)を使用して生成できます。

オプション:

  * `grad_list=(undef,)`: 計算される勾配を指定するタプル; ベクトル要素は、勾配なしの`undef`または`grad_list=(grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1())`の任意の部分集合/順序であることができます; 見かけの`R1a = R1f = R1s`に関する導関数は`grad_R1a()`で計算できます
  * `rfphase_increment=[π]::Vector{Real}`: 連続するパルス間のRF位相の増分。デフォルト値`π`は、$ω0=0$とともに共鳴条件に対応します。複数の値が提供されると、その結果の信号は出力配列の2次元目に格納されます。
  * `m0=:periodic`: デフォルトのキーワード`:periodic`では、信号とその導関数は$m(0) = -m(T)$を仮定して計算されます。ここで`T`はRFトレインの持続時間です。キーワード`:thermal`では、磁化$m(0)$は熱平衡`[xf, yf, zf, xs, zs] = [0, 0, 1-m0s, 0, m0s]`で初期化され、その後にα[1]/2 - TR/2の準備パルスが続きます; キーワード`:IR`では、この初期化の後に持続時間`TRF[1]`の反転パルスが続き（`α[1]=π`に設定）、その後にα[2]/2 - TR/2の準備パルスが続きます。
  * `preppulse=false`: `true`の場合、`α/2 - TR/2`の準備が適用されます。`m0=:IR`の場合、これは`α[2]`に基づく反転パルスの後に適用されますが、そうでない場合は`α[1]`に基づきます。
  * `output=:complexsignal`: デフォルトのキーワードは、関数が複素値信号（`xf + 1im yf`）を出力するようにトリガーします; キーワード`output=:realmagnetization`は、全体の（実値の）ベクトル`[xf, yf, zf, xs, zs, 1]`の出力をトリガーします。
  * `isInversionPulse::Vector{Bool}`: すべての反転パルスを示します; αと同じ長さでなければなりません; `default = [true; falses(length(α)-1)]`は、最初のパルスが反転パルスであり、他のすべてがそうでないことを示します。

# 例

```jldoctest
julia> R2slT = precompute_R2sl();


julia> calculatesignal_linearapprox(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 6.5, 10e-6, R2slT)
100×1×1 Array{ComplexF64, 3}:
[:, :, 1] =
  -0.029305987774458163 - 0.0im
   0.004329424678273618 + 0.0im
  -0.022761409373843695 + 0.0im
   0.008280330224850314 + 0.0im
  -0.016751305727868086 + 0.0im
   0.011921649143708494 + 0.0im
   -0.01119057989041819 + 0.0im
   0.015305608440952356 + 0.0im
 -0.0060267918180664974 + 0.0im
   0.018463027499697613 + 0.0im
                        ⋮
   0.061531473509660414 + 0.0im
    0.06081400768357244 + 0.0im
     0.0617257515931871 + 0.0im
   0.061064216222629225 + 0.0im
     0.0619074570531536 + 0.0im
    0.06129750535994419 + 0.0im
   0.062077399758002534 + 0.0im
   0.061515021919442275 + 0.0im
    0.06223633770306246 + 0.0im
```
