```
NewtonsMethod(;
    max_iters = 1,
    update_j = UpdateEvery(NewNewtonIteration),
    krylov_method = nothing,
    convergence_checker = nothing,
    verbose = Silent(),
)
```

方程 `f(x) = 0` を解くために、ヤコビ行列（またはヤコビ行列の近似） `j(x) = f'(x)` を使用します。これは、`solve_newton!(::NewtonsMethod, cache, x, f!, j! = nothing)` を呼び出すことによって行われ、ここで `f!(f, x)` は `f(x)` をインプレースで設定する関数であり、指定されている場合、`j!(j, x)` は `j(x)` をインプレースで設定する関数です。ニュートン法に渡される `x` はインプレースで変更され、その初期値は根の初期推測として使用されます。`cache` は `allocate_cache(::NewtonsMethod, x_prototype, j_prototype = nothing)` を使用して取得でき、ここで `x_prototype` は `x` と `f(x)` に類似しており、指定されている場合、`j_prototype` は `j(x)` に類似しています。`j(x)` が可逆であるためには、正方行列でなければならず、これは `x` と `f(x)` が互いに類似していることを意味します。

`x[n]` を `n` 番目のニュートン反復における `x` の値（`x[0]` は `x` の初期値を示す）とし、`x[n]` が `f(x)` のある根 `x̂` に十分近いと仮定すると、一次近似 `f(x̂) ≈ f(x[n]) + j(x[n]) * (x̂ - x[n])` が成り立ちます。`f(x̂) = 0` であるため、`n` 番目の反復における誤差はおおよそ `x[n] - x̂ ≈ Δx[n]` となり、ここで `Δx[n] = j(x[n]) \ f(x[n])` です。ニュートン法は `x[n + 1]` をこの近似によって与えられる `x̂` の値に設定します：`x[n + 1] = x[n] - Δx[n]`。

Krylov法が指定されている場合、それを使用して誤差 `Δx[n] = j(x[n]) \ f(x[n])` を計算します。そうでない場合、誤差は `ldiv!(Δx, j, f)` を呼び出すことによって直接計算されます。Krylov法がヤコビ行列フリーのJVP（ヤコビ行列-ベクトル積）を使用する場合、`j_prototype` と `j!` を指定する必要はありません。ニュートン法がKrylov法を使用する場合、それは「ニュートン-クライロフ法」と呼ばれ、さらにKrylov法がヤコビ行列フリーのJVPを使用する場合、それは「ヤコビ行列フリーのニュートン-クライロフ法」と呼ばれます。

`j_prototype` が指定されている場合、それは `DenseMatrix` であってはなりません。もしそうであれば、`ldiv!` が呼び出される前に `lu` で因数分解される必要があり、これには追加のメモリの割り当てが必要です。代わりに、`j_prototype` は `ldiv!` に直接渡すことができるオブジェクトであるべきです。ただし、便利さのために `DenseMatrix` の使用はサポートされています。しかし、`Krylov.jl` はその前処理器に対してそのようなサポートを提供していないため、`j!` で計算された値がヤコビ行列フリーのJVPを持つKrylov法で前処理器として使用されるため、そのようなKrylov法を使用するには `ldiv!` に渡すことができる `j_prototype` を指定する必要があります。

`j(x)` が十分に遅く変化する場合、`update_j` を `UpdateEvery(NewNewtonIteration)` から、`UpdateEvery(NewNewtonSolve)` のような他の `UpdateSignalHandler` に変更することができます。これにより、近似 `j(x[n]) ≈ j(x₀)` を行うことができ、ここで `x₀` は `x[n]` の以前の値（場合によってはニュートン法の以前の `solve_newton!` からの値）です。このような近似を使用するニュートン法は「コード法」と呼ばれます。

さらに、`update_j` はニュートン法の外部から発生する信号によってトリガーされる `UpdateSignalHandler` に設定することができます。例えば、`UpdateEvery(NewTimeStep)` のようにです。ニュートン法が実行されていない間に `j` を更新するための任意の信号を送信することが可能であり、その場合は `update!(::NewtonsMethod, cache, ::UpdateSignal, j!)` を呼び出します。この場合、`j!(j)` は `x` に依存せずに `j` をインプレースで設定する関数です（ニュートン法が実行されていない間は `x` が必ずしも定義されているわけではないため、このバージョンの `j!` は `x` を引数として取ることはありません）。これにより、近似 `j(x[n]) ≈ j₀` を行うことができ、ここで `j₀` は任意の値を持つことができます。

収束チェッカーが提供されている場合、それは反復 `n` において `x[n]` の値とその誤差 `Δx[n]` に基づいて反復を停止するかどうかを判断するために使用されます。そうでない場合、ニュートン法は `n = 0` から `n = max_iters` まで反復します。収束チェッカーが `n = max_iters` の時点で `x[n]` が収束していないと判断した場合、警告が表示されます。

`verbose` が `true` に設定されている場合、各反復で `x[n]` と `Δx[n]` のノルムが表示されます。収束チェッカーがない場合、最後の反復では `Δx[n]` が計算されないため、その最終ノルムは表示されません。
