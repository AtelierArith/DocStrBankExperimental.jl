```
ForwardDiffStepSize1()
```

`ForwardDiffStepSize`は、ここにあるノートに基づいて導出されたものです: https://web.engr.oregonstate.edu/~webbky/MAE4020*5020*files/Section%204%20Roundoff%20and%20Truncation%20Error.pdf。実際にはニュートン-クリロフ法であまり使用されませんが、`ForwardDiffJVP`の`step_adjustment`の値を設定する方法についての直感を提供することができます。

`f(x + ε * Δx)`の一階テイラー級数展開は、`f(x + ε * Δx) = f(x) + j(x) * (ε * Δx) + e_trunc(x, ε * Δx)`であり、ここで`j(x) = f'(x)`であり、`e_trunc`は展開の切り捨て誤差です。丸め誤差のため、`f(x)`の値を直接計算することはできず、代わりに`f̂(x)`のみを決定できます。ここで、`f(x) = f̂(x) + e_round(x)`です。この式を展開に代入すると、`f̂(x + ε * Δx) + e_round(x + ε * Δx) = f̂(x) + e_round(x) + j(x) * (ε * Δx) + e_trunc(x, ε * Δx)`となります。これを整理すると、ヤコビアン-ベクトル積は次のようになります：`j(x) * Δx = (f̂(x + ε * Δx) - f̂(x)) / ε - e_trunc(x, ε * Δx) / ε + (e_round(x + ε * Δx) - e_round(x)) / ε`。したがって、この積の前方差分近似のノルム誤差は、`‖error‖ = ‖(f̂(x + ε * Δx) - f̂(x)) / ε - j(x) * Δx‖ = ‖e_trunc(x, ε * Δx) - e_round(x + ε * Δx) + e_round(x)‖ / ε`です。三角不等式を使用して、上限を得ることができます：`‖error‖ ≤ (‖e_trunc(x, ε * Δx)‖ + ‖e_round(x + ε * Δx)‖ + ‖e_round(x)‖) / ε`。`ε`が十分に小さい場合、`‖e_round(x + ε * Δx)‖ ≈ ‖e_round(x)‖`と近似できます。これにより、上限は次のように簡略化されます：`‖error‖ ≤ (‖e_trunc(x, ε * Δx)‖ + 2 * ‖e_round(x)‖) / ε`。

テイラーの定理（多変数ベクトル値関数の場合）によれば、一階展開の切り捨て誤差は次のように制約されます：`‖e_trunc(x, ε * Δx)‖ ≤ (sup_{x̂ ∈ X} ‖f''(x̂)‖) / 2 * ‖ε * Δx‖^2`、ここで`X`は`x + ε * Δx`を含む`x`の周りの閉じた球です（証明については https://math.stackexchange.com/questions/3478229 を参照してください）。値`S = ‖f(x)‖ / sup_{x̂ ∈ X} ‖f''(x̂)‖`を定義しましょう。デフォルトでは、`S ≈ 1`と仮定しますが、ユーザーが`f(x)`の「滑らかさ」を示すために他の値を渡すことを許可します（`S`の大きな値は、`f(x)`のヘッセ行列が`f(x)`自体に比べて小さなノルムを持つことを示すべきです）。次に、`‖e_trunc(x, ε * Δx)‖| ≤ ε^2 / (2 * S) * ‖Δx‖^2 * ‖f(x)‖`が得られます。

もし`f(x)`の各成分の最後のビットだけが丸め誤差によって変更できる場合、`e_round(x)`の`i`-th成分は次のように制約されます：`|e_round(x)[i]| ≤ eps(f(x)[i])`。より一般的には、ある定数`R`（デフォルトでは`R ≈ 1`と仮定します）が存在し、次のように制約されます：`|e_round(x)[i]| ≤ R * eps(f(x)[i])`。また、次の近似を行うことができます（これは`eps(FT)`の範囲内で正確です）：`eps(f(x)[i]) ≈ eps(FT) * |f(x)[i]|`。これにより、`|e_round(x)[i]| ≤ R * eps(FT) * |f(x)[i]|`が得られます。これは`e_round(x)`と`f(x)`のすべての成分に対して成り立つため、`‖e_round(x)‖ ≤ R * eps(FT) * ‖f(x)‖`が得られます。

切り捨て誤差と丸め誤差の制約を全体の誤差の制約に代入すると、`‖error‖ ≤ ε / (2 * S) * ‖Δx‖^2 * ‖f(x)‖ + 2 / ε * R * eps(FT) * ‖f(x)‖`が得られます。右辺を`ε`に関して微分し、その結果を0に設定します（第二導関数が常に正であることに注意してください）。これにより、この上限は次のように最小化されます：`ε = step_adjustment * sqrt(eps(FT)) / ‖Δx‖`、ここで`step_adjustment = 2 * sqrt(S * R)`です。デフォルトでは、`step_adjustment = 1`と仮定しますが、`f`が非常に滑らかであるか、大きな丸め誤差がある場合には大きくする必要があります。

なお、上記の導出で前方差分近似を中央差分近似に置き換えた場合、平方根は立方根（または、より一般的には、有限差分近似の次数`n - 1`に対する`n`-th根）に置き換えられることに注意してください。
