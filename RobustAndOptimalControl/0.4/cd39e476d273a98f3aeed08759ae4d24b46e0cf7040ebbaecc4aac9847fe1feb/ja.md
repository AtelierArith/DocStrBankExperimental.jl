```
K, γ, info = glover_mcfarlane(G::AbstractStateSpace, γ = 1.1; W1=1, W2=1)
```

GloverとMcFarlaneの手法を使用して、正規化された共素因子不確実性を持つ安定性マージンϵ = 1/γを最大化するために`G`のコントローラを設計します。

```
γ = 1/ϵ = ||[K;I] inv(I-G*K)*inv(M)||∞
G = inv(M + ΔM)*(N + ΔN)
```

γはγminの相対因子として与えられ、1より大きくなければなりません。すなわち、γ = 1.1の場合、コントローラはγ = 1.1*γminのために設計されます。

私たちはγmin（常に≥ 1）をできるだけ小さくしたいと考えており、通常、γminは4未満であることが要求されます。これは、25%の許容される共素不確実性に対応します。

性能モデリングは、整形されたシステム`Gs = W2*G*W1`に対して`glover_mcfarlane`を呼び出すことによって設計に組み込まれ、その後コントローラを`K = W1*Ks*W2`として形成します。この定式化を使用すると、`Gs = W2*G*W1`に対して従来のループ整形が行えます。植物の整形は、キーワード引数`W1, W2`が使用される場合に内部で処理され、返されるコントローラはすでにスケーリングされています。この場合、`Gs`と`Ks`は検査のために`info`という名前のタプルに含まれます。

フィードフォワードフィルタを設計するために[`glover_mcfarlane_2dof`](@ref)も参照してください。また、コントローラの次数削減については[`baltrunc_coprime`](@ref)を参照してください。計算されたコントローラの次数を削減する場合は、`info.Ks`の次数を削減し、`Kr=W1*Ksred*W2`を形成します。`ncfmargin(info.Gs, Ksred)`および`ncfmargin(G, Kr)`を使用してロバスト性を検証します。

# 例:

以下の参考文献からの例9.3。

```@example GMF
using RobustAndOptimalControl, ControlSystemsBase, Plots, Test
G = tf(200, [10, 1])*tf(1, [0.05, 1])^2     |> ss
Gd = tf(100, [10, 1])                       |> ss
W1 = tf([1, 2], [1, 1e-6])                  |> ss
K, γ, info = glover_mcfarlane(G, 1.1; W1)
@test info.γmin ≈ 2.34 atol=0.005
Gcl = extended_gangoffour(G, K) # 閉ループシステムを形成

fig1 = bodeplot([G, info.Gs, G*K], lab=["G" "" "G scaled" "" "Loop transfer"])
fig2 = bodeplot(Gcl, lab=["S" "KS" "PS" "T"], plotphase=false) # ギャングオブフォーをプロット

fig3 = plot(step(Gd*feedback(1, info.Gs), 3), lab="初期コントローラ")
plot!(step(Gd*feedback(1, G*K), 3), lab="ロバスト化")
fig4 = nyquistplot([info.Gs, G*K], ylims=(-2,1), xlims=(-2, 1),
    Ms_circles = 1.5,
    lab = ["初期コントローラ" "ロバスト化"],
    title = "ロバスト化コントローラの有無によるループ伝達"
)
plot(fig1, fig2, fig3, fig4)
```

コントローラ削減の例: 上記で設計されたコントローラの次数は、ロバスト性マージンの少なくとも2/3を維持しながら次のように削減できます。

```@example GMF
e,_ = ncfmargin(info.Gs, info.Ks)
Kr, hs, infor = baltrunc_coprime(info.Ks, n=info.Ks.nx)
n = findlast(RobustAndOptimalControl.error_bound(hs) .> 2e/3) # 2/3 eはロバスト性マージンを設定
Ksr, hs, infor = baltrunc_coprime(info.Ks; n)
@test ncfmargin(info.Gs, Ksr)[1] >= 2/3 * e
Kr = W1*Ksr
bodeplot([G*K, G*Kr], lab=["L original" "" "L Reduced" ""])
```

これにより、最終的なコントローラ`Kr`は次数3になり、次数5の代わりに非常に似たロバスト性マージンを持ちます。また、次のように呼び出すこともできます。

```@example GMF
controller_reduction_plot(info.Gs, info.Ks)
```

コントローラの次数を選択するのに役立ちます。

参考文献: Skogestadの「Multivariable Feedback Control: Analysis and Design」のセクション9.4.1

# 拡張ヘルプ

Skogestadは次の一般的なアドバイスを提供しています。

1. プラントの出力と入力をスケーリングします。これはほとんどの設計手順にとって非常に重要であり、時には忘れられがちです。一般的に、スケーリングは設計問題の条件を改善し、フィードバックシステムのロバスト性の特性を周波数領域で意味のある分析を行えるようにし、ループ整形のために重みの選択を簡素化します。信号の最大または平均値の大きさに関して正規化するなど、さまざまな方法が利用可能です。設計に直接進む場合、次の変種が実際に役立つことが証明されています。

      * 出力は、各出力へのクロスカップリングの等しい大きさが同様に望ましくないようにスケーリングされます。
      * 各入力は、その期待される動作範囲の10%（例えば10%）でスケーリングされます。つまり、入力は相対的なアクチュエータの能力を反映するようにスケーリングされます。
2. 入力と出力の順序を決定し、プラントができるだけ対角的になるようにします。相対ゲイン配列[`relative_gain_array`](@ref)がここで役立つ場合があります。この擬似対角化の目的は、設計のための前および後の補償器を簡素化することです。これらは、簡単のために対角に選択されます。

    次に、重みを選択して整形されたプラント$G_s = W_2 G W_1$を得ることについて説明します。ここで、$W_1 = W_p W_a W_g$です。
3. 対角の前および後の補償器$W_p$と$W_2$の要素を選択し、$W_2 G W_p$の特異値が望ましいようにします。これは通常、低周波数での高いゲイン、所望の帯域幅での約20 dB/デシベルのロールオフ率（約1の傾き）、高周波数でのより高いロールオフ率を意味します。ここにはいくつかの試行錯誤が含まれます。$W_2$は通常、制御される出力の相対的重要性とコントローラにフィードバックされる他の測定値を反映する定数として選択されます。たとえば、制御される2つの出力のフィードバック測定と速度信号がある場合、$W_2$は`diag([1, 1, 0.1])`として選択されるかもしれません。ここで0.1は速度信号チャネルにあります。$W_p$には動的整形が含まれます。低周波数性能のための積分作用、クロスオーバーでのロールオフ率を減少させるための位相先行、そして高周波数でのロールオフ率を増加させるための位相遅れは、必要に応じて$W_p$に配置されるべきです。重みは、$G_s$に不安定な隠れたモードが作成されないように選択されるべきです。
4. オプション: アクチュエータの使用を制御するために、$W_a$とカスケード接続された追加のゲイン行列$W_g$を導入します。$W_g$は対角であり、スケーリングされたプラント出力に対する参照要求と典型的な外乱に対してアクチュエータの速度制限が超えないように調整されます。これにはいくつかの試行錯誤が必要です。
5. 整形されたプラント$G_s = W_2 G W_1$をロバストに安定化させます。ここで、$W_1 = W_p W_a W_g$です。まず、最大安定性マージン$ϵ_{max} = 1/γ_{min}$が計算されます。マージンが小さすぎる場合、$ϵmax < 0.25$、その場合は戻って重みを修正します。そうでなければ、γ-最適でないコントローラが合成されます。最適コントローラを使用することによる利点は通常ありません。$ϵ_{max}$ > 0.25（それぞれ$γ_{min}$ < 4）の場合、設計は通常成功します。この場合、少なくとも25%の共素因子不確実性が許可され、ロバスト安定化後にオープンループ特異値の形状があまり変わらないこともわかります。小さな値のϵmaxは、選択された特異値ループ形状がロバスト安定性要件と互換性がないことを示しています。γが小さい（ϵが大きい）場合、ロバスト安定化後にループ形状があまり変わらないことは、McFarlaneとGlover（1990）で理論的に正当化されています。
6. 設計を分析し、すべての仕様が満たされていない場合は、重みをさらに修正します。
7. コントローラを実装します。以下に示す構成は、従来のセットアップと比較して有用であることがわかっています。これは、参照が直接$K$のダイナミクスを励起しないためであり、これにより大きなオーバーシュート（古典的な導関数キック）が発生する可能性があります。定数の前フィルタは、$W_1$または$G$における積分作用を仮定して、rとyの間の定常状態ゲインが1になることを保証します（注意: この関数によって返されるKはSkogestadのものと符号が逆であるため、ここでは負のフィードバックを使用します）。

アンチワインドアップは、合成後にHanus形式に$W_1$を置くことで$W_1$に追加できます。[`hanus`](@ref)を参照してください。

```
       ┌─────────┐      ┌────────┐      ┌────────┐
    r  │         │    us│        │  u   │        │  y
   ───►│(K*W2)(0)├──+──►│   W1   ├─────►│   G    ├────┬──►
       │         │  │-  │        │      │        │    │
       └─────────┘  │   └────────┘      └────────┘    │
                    │                                 │
                    │                                 │
                    │   ┌────────┐      ┌────────┐    │
                    │   │        │  ys  │        │    │
                    └───┤   K    │◄─────┤   W2   │◄───┘
                        │        │      │        │
                        └────────┘      └────────┘
```

キーワード: `nfcsyn`, `coprimeunc` ```
