```
GroupViaClustering(; kwargs...)
```

[`AttractorsViaFeaturizing`](@ref)で特徴をグループ化する方法に関する指示を含む構造体を初期化します。`GroupViaClustering`は、bSTAB [Stender2021](@cite)およびMCBB [Gelbrecht2020](@cite)による元の作業に類似して、DBSCANを使用して特徴をグループにクラスタリングします。クラスタリングに関するいくつかのオプションが利用可能であり、以下のキーワードを参照してください。

デフォルトは既存の文献に対して大幅な改善をもたらします。詳細は説明を参照してください。

## キーワード引数

  * `clust_distance_metric = Euclidean()`: クラスタリングに使用されるメトリック。実数値ベクトル `a, b` の間の距離を返す任意の関数 `f(a, b)` を使用できます。Distances.jlのすべてのメトリックがここで使用できます。
  * `rescale_features = true`: trueの場合、抽出された特徴の各次元を `[0,1]` の範囲に別々に再スケールします。これにより、通常、より正確なクラスタリングが実現します。
  * `min_neighbors = 10`: 各特徴がクラスタに含まれると見なされるために必要な最小の隣接特徴の数（すなわち、類似の特徴）、自身を含む。これより少ない場合は、外れ値としてラベル付けされます（`-1`）。
  * `use_mmap = false`: 特徴の距離行列を作成するためにディスク上のマップを使用するかどうか。特徴の数が非常に多く、行列のサイズがメモリに収まらない場合に便利です。

### 最適半径推定のためのキーワード

  * `optimal_radius_method::Union{Real, String} = "silhouettes_optim"`: 実数の場合、特徴をクラスタリングするために使用される半径です。それ以外の場合は、その半径を自動的に決定するために使用される方法を決定します。可能な値は次のとおりです：

      * `"silhouettes"`: クラスタのシルエット値の統計（通常は平均）を最大化する半径を線形（逐次）検索します。これは `silhouette_statistic` で選択できます。線形検索は完了するまでに時間がかかる場合があります。速度を上げるために、`num_attempts_radius` を減少させることで反復する半径の数を減らすことができます（以下のエントリを参照）。
      * `"silhouettes_optim"`: `"silhouettes"`と同じですが、Optim.jlを介して最適化された検索を行います。通常、同じ精度で `"silhouettes"` よりも速いです（ただし、ここでの検索は常にグローバル最大を見つけることが保証されているわけではありませんが、通常は近くに到達します）。
      * `"knee"`: 膝（別名エルボー、最高導関数法）に従って半径を選択し、より迅速ですが、一般的にははるかに悪いクラスタリングをもたらします。`min_neighbors` > 1 が必要です。
  * `num_attempts_radius = 100`: `optimal_radius_method` が反復手順で試す半径の数。値が高いほどクラスタリングの精度が向上しますが、必ずしも大幅にではなく、常に速度が低下します。
  * `silhouette_statistic::Function = mean`: "最適"クラスタリングで最大化されるシルエットの統計（例：平均または最小）。[Stender2021](@cite)の元の実装ではシルエットの `minimum` が使用されており、通常は `mean` よりも精度が低くなります。
  * `max_used_features = 0`: `0` でない場合、最適半径を見つける際に使用される最大の特徴の数を示す `Int` である必要があります。非常に多くの特徴をクラスタリングする際に便利です（例：引力盆地の分数の高精度推定）。

## 説明

DBSCANクラスタリングアルゴリズムは、類似の特徴のクラスタを自動的に特定するために使用されます。各特徴ベクトルは特徴空間の点です。各クラスタは、基本的に密接に詰め込まれた点をグループ化します。密接に詰め込まれているとは、点が自分を中心とした半径 `optimal_radius` のボールの中に少なくとも `min_neighbors` を持っていることを意味します。この方法は、半径が適切に選択されている場合に通常うまく機能しますが、必ずしも簡単な作業ではありません。現在、"最適"な半径を自動的に推定するために3つの方法が実装されています。

### 最適半径の推定

デフォルトの方法は**シルエット法**で、キーワード `silhouette` と `silhouette_optim` を含みます。これらはどちらも、クラスタリングを最適化する半径、つまり各クラスタの質の定量化の統計 `silhouette_statistic`（例：平均値）を最大化する半径を探します。この定量化は、各特定されたクラスタのシルエット値です。シルエット値は、ある点が現在属しているクラスタに対して、他のクラスタと比較してどれだけ類似しているかを測定し、-1（最悪の一致）から+1（理想的な一致）までの範囲です。クラスタが1つだけ見つかった場合、割り当てられたシルエットはゼロです。したがって、検索中の各試行半径に対してクラスタが計算され、そのシルエットが計算され、これらのシルエットの統計が計算されます。アルゴリズムは、そのような統計を最大にする半径を見つけます。`optimal_radius_method = "silhouettes"` の場合、検索は線形に行われ、`optimal_radius_method = "silhouettes"` の最小から最大の候補半径まで行われます；`optimal_radius_method = silhouettes_optim` の場合、Optim.jlによって実行される最適化された検索を介して行われ、通常はより速く、同様の精度を持ちます。3つ目の選択肢は`"elbow"`法で、これは各点からそのk近傍（`k=min_neighbors`）までの距離を計算し、距離の曲線の最高導関数に対応する距離を見つけることによって機能します。この距離が最適半径として選ばれます。これは[Ester1996](@cite)および[Schubert2017](@cite)で説明されています。通常、`"silhouette"`法よりもかなり劣ります。 ```
