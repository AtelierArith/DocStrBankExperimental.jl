```
auxquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)
```

関数 `f(x)` を `a` から `b` まで数値的に積分し、オプションで追加の区間 `b` から `c` までなども積分します。キーワードオプションには、相対誤差許容値 `rtol` （`atol==0` の場合、デフォルトは端点の精度で `sqrt(eps)`）、絶対誤差許容値 `atol` （デフォルトは 0）、最大関数評価回数 `maxevals` （デフォルトは `10^7`）、および積分ルールの `order` （デフォルトは 7）が含まれます。

推定された積分値 `I` と絶対誤差の推定上限 `E` のペア `(I,E)` を返します。`maxevals` を超えない場合、`E <= max(atol, rtol*norm(I))` が成り立ちます。（`norm(I)` がゼロになる可能性がある場合には、正の `atol` を指定することが有用です。）

QuadGK.jl の `quadgk` と比較して、`auxquadgk` は難しい関数の積分に対していくつかの追加の安全策を実装しています。相対誤差を使用してすべてのセグメントを誤差が許容値を超える場合に適応的に細分化する方法が変更されます（最大の誤差を持つセグメントだけでなく）。さらに、被積分関数が `AuxValue` を返す場合、ヒープはまず補助値を積分し、その後に主値を積分するためにセグメントのヒープを再ソートします。

端点 `a` などは複素数でも構いません（この場合、積分は複素平面の直線セグメントに対して行われます）。端点が `BigFloat` の場合、積分も `BigFloat` 精度で行われます。

!!! note
    積分の `order` を精度に応じて増加させることが推奨されます。滑らかな被積分関数に対して。


より一般的には、精度は積分端点の精度によって設定されます（浮動小数点型に昇格されます）。

被積分関数 `f(x)` は任意の数値スカラー、ベクトル、または行列型、または実際には `+`、`-`、実数値による乗算、および `norm` をサポートする任意の型を返すことができます（すなわち、任意のノルム付きベクトル空間）。あるいは、`norm` キーワード引数として `norm` に似た関数を渡すことで異なるノルムを指定することもできます（デフォルトは `norm`）。

!!! note
    この関数は一次元の積分のみを提供します。多次元積分（キュバチュア）には、多くの異なるアルゴリズムがあり（しばしば単純なネストされた1d積分よりもはるかに優れています）、最適な選択は非常に問題依存的です。多次元積分や他の専門的なタスク（例えば、高振動または特異関数の積分）に利用可能なアルゴリズムについては、Juliaの外部パッケージリストを参照してください。


このアルゴリズムは適応型ガウス-クロンロッド積分技術です：各区間の積分はクロンロッドルール（`2*order+1` 点）を使用して推定され、誤差は埋め込まれたガウスルール（`order` 点）を使用して推定されます。最大の誤差を持つ区間は2つの区間に細分化され、所望の誤差許容値が達成されるまでこのプロセスが繰り返されます。

これらの数値積分ルールは、各区間内の滑らかな関数に対して最も効果的に機能しますので、関数に既知の不連続点や他の特異点がある場合は、不連続点を端点に置くように区間を細分化するのが最良です。例えば、`f` が `x=0.7` で不連続であり、0から1まで積分したい場合は、`auxquadgk(f, 0,0.7,1)` を使用して不連続点で区間を細分化する必要があります。被積分関数は区間の端点で正確に評価されることはないため、特異点が積分可能である限り、端点で発散する関数を積分することが可能です（例えば、`log(x)` や `1/sqrt(x)` の特異点）。

実数値の端点の場合、開始点および/または終了点は無限大である可能性があります。（無限区間を有限区間にマッピングするために内部で座標変換が行われます。）

通常の使用では、`auxquadgk(...)` はセグメント用のバッファを割り当てます。代わりに、`alloc_segbuf(...)` を使用して割り当てられた事前割り当てバッファを `segbuf` 引数として渡すことができます。このバッファは、繰り返しの割り当てを避けるために複数の呼び出しで使用できます。 ```
