```
contquadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)
```

関数 `f(x)` を `a` から `b` まで数値的に積分し、オプションで追加の区間 `b` から `c` なども積分します。キーワードオプションには、相対誤差許容値 `rtol` （`atol==0` の場合、デフォルトは端点の精度で `sqrt(eps)`）、絶対誤差許容値 `atol` （デフォルトは 0）、最大関数評価回数 `maxevals` （デフォルトは `10^7`）、および積分則の `order` （デフォルトは 7）が含まれます。

推定された積分値 `I` と絶対誤差の推定上限 `E` のペア `(I,E)` を返します。`maxevals` を超えない場合、`E <= max(atol, rtol*norm(I))` が成り立ちます。（`norm(I)` がゼロになる可能性がある場合には、正の `atol` を指定することが有用です。）

端点 `a` などは複素数でも構いません（この場合、積分は複素平面の直線セグメントに沿って行われます）。端点が `BigFloat` の場合、積分も `BigFloat` 精度で行われます。

!!! note
    積分の `order` を精度に応じて増加させることが推奨されます。滑らかな被積分関数に対して。


より一般的には、精度は積分端点の精度によって設定されます（浮動小数点型に昇格されます）。

被積分関数 `f(x)` は任意の数値スカラー、ベクトル、または行列型を返すことができ、実際には `+`、`-`、実数値による乗算、および `norm` をサポートする任意の型（すなわち、任意のノルム付きベクトル空間）である必要があります。あるいは、`norm` キーワード引数として `norm` に似た関数を渡すことで異なるノルムを指定することもできます（デフォルトは `norm`）。

!!! note
    この関数は一次元の積分のみを提供します。多次元積分（キュバチュア）には、多くの異なるアルゴリズムがあり（しばしば単純なネストされた1d積分よりもはるかに優れています）、最適な選択は非常に問題依存です。多次元積分や他の専門的なタスク（例えば、高振動または特異関数の積分）に利用可能なアルゴリズムについては、Juliaの外部パッケージリストを参照してください。


このアルゴリズムは適応型ガウス-クロンロッド積分技術です：各区間の積分はクロンロッド則（`2*order+1` 点）を使用して推定され、誤差は埋め込まれたガウス則（`order` 点）を使用して推定されます。最大の誤差を持つ区間は2つの区間に分割され、所望の誤差許容値が達成されるまでこのプロセスが繰り返されます。

これらの数値積分則は、各区間内で滑らかな関数に対して最も効果的に機能します。したがって、関数に既知の不連続性や他の特異点がある場合は、不連続点を端点に置くように区間を分割するのが最良です。たとえば、`f` が `x=0.7` で不連続性を持ち、0から1まで積分したい場合は、`quadgk(f, 0,0.7,1)` を使用して不連続点で区間を分割する必要があります。被積分関数は区間の端点で正確に評価されることはないため、特異点が可積分である限り、端点で発散する関数を積分することが可能です（たとえば、`log(x)` や `1/sqrt(x)` の特異点）。

実数値の端点の場合、開始点および/または終了点は無限大である可能性があります。（無限区間を有限区間にマッピングするために内部で座標変換が行われます。）

通常の使用では、`quadgk(...)` はセグメント用のバッファを割り当てます。代わりに、`alloc_segbuf(...)` を使用して割り当てられた事前割り当てバッファを `segbuf` 引数として渡すことができます。このバッファは、繰り返しの割り当てを避けるために複数の呼び出しで使用できます。
