このモジュールは、有限複素反射群および任意のコクセター群に関連するヘッケ代数を実装しており（これらの代数は後者の場合にイワホリ・ヘッケ代数と呼ばれます）、また有限群のヘッケ代数のキャラクターテーブル、シュール要素、および表現も実装しています。イワホリ・ヘッケ代数および `G(d,1,1)` に対して、このモジュールは標準の `T` 基底も実装しています。カズダン・ルスティグ基底についてはモジュール `KL` を参照してください。

`(W,S)` をコクセター系とし、`mₛₜ` を `s,t∈ S` の `st` の順序とします。`R` を 1 を持つ可換環とし、`s∈ S` に対して `uₛ₀,uₛ₁∈ R` を `W` における `s` の共役類のみに依存する要素とします（これは、`mₛₜ` が奇数のときに `uₛᵢ=uₜᵢ` であることを要求するのと同じです）。`R` 上の `W` のイワホリ・ヘッケ代数は、次のように定義される `R` 上の `W` の群代数の変形です：それは、次の関係に従う要素 `Tₛ, s∈ S` によって生成される単位的な可換 `R`-代数です。

$$
(Tₛ-uₛ₀)(Tₛ-uₛ₁)=0
$$

すべての `s∈ S` に対して（2次関係）

$$
TₛTₜTₛ…= TₜTₛTₜ…
$$

各側に `mₛₜ` 個の因子を持つ（ブレイド関係）

もし `uₛ₀=1` および `uₛ₁=-1` がすべての `s` に対して成り立つなら、2次関係は `Tₛ²=1` となり、群代数の変形は自明になります。

生成子 `Tₛ` がブレイド関係を満たすため、`H` は実際には `W` に関連するブレイド群の群代数の商です。ブレイド関係はまた、任意の簡約表現 `s_1⋯ s_m` の積 `Tₛ_1⋯ Tₛ_m` が同じ値を持つことを示唆しており、それを `T_w` と表記します。`T_1=1` であり、もし `uₛᵢ` のいずれかが可逆であれば、`{T_w}_{w∈ W}` はイワホリ・ヘッケ代数の `R`-基底を形成し、`uₛ₀↦1` および `uₛ₁↦-1` のとき群代数 `R[W]` の標準基底に特化します。

`uₛᵢ` のいずれかが可逆である場合、構造定数（積 `T_vT_w` の分解）は次のように得られます。`v` の簡約表現を選び、例えば `v=s_1 ⋯ s_k` とし、次の式を帰納的に適用します：

$$
T_sT_w=T_{sw}
$$

```
           もし `l(sw)=l(w)+1`
```

$$
T_sT_w=-uₛ₀uₛ₁T_{sw}+(uₛ₀+uₛ₁)T_w
$$

もし `l(sw)=l(w)-1`。

もし `uₛ₀` または `uₛ₁` のいずれかが `R` で可逆であれば、例えば `uₛ₁` の場合、生成子を `T′ₛ=-Tₛ/uₛ₁` に変更し、`qₛ=-uₛ₀/uₛ₁` を設定することによって、ブレイド関係は変わりません（`mₛₜ` が奇数のときに `uₛᵢ=uₜᵢ` であるため）が、2次関係は `(T′ₛ-qₛ)(T′ₛ+1)=0` になります。この正規化は文献で考慮される最も一般的な形です。カズダン・ルスティグ理論の文脈でのもう一つの一般的な形は、`uₛ₀=√qₛ` および `uₛ₁=-√qₛ⁻¹` です。生成子ごとに2つのパラメータを持つこの形は、例えばジョーンズ多項式を構築する際に便利です。すべての `s` に対して `uₛ₀=q`、`uₛ₁=-1` であれば、対応する代数を `W` に関連する「1パラメータ」または「スペシャル」イワホリ・ヘッケ代数と呼びます。

いくつかのイワホリ・ヘッケ代数では、キャラクターテーブル、および一般的にカズダン・ルスティグ基底は `-uₛ₀uₛ₁` の平方根を必要とします。これらの平方根は、代数を構築する際にキーワード `rootpara` で指定できます；その後、関数 `rootpara(H)` は選択された根を返します。指定されていない場合、必要に応じて自動的に根を抽出しようとします；`rootpara(H)` は行われた選択について通知します。いくつかの数学的結果は、明示的に2つの可能な根のうちの1つを選択することを要求し、自動的に行うことができないため、キーワード初期化が必要です。

`R` と `uₛᵢ` に対する普遍的な選択があります：`uₛᵢ:s∈ S,i∈[0,1]` を、`mₛₜ` が奇数のときに `uₛᵢ=uₜᵢ` となるような不定元とし、対応する多項式環を `A=ℤ[uₛᵢ]` とします。すると、パラメータ `uₛᵢ` を持つ `W` のヘッケ代数 `H` は、`W` の *一般的なイワホリ・ヘッケ代数* と呼ばれます。パラメータ `vₛᵢ` を持つヘッケ代数 `H₁` は、`H` から特化によって得られます。なぜなら、すべての `i` に対して `f:A → R` という一意の環準同型が存在し、`f(uₛᵢ)=vₛᵢ` となるからです。したがって、`f` を介して `H₁` を $R⊗ _A H$ に同一視できます。

1パラメータヘッケ代数の不可約キャラクターの特定の不変量は、基礎となる有限コクセター群の表現理論において特別な役割を果たします。すなわち、`a`-および `A`-不変量です。イワホリ・ヘッケ代数の基本的な性質と、有限リー型群の表現理論に対する関連性については、例えば [Curtis and Reiner 1987](biblio.htm#CR87) のセクション67および68を参照してください。

次の例では、コクセター群のタイプ `A_2` に関連する `0`-イワホリ・ヘッケ代数の乗法表を計算します。

```julia-repl
julia> W=coxgroup(:A,2)
A₂

julia> H=hecke(W,0)            # `q=0` の1パラメータ代数
hecke(A₂,0)

julia> T=Tbasis(H);            # `T` 基底を作成

julia> b=T.(elements(W))       # 基底
6-element Vector{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:
 T.
 T₁
 T₂
 T₁₂
 T₂₁
 T₁₂₁

julia> b*permutedims(b)       # 乗法表
6×6 Matrix{HeckeTElt{HeckeAlgebra{Int64, Perm{Int16}, FiniteCoxeterGroup{Perm{Int16},Int64}}, Int64, Perm{Int16}}}:
 T.    T₁     T₂     T₁₂    T₂₁    T₁₂₁
 T₁    -T₁    T₁₂    -T₁₂   T₁₂₁   -T₁₂₁
 T₂    T₂₁    -T₂    T₁₂₁   -T₂₁   -T₁₂₁
 T₁₂   T₁₂₁   -T₁₂   -T₁₂₁  -T₁₂₁  T₁₂₁
 T₂₁   -T₂₁   T₁₂₁   -T₁₂₁  -T₁₂₁  T₁₂₁
 T₁₂₁  -T₁₂₁  -T₁₂₁  T₁₂₁   T₁₂₁   -T₁₂₁
```

したがって、我々は任意のパラメータを持つ代数で作業します。これはキャラクターや表現のレベルでも機能することがわかります。

一般の複素反射群についても、状況は似ています。ヘッケ代数は群代数の変形であり、実反射群のためのものを一般化しています。

定義は、ブレイド群の代数の商としてのものです。ここで `W` が複素ベクトル空間 `V` の *有限* 反射群であると仮定します。関連する *ブレイド群* は、空間 $(V-\bigcup_{H\in\mathcal H}  H)/W$ の基本群 `Π₁` です。ここで、$\mathcal H$ は `W` の反射ハイパープレーンの集合です。この群は、ブレイド群から反射群への自然な写像によって特定の反射に射影される *ブレイド反射* によって生成されます。与えられた `W`-軌道の反射に射影されるブレイド反射は共役です。`𝐬` をそのようなブレイド反射の共役類の代表とし、`e` を `W` における `𝐬` の像の順序とし、$u_{𝐬,0},…,u_{𝐬,e-1}$ を不定元とします。`W` の一般的なヘッケ代数は、ブレイド群代数の商であり、関係 $(𝐬-u_{𝐬,0})…(𝐬-u_{𝐬,e-1})=0$ によって定義される $ℤ[u_{𝐬,i}^{±  1}]_{𝐬,i}$-代数です。そして、`W` の任意のヘッケ代数は、この一般的な代数からいくつかのパラメータを特化することによって得られる代数です。

一般的なヘッケ代数は、ブレイド群の提示によって明示的に記述されます。ブレイド群は、ブレイド反射における同次関係によって提示され、これを *ブレイド関係* と呼びます。これは [Broué-Malle-Rouquier 1998](biblio.htm#BMR98) および [Bessis-Michel 2003](biblio.htm#BM03) で説明されています（その一部は、VKCURVE GAP3パッケージを使用して得られ、Juliaにも移植されています）。さらに、これらの提示は、反射群が同じ関係によって提示され、生成反射の順序を記述する関係、すなわち *順序関係* が追加されるような形になっています。したがって、ヘッケ代数は `W` の提示に似た形を持ち、同じブレイド関係を持ちますが、順序関係は変形されたバージョンに置き換えられます。

`S⊂ W` が、ブレイド群における生成ブレイド反射に持ち上げられる `W` の特定の反射の集合である場合、順序 `e` の `s` の共役類ごとに不定元 `uₛ₀,…,uₛₑ₋₁` を取ります。すると、一般的なヘッケ代数は、ブレイド関係と変形された順序関係 $(T_s-u_{s,0})…(T_s-u_{s,e-1})=0$ によって提示された、生成子 `T_s` を持つ $ℤ[uₛᵢ^{±1}]ₛᵢ$-代数 `H` です。

アリキ、コイケ、マレは、これらの代数のいくつかのキャラクターテーブルを計算しました。これには、すべての2次元反射群のものが含まれています。詳細は [Broué-Malle 1993](biblio.htm#BM93) および [Malle 1996](biblio.htm#Mal96) を参照してください。私たちのデータには、実反射群のすべての表現およびキャラクターテーブルのモデルが含まれています。また、非原始群および次元2および3の原始群のものも含まれています（これらの最後の表現は [Malle-Michel 2010](biblio.htm#MM10) で計算されています）。さらに、`G₂₉` および `G₃₃` に対してミッシェルによって計算されたモデルとキャラクターテーブルも含まれています。また、残りの群 `G₃₁,G₃₂` および `G₃₄` に対する表現の部分リストと部分キャラクターテーブルも含まれています。これらは、マレとミッシェルが `G₃₂` に対して、ミッシェルが他の2つの代数に対して計算したものです。

特化 $u_{𝐬,i}↦ ζₑⁱ$ によって得られるヘッケ代数の商は、`W` の群代数と同型です。分裂環の上で、ヘッケ代数が同じ環の上で `W` の群代数と同型であるという予想が20年間なされてきました。これは、ヘッケ代数が次元 `|W|` の自由であることを示すことが主な問題であるため、自由性予想と呼ばれました。これは、2019年に、マリン、ファイファー、チャブリ、土岡を含む多くの人々の仕事のおかげでついに証明されました。その過程で、`b_1=1` であり、自然な商写像によって `b_w` が `w` に写像されるようなブレイド群の要素の集合 `{b_w}_{w∈ W}` が存在することが証明されました。その画像 `T_w` はヘッケ代数の基底を形成します。

そのような基底 `T_w` を選択できると予想されています。さらに、`t` という線形形式が定義され、`t(T_w)=0` もし `w≠ 1` であり、`t(1)=1` であるとき、これは対称代数 `H` の対称化形式であるとされています。これはすべての実反射群に対してよく知られており、非原始反射群に対しては [Malle-Mathas 1998](biblio.htm#MM98) で、次元2および3のいくつかの原始群に対しては [Malle-Michel 2010](biblio.htm#MM10) で証明されています。クローヴェラキとチャブリは、他のいくつかの2次元ケースを扱っています。各不可約キャラクター `φ` に対して、`H` に関連する *シュール要素* `Sᵩ` を、任意の `H` の要素 `T` に対して `t(T)=∑ᵩ φ(T)/Sᵩ` という条件によって定義します。シュール要素はローレンツ多項式であり、上記の性質を持つ基底の選択には依存しないことが示されます。マレは、上記の予想を仮定してこれらのシュール要素を計算しました。これらはチェヴィデータに含まれています。

ヘッケ代数のパラメータを指定するさまざまな方法については、関数 `hecke` を参照してください。また、`central_monomials, char_values, class_polynomials, schur_elements, isrepresentation, factorized_schur_elements` のドキュメントストリングも確認してください。ヘッケ代数の `CharTable, representations, reflrep` のメソッドも参照してください。

ヘッケ要素を分解するには、`getindex`, `setindex!`, `keys`, `values`, `iterate` の関数を使用します。

```julia-repl
julia> H=hecke(W,Pol(:q))
hecke(A₂,q)

julia> T=Tbasis(H);

julia> h=T(1,2)^2
qT₂₁+(q-1)T₁₂₁

julia> length(h) # h は2項を持つ
2

julia> h[W(2,1)] # W(2,1) の係数
Pol{Int64}: q

julia> collect(h) # perm=>coeff のペア
2-element Vector{Any}:
  (1,2,6)(3,4,5) => q
 (1,5)(2,4)(3,6) => q-1

julia> collect(values(h)) # 係数を取得
2-element Vector{Pol{Int64}}:
 q
 q-1

julia> collect(keys(h)) # 対応する Perm を取得
2-element Vector{Perm{Int16}}:
 (1,2,6)(3,4,5)
 (1,5)(2,4)(3,6)

julia> h[W(2,1)]=Pol(3)
Pol{Int64}: 3

julia> h
3T₂₁+(q-1)T₁₂₁
```

最後に、julia 1.8 でのベンチマーク

```benchmark
julia> function test_w0(n)
         W=coxgroup(:A,n)
         Tbasis(hecke(W,Pol(:q)))(longest(W))^2
       end
test_w0 (generic function with 1 method)

julia> @btime test_w0(7);
   97.210 ms (1776476 allocations: 127.52 MiB)
```

GAP3 では、類似の関数は920msかかります。

```
test_w0:=function(n)local W,T,H;
  W:=CoxeterGroup("A",n);H:=Hecke(W,X(Rationals));T:=Basis(H,"T");
  return T(LongestCoxeterWord(W))^2;
end;
```
