`V` を複素数の部分体 `K` 上のベクトル空間とします（Julia では `K` の要素は通常 `Rational` や `Cyc` で表されます）。

*複素反射* は、固定点集合がハイパープレーンである有限次数の `GL(V)` の要素 `s∈ GL(V)` です。`s` の *反射ハイパープレーン* を `Hₛ` と呼びます。

ほとんどの場合、「複素反射」を *反射* と略します。一部の文献では「反射」は次数 2 の `s` に限定され、それ以外は *擬似反射* が使用されます。

反射 `s` には、`1` でない一意の固有値 `ζₛ` があり、これは単位根です。`K` が実数の部分体である場合、`ζₛ` は必ず `-1` に等しく、`s` は次数 2 です。固有値 `ζₛ` に対する `s` の固有ベクトル `r∈ V` は `s` の *根* と呼ばれ、核 `Hₛ` の上の線形形式 `rᵛ` は `s` の *コルート* と呼ばれます。通常、`r` と `rᵛ` は `rᵛ(r)=1-ζ` となるようにスケーリングされます。すると、`s` は `s(x)=x-rᵛ(x)r` で定義される `V` 上の写像です。このような根とコルートは、根をスケーリングし、コルートを逆にスケーリングすることによって一意です。

有限複素反射群 `W` は、複素反射によって生成される有限群です。`W` が反射 `s` を含むとき、必ずその冪を含むため、`W` は常に `ζₛ==E(d)` を満たす反射 `s` によって生成されます。ここで `d` は `s` の次数です。また、`s` が `W` の他の反射の冪でないと仮定できます。このような反射は `W` の *特別* な反射と呼ばれ、`Hₛ` を中心化する `W` の循環部分群の標準生成元です。私たちが構築する複素反射群の生成元は常に特別な反射です。特別な反射の集合は反射ハイパープレーンと一対一対応します。実反射群では、すべての反射が特別です。

置換群で計算する方が行列群で計算するよりもはるかに効率的です。したがって、有限複素反射群 `W` で計算するために、`W` 不変な根とコルートベクトルの集合に対する置換表現を使用します。つまり、`R` というペアの集合 `(r,rᵛ)∈ V×Vᵛ` が `W` によって不変であり、`W` のすべての特別な反射が `R` のいくつかのペアによって決定されるようにします（[`reflectionMatrix`](@ref) を参照）。`W` 不変な集合を使用することは、同じ反射を決定する複数のペアが存在することを意味し、それらは単位根によって異なります。これは、各反射に対して2つの根（1つは正、もう1つは負）が関連付けられるコクセター群の通常の構成を一般化します（`K=ℝ` の場合）。

複素反射群は、表現 `V` が不可約である場合に *不可約* です。不可約複素反射群の場合、特別な反射に対しての根の数は、反射の次数と `W` の中心の次数の最小公倍数以上です。

以下のメソッドは、有限複素反射群に対して常に定義されています：

  * `gens(W)`：`W` を生成する（特別な）反射で、根の置換として与えられます。`reflrep(W)` はそれらを行列として提供します。
  * `roots(W)`：`W` の根のリスト。
  * `coroots(W)`：根と同じ順序のコルートのリスト。
  * `refls(W)`：置換としての `W` の特別な反射のリスト。このリストは根と同じ長さであり、その `i` 番目の要素は `i` 番目の根に対する特別な反射であるため、重複があります。`unique_refls(W)` は、対応する根の周りの特別な反射が `W` の各特別な反射を1回だけ達成するような `1:length(roots(W))` のサブリストを返します。

リスト `roots`、`coroots` および `refls` は、反射 `gens(W)` のものから始まります。これらは *単純* 根とコルートおよび *単純* 反射と呼ばれます。

  * `simpleroots(W)`：単純根を行列として。
  * `simplecoroots(W)`：単純コルートを行列として。
  * `reflections(W)` は、重複なしで `W` のすべての反射のリストを提供します（特別なものだけでなく）、[`Reflection`](@ref) 型のオブジェクトとして、特別な反射から始まります。これらのオブジェクトは、各反射に関するより多くの情報を含んでいます。

有限不可約複素反射群は Shephard と Todd によって分類されました。詳細は [ShephardTodd1954](biblio.htm#ST54) を参照してください。これらは、3つのパラメータに依存する無限ファミリー `G(de,e,r)` と、`G₄` から `G₃₇` までの名前が Shephard と Todd によって付けられた34の例外群から構成されています。これらの例外群には、例外的なウィール群が含まれます。たとえば、`coxgroup(:E,8)` は `G₃₇` と同じです。

私たちは、単純根と単純コルートのリストを与えることによって（[`PRG`](@ref) を参照）、または分類に基づいて（[`complex_reflection_group`](@ref) を参照）、任意の有限反射群を構築するための関数を提供します。たとえば、ウィール群の文脈では、選択された特定の根系を従来の結晶根系の分類に基づいて説明したいと考えます。これは、関数 [`coxeter_group`](@ref) への呼び出しを介して行われます（モジュール [`Weyl`](@ref) を参照）。非実反射群のための良い根の集合を構築するための一般的な理論はまだ存在しません。ここで選択された根はケースバイケースで得られましたが、いくつかの重要な特性を満たしています：

  * 単純反射は、`W` に関連するブレイド群を示すブレイド関係を満たします（[`diagram`](@ref) を参照）。
  * `W` の *定義体* は、`V` 上で作用する `W` の要素のトレースによって生成される体 `K` です。`W` は `K` 上の反射群として実現できるという定理があります。
  * 単純根とコルートに対して `rᵛ(r')` のカルタン行列は、`K` の整数の環 `ℤₖ` にエントリを持ち、他の根（およびコルート）は、線形独立な部分集合の係数が `ℤₖ` の線形結合です。

すべての `W` の表現は、定義体 `K` 上で定義されることが判明しました（[Benard1976](biblio.htm#Ben76) および D.~Bessis の論文を参照）。これは、`K=ℚ` の場合、すなわちウィール群のケースでは、すべての表現が整数であることが長い間知られていました。

```julia-repl
julia> W=complex_reflection_group(4)
G₄

julia> gens(W) # 24根の置換として
2-element Vector{Perm{Int16}}:
 (1,3,9)(2,4,7)(5,10,18)(6,11,16)(8,12,19)(13,15,20)(14,17,21)(22,23,24)
 (1,5,13)(2,6,10)(3,7,14)(4,8,15)(9,16,22)(11,12,17)(18,19,23)(20,21,24)

julia> length(unique(refls(W)))
4

julia> length(refls(W)) # 24=4*(ℚ の単位根の数 (ζ₃))
24

julia> reflrep(W) # 行列としての生成元
2-element Vector{Matrix{Cyc{Rational{Int64}}}}:
 [1 0; 0 ζ₃]
 [√-3/3 -ζ₃²√-3/3; (-3+√-3)/3 -ζ₃√-3/3]
```

ほとんどすべての不可約複素反射群に対して、私たちが与える `W` の生成行列は定義体 `K` の係数を持っています。さらに、`W` のすべての要素の行列の集合は、`K/ℚ` のガロア群の下で全体的に不変であるため、ガロア作用は `W` の自己同型を誘導します。例外は `G₂₂, G₂₇` で、行列は `K` の次数2の拡張にあります（これは、全体的に不変なモデルを持つために必要です。詳細は [MarinMichel2010](biblio.htm#MarinMichel10) を参照）。また、いくつかの二面体群、`H₃` および `H₄` も例外であり、与えられた行列（通常のコクセター反射表現）は全体的に不変ではありません（ただし、`chevieget(:H4,:InvariantModel)` によって不変なものを得ることができます）。

```julia-repl
julia> braid_relations(W) # 生成元の等しい単語のタプルとして
1-element Vector{Tuple{Vector{Int64}, Vector{Int64}}}:
 ([1, 2, 1], [2, 1, 2])

julia> diagram(W) # 同じ内容を図で
③ ——③ G₄
1   2

julia> cartan(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
 ζ₃²√-3     ζ₃²
   -ζ₃²  ζ₃²√-3

julia> simpleroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
    0  ζ₃²√-3
 2ζ₃²     ζ₃²

julia> simplecoroots(W)
2×2 Matrix{Cyc{Rational{Int64}}}:
     0      1
 √-3/3  √-3/3
```

`SV` を `V` の対称代数とします。`SV` における `W` の不変量は、`W` の *多項式不変量* と呼ばれます。`n=dim V` の場合、これらは `n` 個の同次代数的に独立な多項式 `f₁,…,fₙ` によって多項式環として生成されます。多項式 `fᵢ` は一意に決定されるわけではありませんが、その次数は決まっています。`fᵢ` は `W` の *基本不変量* と呼ばれ、その次数は `W` の *反射次数* と呼ばれます。関数 `degrees(W)` はこれらの不変量を返します。

`I` を `SV` における正の次数の同次不変量によって生成される理想とします。すると `SV/I` は、`W` モジュールとしての `W` の通常表現に同型です。したがって、これは `SV` の要素の次数によってグレーディングされた `W` の通常表現のバージョンです。グレーディングされたモジュール `SV/I` における `W` のキャラクター `φ` のグレーディングされた重複度を与える多項式は、`φ` の *擬似次数* と呼ばれます。関数 `fakedegrees` はこれらの多項式を返します。

```julia-repl
julia> degrees(W)
2-element Vector{Int64}:
 4
 6

julia> fakedegrees(W,Pol(:x))
7-element Vector{Pol{Int64}}:
 1
 x⁴
 x⁸
 x⁷+x⁵
 x⁵+x³
 x³+x
 x⁶+x⁴+x²
```
