一般的なコクセター群の理論に関する適切な参考文献は、例えば、ブルバキの「リー群とリー代数」第4章です。

*コクセター群*は、ある対称整数行列 `m(s,t)`（*コクセター行列*と呼ばれる）に対して、$W=⟨S|(st)^{m(s,t)}=1\text{  for  }s,t∈  S⟩$ という表現を持つ群です。ここで、`m(s,t)>1` は `s≠t` の場合に成り立ち、`m(s,s)=1` です；`m(s,t)=∞` は `s` と `t` の間に関係がないことを意味します。コクセター群において `st` の順序が正確に `m(s,t)` であることは真実であり（しかし非自明な定理です）、したがってコクセター群は*コクセター系*と同じであり、すなわち群 `W` と、群が生成子 `S` によって提示され、`S` の2つの要素の積の順序を記述する関係を持つ集合 `S⊂W` の対 `(W,S)` です。

コクセター群は、次元 `length(S)` の実ベクトル空間 `V` 上に自然な表現、すなわち*反射表現*を持ちます（これは `W` の*コクセター階数*です）。ここで、`S` の各要素は反射として作用します。この表現の忠実性（ティッツの定理）は、`st` の順序が正確に `m(s,t)` であることを証明するための主な議論です。この表現は、`s∈ S` に対して、基底 `{eₛ}` を持つ空間 `V` 上で次のように定義されます。コクセター行列 `m(s,t)` に関連する*カータン行列*は、`C` という行列で、エントリは `C(s,t)=-2cos(π/m(s,t))` です；`m(s,t)=∞` の場合は `C(s,t)=-2` と設定します。次に、`s∈ S` の `V` 上の作用は `s(eₜ)=eₜ-C(s,t)eₛ` で与えられます。

したがって、コクセター群は実反射群です。反射超平面の集合が悪い位相的性質を持つ場合、逆は必ずしも真ではありませんが、有限コクセター群は有限実反射群と同じであることがわかります。有限コクセター群の可能なコクセター行列は完全に分類されており、[`Weyl`](@ref) を参照してください；対応する有限群は数学のいくつかの分野で深い役割を果たします。

コクセター群は単語問題に対して素晴らしい解決策を持っています。要素 `w∈ W` の*長さ* `l(w)` は、それが生成子 `S` の最小数の要素の積であることを示します（`S` の要素は反転であるため、逆は必要ありません）。最小長さの `w` の表現は、`w` の*簡約単語*と呼ばれます。簡約単語の主な性質は*交換補題*であり、これは `s₁…sₖ` が `w` の簡約単語である場合（したがって `k=l(w)`）、`s∈ S` が `l(sw)≤l(w)` であるならば、`w` の単語の中の `sᵢ` の1つを削除して `sw` の簡約単語を得ることができると述べています。したがって、`s∈ S` と `w∈ W` が与えられた場合、`l(sw)=l(w)+1` または `l(sw)=l(w)-1` のいずれかが成り立ち、後者の場合、`s` は `w` の*左降下集合*に属すると言います。要素の簡約単語を計算することや他の単語問題は、要素の乗法と左降下集合を知っていれば簡単です。私たちが実装する各コクセター群では、左降下集合は計算が容易です（例えば、以下の [`coxeter_symmetric_group`](@ref) を参照してください）。したがって、コクセター群を一般的に扱う方法が示唆されます：

型 `CoxeterGroup` は抽象型です；これを実装する実際の構造体は、次の関数を定義する必要があります。

`isleftdescent(W,w,i)` は、`S` の `i` 番目の要素が `w` の左降下集合に含まれているかどうかを示します。

コクセター群のインスタンスに必要な他の関数は次のとおりです。

  * `gens(W)` は集合 `S`（*コクセター生成子*のリスト）を返します。
  * `nref(W)` は `W` が有限の場合は `W` の反射の数を返し、`W` が無限の場合は `nothing` を返します。

コクセター群は、上記の関数を実装する*任意の*種類の群であることに注意すべきです。

コクセター群における単語問題の簡単な解決策のため、要素をコクセター生成子の単語として表現する便利な方法は、すなわち `1:length(S)` の整数のリストです。関数 'word' と 'W(...)' は、コクセター単語と群の要素の間の変換を行います。

# 例

```julia-repl
julia> W=coxsym(4)
𝔖 ₄

julia> p=W(1,3,2,1,3)
(1,4)

julia> word(W,p)
5-element Vector{Int64}:
 1
 2
 3
 2
 1
```

私たちは、最初に始めた単語と最終的に得た単語が同じでないことに気付きますが、両方とも `W` の同じ要素を表しています。その理由は、`W` の要素に対していくつかの簡約単語が存在するためです。関数 'word' は `w` の辞書順で最小の単語を計算します。以下は、同じコクセター群を使用した他の可能な計算です：

```julia-repl
julia> word(W,longest(W))  # W の (唯一の) 最長要素
6-element Vector{Int64}:
 1
 2
 1
 3
 2
 1

julia> w0=longest(W)
(1,4)(2,3)

julia> length(W,w0)
6
julia> map(w->word(W,w),refls(W,1:nref(W)))
6-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [1, 2, 1]
 [2, 3, 2]
 [1, 2, 3, 2, 1]
julia> [length(elements(W,i)) for i in 0:nref(W)]
7-element Vector{Int64}:
 1
 3
 5
 6
 5
 3
 1
```

最後のリストは、長さ0の要素が1つ、長さ3の要素が6つあることを示しています。

ほとんどの基本関数において、入力はコクセター単語ではなく群の要素であるという慣習があります。これは、コクセター群が置換群である場合、置換のための低レベル関数を使用する方が、簡約表現を表すリストを操作するよりも通常ははるかに速いためです。

このモジュールで実装されている唯一のコクセター群コンストラクタは `coxsym` と `coxgroup` です；最後のコンストラクタはカータン行列を取り、対応するコクセター群を行列群として構築します。モジュール [`Weyl`](@ref) は、与えられた型の置換群として有限コクセター群を構築するための `coxgroup` の他のメソッドを定義しています。
