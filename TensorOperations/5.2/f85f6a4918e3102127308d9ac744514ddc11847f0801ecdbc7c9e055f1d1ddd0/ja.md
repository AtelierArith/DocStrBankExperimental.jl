```
@tensoropt(optex, block)
@tensoropt(block)
```

アインシュタインのインデックス表記を使用して、1つ以上のテンソル演算を指定します。インデックスは任意のJulia変数名または整数を選択できます。複数のテンソルを一緒に収束させる場合、マクロは個々のインデックスに関連するコストに基づいて、最適な収束順序をコンパイル時に決定します。`optex`が提供されていない場合、すべてのインデックスは抽象的なスケーリング`χ`を持つと仮定され、`χ`が大きい漸近的な制限で最適化されます。

コストは以下の方法で指定できます：

```julia
# すべてのインデックス (a, b, c, d, e, f) のコスト χ
@tensoropt D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]

# インデックス (a, b, c, e) の漸近的コスト χ、他のインデックス (d, f) のコストは 1
@tensoropt (a, b, c, e) C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]

# インデックス (a, b, c, e) のコストは 1; 他のインデックス (d, f) の漸近的コストは χ
@tensoropt !(a, b, c, e) C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]

# リストされたインデックスのコストは指定され、リストされていないインデックスのコストは 1 (χの任意のシンボルを使用できます)
@tensoropt (a => χ, b => χ^2, c => 2 * χ, e => 5) begin
    C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]
end
```

`@tensoropt`は、（ブロックの）式の中で遭遇する任意のテンソル収束シーケンスを最適化します。ただし、明示的に括弧でグループ化された式を分解することはありません。つまり、

```julia
@tensoropt C[a, b, c, d] := A[a, e, c, f, h] * (B[f, g, e, b] * C[g, d, h])
```

では、常に`B`と`C`が最初に収束します。単一のテンソル収束シーケンスの場合、最適な収束順序と関連する（漸近的な）コストは`@optimalcontractiontree`を使用して取得できます。
