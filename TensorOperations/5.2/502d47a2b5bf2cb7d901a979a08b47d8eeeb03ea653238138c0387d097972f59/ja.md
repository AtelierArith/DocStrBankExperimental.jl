```
@tensor(tensor_expr; kwargs...)
@tensor [kw_expr...] tensor_expr
```

Einsteinのインデックス表記を使用して1つ以上のテンソル演算を指定します。インデックスは任意のJulia変数名または整数を選択できます。複数のテンソルを一緒に収束させる場合、これは左から右の順序でペアワイズ収束として評価されます。ただし、いわゆるNCONスタイルが使用されている場合（収束インデックスには正の整数、オープンインデックスには負のインデックスを使用）。

パーサーの動作を制御するために追加のキーワード引数を渡すことができます：

  * `order`:    収束インデックスのリストで、`order=(...,)`の形式で収束の順序を指定します。
  * `opt`:   収束順序の最適化、[`@tensoropt`](@ref)に似ています。ブール値または`OptExpr`のいずれかにすることができます。
  * `contractcheck`:   インデックスの収束可能性をランタイムでチェックするためのブールフラグで、より明確なエラーメッセージを提供します。
  * `costcheck`:   `:warn`または`:cache`のいずれかにすることができ、コンパイル時の収束順序と実際のランタイムテンソルコストに対して計算された最適順序を比較するためのランタイムチェックを追加します。`costcheck == :warn`の場合、遭遇したすべての最適でない収束に対して警告が表示されます。`costcheck == :cache`の場合、特定の最適でない収束の最もコストのかかる実行のみが`TensorOperations.costcache`にキャッシュされます。いずれの場合も、最適な収束順序に切り替えるための`order`キーワード引数の提案が計算されます。
  * `backend`:    生成されたコード内の異なるテンソル操作呼び出しに最終引数として実装バックエンドを挿入します。
  * `allocator`:   生成されたコード内のテンソル割り当て呼び出しに最終引数として割り当て戦略を挿入します。
