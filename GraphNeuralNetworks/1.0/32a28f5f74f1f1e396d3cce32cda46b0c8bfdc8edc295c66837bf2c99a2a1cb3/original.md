```
GNNRecurrence(cell)
```

Construct a recurrent layer that applies the graph recurrent `cell` forward multiple times to process an entire temporal sequence of node features at once.

The `cell` has to satisfy the following interface for the forward pass:  `yt, state = cell(g, xt, state)`, where `xt` is the input node features, `yt` is the updated node features, `state` is the cell state to be updated.

# Forward

```
layer(g, x, [state])
```

Applies the recurrent cell to each timestep of the input sequence.

## Arguments

  * `g`: The input `GNNGraph` or `TemporalSnapshotsGNNGraph`.

      * If `GNNGraph`, the same graph is used for all timesteps.
      * If `TemporalSnapshotsGNNGraph`, a different graph is used for each timestep. Not all cells support this.
  * `x`: The time-varying node features. 

      * If `g` is `GNNGraph`, it is an array of size `in x timesteps x num_nodes`.
      * If `g` is `TemporalSnapshotsGNNGraph`, it is an vector of length `timesteps`, with element `t` of size `in x num_nodes_t`.
  * `state`: The initial state for the cell.   If not provided, it is generated by calling `Flux.initialstates(cell)`.

## Return

Returns the updated node features:

  * If `g` is `GNNGraph`, returns an array of size `out_features x timesteps x num_nodes`.
  * If `g` is `TemporalSnapshotsGNNGraph`, returns a vector of length `timesteps`,  with element `t` of size `out_features x num_nodes_t`.

# Examples

The following example considers a static graph and a time-varying node features.

```jldoctest
julia> num_nodes, num_edges = 5, 10;

julia> d_in, d_out = 2, 3;

julia> timesteps = 5;

julia> g = rand_graph(num_nodes, num_edges);
GNNGraph:
  num_nodes: 5
  num_edges: 10

julia> x = rand(Float32, d_in, timesteps, num_nodes);

julia> cell = GConvLSTMCell(d_in => d_out, 2)
GConvLSTMCell(2 => 3, 2)  # 168 parameters

julia> layer = GNNRecurrence(cell)
GNNRecurrence(
  GConvLSTMCell(2 => 3, 2),             # 168 parameters
)                   # Total: 24 arrays, 168 parameters, 2.023 KiB.

julia> y = layer(g, x);

julia> size(y) # (d_out, timesteps, num_nodes)
(3, 5, 5)
```

Now consider a time-varying graph and time-varying node features.

```jldoctest
julia> d_in, d_out = 2, 3;

julia> timesteps = 5;

julia> num_nodes = [10, 10, 10, 10, 10];

julia> num_edges = [10, 12, 14, 16, 18];

julia> snapshots = [rand_graph(n, m) for (n, m) in zip(num_nodes, num_edges)];

julia> tg = TemporalSnapshotsGNNGraph(snapshots)

julia> x = [rand(Float32, d_in, n) for n in num_nodes];

julia> cell = EvolveGCNOCell(d_in => d_out)
EvolveGCNOCell(2 => 3)  # 321 parameters

julia> layer = GNNRecurrence(cell)
GNNRecurrence(
  EvolveGCNOCell(2 => 3),               # 321 parameters
)                   # Total: 5 arrays, 321 parameters, 1.535 KiB.

julia> y = layer(tg, x);

julia> length(y)    # timesteps
5

julia> size(y[end]) # (d_out, num_nodes[end])
(3, 10)
```
