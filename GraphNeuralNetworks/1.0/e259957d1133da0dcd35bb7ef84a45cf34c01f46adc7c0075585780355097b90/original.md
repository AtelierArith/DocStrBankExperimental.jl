"     EvolveGCNOCell(in => out; bias = true, init = glorot_uniform)

Evolving Graph Convolutional Network cell of type "-O" from the paper  [EvolveGCN: Evolving Graph Convolutional Networks for Dynamic Graphs](https://arxiv.org/abs/1902.10191).

Uses a [`GCNConv`](@ref) layer to model spatial dependencies, and an `LSTMCell` to model temporal dependencies. Can work with time-varying graphs and node features.

# Arguments

  * `in => out`: A pair where `in` is the number of input node features and `out`  is the number of output node features.
  * `bias`: Add learnable bias for the convolution and the lstm cell. Default `true`.
  * `init`: Weights' initializer for the convolution. Default `glorot_uniform`.

# Forward

```
cell(g::GNNGraph, x, [state]) -> x, state
```

  * `g`: The input graph.
  * `x`: The node features. It should be a matrix of size `in x num_nodes`.
  * `state`: The current state of the cell.   A state is a tuple `(weight, lstm)` where `weight` is the convolution's weight and `lstm` is the lstm's state.   If not provided, it is generated by calling `Flux.initialstates(cell)`.

Returns the updated node features `x` and the updated state.

```jldoctest
julia> using GraphNeuralNetworks, Flux

julia> num_nodes, num_edges = 5, 10;

julia> d_in, d_out = 2, 3;

julia> timesteps = 5;

julia> g = [rand_graph(num_nodes, num_edges) for t in 1:timesteps];

julia> x = [rand(Float32, d_in, num_nodes) for t in 1:timesteps];

julia> cell1 = EvolveGCNOCell(d_in => d_out)
EvolveGCNOCell(2 => 3)  # 321 parameters

julia> cell2 = EvolveGCNOCell(d_out => d_out)
EvolveGCNOCell(3 => 3)  # 696 parameters

julia> state1 = Flux.initialstates(cell1);

julia> state2 = Flux.initialstates(cell2);

julia> outputs = [];

julia> for t in 1:timesteps
           zt, state1 = cell1(g[t], x[t], state1)
           yt, state2 = cell2(g[t], zt, state2)
           outputs = vcat(outputs, [yt])
       end

julia> size(outputs[end]) # (d_out, num_nodes)
(3, 5)
```
