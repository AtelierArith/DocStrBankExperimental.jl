```
subs(p, s::AbstractSubstitution...)
```

`p`に対して置換`s`を適用します。すべての変数が`s`で置換されていることが確実な場合は、`p(s...)`を使用してください。

許可される置換は次のとおりです：

  * `v => p` ここで `v` は変数で、`p` は多項式です。例：`x => 1` または `x => x^2*y + x + y`。
  * `V => P` ここで `V` は変数のタプルまたはベクトルで、`P` は多項式のタプルまたはベクトルです。例：`(x, y) => (y, x)` または `(y, x) => (2, 1)`。

変数の順序は、TypedPolynomialsでは名前の辞書式順序、DynamicPolynomialsでは作成順序によります。変数の順序に保証がないため、タプルやベクトルを直接使用した置換は許可されていません。変数の順序が確実である場合（例：名前の順序が作成順序と一致する場合）は、`p(variables(p) => (1, 2))`を代わりに使用できます。

### 例

```julia
p = 3x^2*y + x + 2y + 1
p(x => 2, y => 1) # 戻り値の型は Int
subs(p, x => 2, y => 1) # 戻り値の型は TypedPolynomials では Int ですが、DynamicPolynomials では Int の係数を持つ多項式です
subs(p, y => x*y^2 + 1)
p(y => 2) # それはしないでください。これは TypedPolynomials では問題なく動作しますが、DynamicPolynomials では戻り値の型が `Int` であると考えるため、正しい結果を返しません。
```
