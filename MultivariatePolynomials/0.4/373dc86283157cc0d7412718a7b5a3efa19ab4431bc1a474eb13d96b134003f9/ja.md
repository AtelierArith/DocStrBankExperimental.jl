```
function gcd(p1::AbstractPolynomialLike{T}, p2::AbstractPolynomialLike{S}) where {T, S}
```

`p1` と `p2` の最大公約数を返します。一般的に、u と v の「最大公約数」について話すことは意味がありません; 最大公約数の集合があり、それぞれが他のものの単位倍数です [Knu14, p. 424]。

# 実装ノート

`gcd` を計算するための古典的なアルゴリズムは、ユークリッドアルゴリズムと呼ばれ、基本ケース `gcd(p, 0) = p` と関係 `gcd(p1, p2) = gcd(p2, rem(p1, p2))` を使用する再帰を用います。この関係はユークリッド除法から来ています: `p1 = q * p2 + r` の場合、もし `g` が `p1` と `p2` を割り切るなら、`r` も割り切り、もし `g` が `r` と `p2` を割り切るなら、`p1` も割り切ります。

多変数多項式の場合、`rem(p1, p2) = p1` となることがあるため、これでは終了しません。進展を確保するために、特定の変数 `xi` を選び、`q1` と `q2` を見つけるようにします。そうすれば、`q2 * p1 = q1 * p2 + r` となり、`r` の `xi` における次数は `p1` の `xi` における次数よりも厳密に小さくなります。`g` が `p1` と `p2` を割り切るなら、`r` も割り切りますが、`g` が `r` と `p2` を割り切る場合、`q2` を割り切るかもしれず、`p1` を割り切らないかもしれません。では、どうすればよいでしょうか？ `dj` を `pj` の `xi` における次数としましょう。`qj` を `xi^dj` における `pj` の係数と選ぶとします。もし `g` が `q2` を割り切るなら、`g` の `xi` における次数はゼロです。したがって、もし `g` が `p2` を割り切るなら、`xi^k` における `p2` の係数も割り切ります（`k = 0, 1, ..., d2`）。これにより、これらが互いに素であることを確保すれば、問題は発生しません。したがって、まず `pj` の各次数における係数の `gcd` `gj` を計算します。これを `pj` の [`content`](@ref) と呼びます。そして、`_gcd(p1 / g1, p2 / g2) * gcd(g1, g2)` を計算します。ここで、再帰 `_gcd(p1, p2) = _gcd(p2, q2 * p1 - q1 * p2)` を使用できます。ここで `q1, q2` は上で定義した通りです。これが [`GeneralizedEuclideanAlgorithm`](@ref) です。

[Knu14] Knuth, D.E., 2014. *Art of computer programming, volume 2: Seminumerical algorithms.* Addison-Wesley Professional. 第3版。
