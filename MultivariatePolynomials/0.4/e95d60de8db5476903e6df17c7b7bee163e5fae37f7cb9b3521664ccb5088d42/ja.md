```
subs(p, s::AbstractSubstitution...)
```

`p`に対して置換`s`を適用します。すべての変数が`s`で置換されていることが確実な場合は、`p(s...)`を使用してください。

許可される置換は次のとおりです：

  * `v => p` ここで、`v`は変数で、`p`は多項式です。例：`x => 1` または `x => x^2*y + x + y`。
  * `V => P` ここで、`V`は変数のタプルまたはベクトルで、`P`は多項式のタプルまたはベクトルです。例：`(x, y) => (y, x)` または `(y, x) => (2, 1)`。

変数の順序は、TypedPolynomialsでは名前の辞書式順序、DynamicPolynomialsでは作成順序に従います。変数の順序に保証がないため、タプルやベクトルを直接使用した置換は許可されていません。変数の順序が確実である場合（例：名前の順序が作成順序と一致する場合）は、`p(variables(p) => (1, 2))`を代わりに使用できます。

### 例

```julia
p = 3x^2*y + x + 2y + 1
p(x => 2, y => 1) # 戻り値の型はInt
subs(p, x => 2, y => 1) # 戻り値の型はTypedPolynomialsではIntですが、DynamicPolynomialsではInt係数の多項式です
subs(p, y => x*y^2 + 1)
p(y => 2) # それはしないでください。これはTypedPolynomialsでは正常に動作しますが、DynamicPolynomialsでは戻り値の型が`Int`であると考えるため、正しい結果を返しません。
```
