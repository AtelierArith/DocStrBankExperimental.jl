```
@espy function ... end
```

注釈付き関数コードから、注釈が削除された「クリーン」コードを生成し、呼び出し構文 `argout... = foo(argin...)` を使用します。また、入力および出力引数が追加された「エスパイ」コードを生成します。`argout...,res = foo(argin...,req)` の形式で、`req` は `@request` を使用して生成され、`res` は要求されたデータを含む `NamedTuple` と `NTuple` のネスト構造です。

このマクロは一般的ではなく、`residual` と `lagrangian` のために設計されており、パフォーマンスのために「不変」スタイルでプログラムされる必要があります。変数を決して変更してはいけません（これは特に、ガウスポイントのループ内で配列に追加しないことを意味します）。したがって、@espy はこのスタイルで必要な特定のプログラミング構造のみをサポートします。

以下は注釈付きコードの例です：

```
@espy function residual(x::Vector{R},y) where{R<:Real}
    ngp=2
    accum = ntuple(ngp) do igp
        ☼z = x[igp]+y[igp]
        ☼s,☼t  = ☼material(z)
        ♢square = s^2
        @named(s) 
    end
    r = sum(i->accum[i].s,ngp)
    return r,nothing,nothing
end
```

  * キーワード `function` の前にマクロ呼び出し `@espy` が付いています。
  * 要求可能な変数の名前の前には `☼`（`\sun`）が付いています。この注釈は常に代入の左側に現れなければなりません。
  * 変数の名前の前に `♢`（`\diamond`）が付いている場合、その変数は要求された場合にのみ評価されます。この注釈は、代入の左側に1つの変数しかない場合にのみ使用できます。
  * 呼び出される関数の名前は、関数の定義自体がマクロ呼び出し `@espy` によって前置されている場合、`☼` の前に付ける必要があります。
  * `for` ループはサポートされていません。`do` ループを使用する必要があります：効率的であるために、`residual` と `lagrangian` は割り当てを行わず、不変のものを使用しなければなりません。
  * キーワード `return` は明示的に使用されなければならず、出力変数のカンマ区切りリストに続かなければなりません。`return if...` のような構文はサポートされていません。

参照： [`@request`](@ref), [`@espydbg`](@ref), [`getresult`](@ref)
