```
DirectXUA{OX,OU,IA}
```

最適化FEMのための非線形直接ソルバーです。

分析は以下の構文での呼び出しによって実行されます：

```
initialstate    = initialize!(model)
stateXUA        = solve(DirectXUA{OX,OU,IA};initialstate,time=0:1.:5)
```

このソルバーはまだ内部点法をサポートしていません。

# パラメータ

  * `OX`                静的解析の場合は0                     時間における一次問題の場合は1（粘性、摩擦、速度の測定）                     時間における二次問題の場合は2（慣性、加速度の測定）
  * `OU`                未知の荷重プロセスの前にホワイトノイズの場合は0                     それ以外は2
  * `IA`                XU問題の場合は0（クラスAの変数は変更されません）                     XUA問題の場合は1

# 名前付き引数

  * `dbg=(;)`           呼び出しツリーを追跡するための名前付きタプル（デバッグ用）。
  * `verbose=true`      出力を抑制するにはfalseに設定します（テスト用）。
  * `silenterror=false` エラーの出力を抑制するにはtrueに設定します（テスト用）。
  * `initialstate`      `State`。
  * `time`              ステップを計算する時間の`AbstractRange`。 例：0:0.1:5。
  * `maxiter=50`        ニュートン-ラフソン反復の最大数。
  * `maxΔλ=1e-5`        収束基準：スケーリングされた`Λ`増分のノルム。
  * `maxΔx=1e-5`        収束基準：スケーリングされた`X`増分のノルム。
  * `maxΔu=1e-5`        収束基準：スケーリングされた`U`増分のノルム。
  * `maxΔa=1e-5`        収束基準：スケーリングされた`A`増分のノルム。
  * `saveiter=false`    出力`state`がベクトル（反復ごと）であり、モデルの`State`のベクトル（ステップごと）であるようにtrueに設定します（非収束のデバッグ用）。

以下のフラグを`true`に設定すると、システムのスパース性が向上します。ただし、条件が満たされていないときにフラグを`true`に設定すると、ヘッセ行列が誤ってしまい、収束に悪影響を及ぼします。

  * `Xwhite=false`      応答測定誤差がホワイトノイズプロセスである場合は`true`。
  * `XUindep=false`     応答測定誤差が`U`に依存しない場合は`true`。
  * `UAindep=false`     `U`が`A`に依存しない場合は`true`。
  * `XAindep=false`     応答測定誤差が`A`に依存しない場合は`true`。

# 出力

これらの各ステップで最適化されたモデルの状態を含む、`time`の長さと等しいベクトル。

参照： [`solve`](@ref), [`SweepX`](@ref)
