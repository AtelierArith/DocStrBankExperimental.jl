```
hc_partition_groups(X::AbstractMatrix; [cutoff], [min_clusters], [force_contiguous])
hc_partition_groups(Σ::Symmetric; [cutoff], [min_clusters], [force_contiguous])
```

個々のレベルデータ `X` または相関行列 `Σ` に基づいて、指定されたリンクを使用して階層的クラスタリングを行い、グループのパーティションを計算します。

# 入力

  * `X`: `n × p` データ行列。各行はサンプルです。
  * `Σ`: `p × p` 相関行列。`Symmetric` 引数でラップする必要があります。そうでない場合、個々のレベルデータとして扱います。
  * `cutoff`: クラスタリング結果がカットされる高さの値、0 と 1 の間 (デフォルトは 0.5)。これにより、2 つのグループ間の変数の相関が `cutoff` を超えないことが保証されます。1 はグループ化されていない構造を回復し、0 はすべてが単一のグループに対応します。
  * `min_clusters`: 希望するクラスタの数。
  * `linkage`: 使用する *クラスタリンク* 関数 ( `force_contiguous=true` の場合、`linkage` は `:single` でなければなりません)。`linkage` は、データポイント間の距離がクラスタ間の距離にどのように集約されるかを定義します。これは、各イテレーションでどのクラスタがマージされるかに影響します。有効な選択肢は次のとおりです：

      * `:single` (デフォルト): クラスタメンバーのいずれかの最小距離を使用
      * `:average`: クラスタメンバーのいずれかの平均距離を使用
      * `:complete`: メンバーのいずれかの最大距離を使用
      * `:ward`: 距離は、2 つのクラスタをマージした後のポイントとそのクラスタ重心との平均二乗距離の増加です
      * `:ward_presquared`: `:ward` と同じですが、d の距離がすでに二乗されていると仮定します。
  * `rep_method`: 各グループの代表者を選択する方法。オプションは `:id` (おおよそ独立した変数を選択する傾向がある) または `:rss` (より相関のある変数を選択する傾向がある) です。

`force_contiguous = false` で、`min_clusters` と `cutoff` の両方が指定されている場合、クラスタの数が `min_clusters` より少なくならず、その高さが `cutoff` を超えないことが保証されます。`force_contiguous = true` の場合、`min_clusters` キーワードは無視されます。

# 出力

  * `groups`: 各変数のグループメンバーシップの長さ `p` のベクトル
  * `group_reps`: 代表者として選択された X の列。各グループは最大 `nrep` の代表者を持ちます。これらは通常、非常に大きなグループのために小さなグループのノックオフを構築するために使用されます。
