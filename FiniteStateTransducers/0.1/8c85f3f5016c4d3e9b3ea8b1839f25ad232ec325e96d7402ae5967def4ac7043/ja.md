`DFS(fst::WFST, initial; filter=arc->true)`

`fst`から状態`initial`を起点に深さ優先探索（DFS）を行うイテレータを作成します。関数フィルタは、ユーザー定義のプロパティを持つアークを無視して探索を行うために指定できます。

各イテレータに対して、タプル`(p,s,n,d,e)`が返されます。ここで：

  * `p`は親の親状態（親がいない場合はp==0）
  * `s`は現在の状態
  * `n`次の状態：`s`にアークがない場合や完全に探索された場合は`n==0`。これにより標準的なDFSの反復が得られます。
  * `d`は`Bool`：`true`の場合は新しい状態が発見されたことを意味し、DFSのピックアップに使用できます（以下の例を参照）
  * `e`は`Bool`、`true`の場合はすべてのアークが検査されたことを意味します
  * `a`は検査されたアーク（`d == false`の場合は空）

以下のケース/色が可能です：

  * `d == false && n ==0` -> 黒状態、状態は完全にチェックされています
  * `d == false && n !=0` -> `n`はすでに灰色です
  * `d == true -> n` 状態は灰色に色付けされており、つまり初めて訪問されています

# 例

```julia
julia> fst = WFST(Dict(1=>1));

julia> add_arc!(fst, 1, 2, 1, 1, 1.0);

julia> add_arc!(fst, 1, 5, 1, 1, 1.0);

julia> add_arc!(fst, 1, 3, 1, 1, 1.0);

julia> add_arc!(fst, 2, 6, 1, 1, 1.0);

julia> add_arc!(fst, 2, 4, 1, 1, 1.0);

julia> add_arc!(fst, 5, 4, 1, 1, 1.0);

julia> add_arc!(fst, 3, 4, 1, 1, 1.0);

julia> add_arc!(fst, 3, 7, 1, 1, 1.0);

julia> initial!(fst,1)
WFST #states: 7, #arcs: 8, #isym: 1, #osym: 1
|1/0.0f0|
1:1/1.0f0 → (2)
1:1/1.0f0 → (5)
1:1/1.0f0 → (3)
(2)
1:1/1.0f0 → (6)
1:1/1.0f0 → (4)
(3)
1:1/1.0f0 → (4)
1:1/1.0f0 → (7)
(4)
(5)
1:1/1.0f0 → (4)
(6)
(7)

julia> dfs = FiniteStateTransducers.DFS(fst,1); # 状態1から始まるDFS

julia> for (p,s,n,d,e,a) in dfs
         println("$p,$s,$n")
         if d == true
           println("初めて訪問中 $n (灰色)")
         else
           if e
             println("完了した状態 $s (黒)")
           else
             println("ノード $n はすでに訪問済み")
           end
         end
       end
0,1,2
初めて訪問中 2 (灰色)
1,2,6
初めて訪問中 6 (灰色)
2,6,0
完了した状態 6 (黒)
1,2,4
初めて訪問中 4 (灰色)
2,4,0
完了した状態 4 (黒)
1,2,0
完了した状態 2 (黒)
0,1,5
初めて訪問中 5 (灰色)
1,5,4
ノード 4 はすでに訪問済み
1,5,0
完了した状態 5 (黒)
0,1,3
初めて訪問中 3 (灰色)
1,3,4
ノード 4 はすでに訪問済み
1,3,7
初めて訪問中 7 (灰色)
3,7,0
完了した状態 7 (黒)
1,3,0
完了した状態 3 (黒)
0,1,0
完了した状態 1 (黒)

```
