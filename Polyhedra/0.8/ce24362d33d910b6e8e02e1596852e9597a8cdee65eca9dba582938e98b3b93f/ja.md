```
detect_new_linearities(rep::HRepresentation{T}, solver; verbose=0, tol=Base.rtoldefault(T)) where {T}
```

H表現 `rep` を持つ多面体が与えられたとき、`solver` によって解かれた線形プログラムを使用して、`halfspaces` の半空間から新しい超平面を生成できるかどうかを検出します。このメソッドは、以下に説明する線に対して使用されるメソッドに似ています。この関数は、ソルバーが提供されている場合、`removehredundancy` によって自動的に呼び出されます。

```
detect_new_linearities(rep::VRepresentation{T}, solver; verbose=0, tol=Base.rtoldefault(T)) where {T}
```

V表現 `rep` によって定義された円錐が与えられたとき（表現内の点は無視します）、`rays` の光線から新しい線を生成できるかどうかを、`solver` によって解かれた線形プログラムを使用して検出します。メソッドは次のとおりです（簡単のために `lines` は空であると仮定します）。この関数は、ソルバーが提供されている場合、`removevredundancy` によって自動的に呼び出されます。

キーワード引数 `tol` は、数がゼロであるかどうかを判断するための許容誤差として使用されます。

円錐内に線 `l` があった場合、それは `μ >= 0` および `ν >= 0` が存在し、`Σ μ_i r_i = l` および `Σ ν_i r_i = -l` であることを意味します。これから、`Σ λ_i r_i = 0` であることが導かれます。ここで `λ = μ + ν` です。

逆に、`Σ λ_i r_i = 0` となる `λ >= 0` がある場合、`λ` の最大の絶対値を持つインデックスを `j` とします（それがゼロでないことを確認するため）。我々は `Σ_{i != j} λ_i/λ_j r_i = -r_j` を得ます。`r_j` と `-r_j` の両方が円錐内にあるため、`r_j` は円錐内に線を生成します。しかし、これは今や `Σ_{i != j} λ_i/λ_j r_i ≡ 0 (mod r_j)` であることを意味し、他に非ゼロの値を持つ `λ_i` があれば、それも線に変換できます。要約すると、`λ_i != 0` である各 `i` に対して線 `r_i` を持っています。

双対プログラムは次のとおりです：

```
max z
s.t. r_i'x ≥ z
```

プライマルが実行可能な場合、双対プログラムは依然として実行可能である可能性があります。強双対性により、目的関数の値はゼロである必要があるため、`z = 0` であることがわかります。したがって、制約は `r_i'x ≥ 0` です。もし `r_i'x > 0` である `i` がある場合、それは `-r_i` が円錐に属さないことを意味し、したがって線を探す目的で `r_i` を削除できます。

## 注意

CDDLib では、双対プログラムが解かれ、目的関数の値がゼロであれば、`r_i'x = 0` となる各 `i` に対して、`-r_i` が円錐に属するかどうかを確認するために LP を解きます。CDDLib は、各光線に対して LP を解く必要なく線形性を直接与える `λ` で提供されるプライマルの結果を無視します。したがって、Polyhedra に実装されたメソッドは、複雑さが `O(dimension of linespace)` であり、`O(fulldim)` に上限されるため、はるかに効率的です。一方、CDDLib のメソッドは `O(number of rays)` です。 ```
