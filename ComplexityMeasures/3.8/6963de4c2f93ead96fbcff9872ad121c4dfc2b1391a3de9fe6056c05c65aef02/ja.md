```
SpatialOrdinalPatterns <: OutcomeSpaceModel
SpatialOrdinalPatterns(stencil, x; periodic = true)
```

空間的順序パターンは、[`OutcomeSpace`](@ref) のための記号的な置換ベースのもので、空間時間システムに対して [`OrdinalPatterns`](@ref) を高次元配列に一般化します。置換パターンの順序 `m` は `stencil` から抽出されます。以下を参照してください。

`SpatialOrdinalPatterns` は、[Ribeiro2012](@citet) と [Schlemmer2018](@citet) による2Dおよび3Dの*空間時間置換エントロピー*推定器に基づいていますが、ここでは `D` 次元の入力配列 `x` に対して一般化された純粋な確率推定器として実装されています。任意の領域（ステンシル）を使用してパターンを形成し、（場合によっては）周期的境界条件を持ちます。

`stencil` を指定する方法については以下を参照してください。`periodic = true` の場合、ステンシルは配列の端でラップします。`false` の場合、配列の境界を超えるインデックスを持つ収集された領域はスキップされます。

[`information`](@ref) および [`information_normalized`](@ref) と組み合わせることで、この確率推定器は任意のタイプの一般化された空間時間置換 [`InformationMeasure`](@ref) を計算するために使用できます。

## 結果空間

`SpatialOrdinalPatterns` の結果空間 `Ω` は、整数 `1, 2, …, m` によって形成される長さ `m` の順序パターン（すなわち置換）の集合です。これらのパターンは辞書順に並べられます。ここで `m` は `stencil` に含まれるポイントの数を指します。

## ステンシル

`stencil` は、ハイパーボクセルをグループ化するために使用するローカルエリアを定義します。各ハイパーボクセルのグループ化は、順序 `m` の置換パターンにマッピングされ、その後 [`OrdinalPatterns`](@ref) のように整数にマッピングされます。`stencil` は入力配列の周りを移動し、入力配列を「スキャン」することで、境界条件（周期的または非周期的）によって許可されるすべての可能なグループ化を収集します。

ステンシルは以下の3つの方法のいずれかで渡されます：

1. ステンシルに含めるインデックスのオフセットをエンコードする `CartesianIndex` のベクトルとして。例えば `stencil = CartesianIndex.([(0,0), (0,1), (1,1), (1,0)])`。ハイパーボクセル自体を含めたい場合は、ゼロオフセットインデックスを含めることを忘れないでください。ここで、ステンシルはピクセルの下と右に拡張する2x2の正方形を作成します（ここでの方向は、Juliaがデフォルトで行列を印刷する方法に対応します）。`CartesianIndex` のベクトルとしてステンシルを渡す場合、`m = length(stencil)` です。
2. `0` と `1` を含む `D` 次元配列として（ここで `D` は入力データの次元数に一致します）。`stencil[index] == 1` の場合、対応するピクセルが含まれ、`stencil[index] == 0` の場合は含まれません。1. と同じ推定器を生成するには、`stencil = [1 1; 1 1]` を使用します。`D` 次元配列としてステンシルを渡す場合、`m = sum(stencil)` です。
3. `D` 次元データ用の長さ `D` の2つの `Tuple` を含む `Tuple` として。最初のタプルはステンシルの `extent` を指定し、`extent[i]` は `i` 番目の軸に沿って含めるハイパーボクセルの数を決定し、`lag[i]` は同じ軸に沿ったハイパーボクセルの間隔を決定します。この方法では（ハイパー）長方形のステンシルのみを生成できます。前の例と同じ推定器を作成するには、ここで `stencil = ((2, 2), (1, 1))` を使用します。`extent` と `lag` を使用してステンシルを渡す場合、`m = prod(extent)` です。
