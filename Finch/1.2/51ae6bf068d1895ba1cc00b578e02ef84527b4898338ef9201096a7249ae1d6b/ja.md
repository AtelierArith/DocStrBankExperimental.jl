```
@finch [options...] prgm
```

フィンチプログラム `prgm` を実行します。フィンチプログラムの構文は、点ごとの配列代入に対するネストされたループ、ステートメント、および分岐のセットです。たとえば、次のプログラムは2つの配列の合計 `A = B + C` を計算します：

```julia
@finch begin
    A .= 0
    for i = _
        A[i] = B[i] + C[i]
    end
    return A
end
```

フィンチプログラムは、次の構文を使用して構成されます：

  * `arr .= 0`: 配列宣言で、arrをゼロに初期化します。
  * `arr[inds...]`: 配列アクセスで、配列は変数でなければならず、各インデックスは別のフィンチ式である場合があります。
  * `x + y`, `f(x, y)`: 関数呼び出しで、`x` と `y` はフィンチ式です。
  * `arr[inds...] = ex`: 配列代入式で、`arr[inds]` に `ex` の値を設定します。
  * `arr[inds...] += ex`: 増加配列式で、`ex` を `arr[inds]` に加えます。 `*, &, |` がサポートされています。
  * `arr[inds...] <<min>>= ex`: カスタム演算子を使用した増加配列式で、例えば `<<min>>` は最小演算子です。
  * `for i = _ body end`: インデックス `i` に対するループで、`_` は `body` 内の `i` を使用した配列アクセスから計算されます。
  * `if cond body end`: `cond` が真であるイテレーションのみを実行する条件分岐です。
  * `return (tnss...,)`: グローバルスコープでプログラムを終了し、テンソル `tnss` を新しい次元で返します。デフォルトでは、グローバルスコープで宣言された任意のテンソルが返されます。

シンボルは変数を表すために使用され、その値は環境から取得されます。ループはその本体のスコープにインデックス変数を導入します。

フィンチは配列の型とシンボリック分析を使用してプログラムの最適化を発見します。`B` と `C` がスパース配列型である場合、プログラムは非ゼロ要素のみに対してのみ実行されます。

意味的には、フィンチプログラムはすべてのイテレーションを実行します。ただし、フィンチはスパース情報を使用して、可能な場合にイテレーションを信頼性を持ってスキップできます。

`options` はオプションのキーワード引数です：

  * `algebra`: プログラムに使用する代数。デフォルトは `DefaultAlgebra()` です。
  * `mode`: プログラムに使用する最適化モード。可能なモードは：

      * `:debug`: バウンドチェックとより良いエラーハンドリングを伴うデバッグモードでプログラムを実行します。
      * `:safe`: パフォーマンスと正確性のための控えめなチェックを伴うセーフモードでプログラムを実行します。
      * `:fast`: チェックや警告なしでプログラムを高速モードで実行します。このモードはパワーユーザー向けです。

    デフォルトは `:safe` です。

参照： [`@finch_code`](@ref)
