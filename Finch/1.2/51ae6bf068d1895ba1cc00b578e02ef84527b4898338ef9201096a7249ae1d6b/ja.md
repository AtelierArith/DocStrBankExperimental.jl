```
@finch [options...] prgm
```

finchプログラム`prgm`を実行します。finchプログラムの構文は、点ごとの配列代入に対するネストされたループ、ステートメント、および分岐のセットです。たとえば、次のプログラムは2つの配列の合計を計算します `A = B + C`:

```julia
@finch begin
    A .= 0
    for i = _
        A[i] = B[i] + C[i]
    end
    return A
end
```

Finchプログラムは、次の構文を使用して構成されます：

  * `arr .= 0`: 配列宣言で、arrをゼロに初期化します。
  * `arr[inds...]`: 配列アクセスで、配列は変数でなければならず、各インデックスは別のfinch式である場合があります。
  * `x + y`, `f(x, y)`: 関数呼び出しで、`x`と`y`はfinch式です。
  * `arr[inds...] = ex`: 配列代入式で、`arr[inds]`を`ex`の値に設定します。
  * `arr[inds...] += ex`: 増分配列式で、`ex`を`arr[inds]`に加えます。`*, &, |`がサポートされています。
  * `arr[inds...] <<min>>= ex`: カスタム演算子を使用した増分配列式で、例えば`<<min>>`は最小演算子です。
  * `for i = _ body end`: インデックス`i`に対するループで、`_`は`body`内の`i`を使用した配列アクセスから計算されます。
  * `if cond body end`: `cond`が真であるイテレーションのみを実行する条件分岐です。
  * `return (tnss...,)`: グローバルスコープで、プログラムを終了し、テンソル`tnss`を新しい次元で返します。デフォルトでは、グローバルスコープで宣言された任意のテンソルが返されます。

シンボルは変数を表すために使用され、その値は環境から取得されます。ループはその本体のスコープにインデックス変数を導入します。

Finchは配列の型とシンボリック分析を使用してプログラムの最適化を発見します。`B`と`C`がスパース配列型である場合、プログラムは非ゼロ要素のみに対してのみ実行されます。

意味的には、Finchプログラムはすべてのイテレーションを実行します。ただし、Finchはスパース情報を使用して、可能な場合はイテレーションを信頼性を持ってスキップできます。

`options`はオプションのキーワード引数です：

  * `algebra`: プログラムに使用する代数。デフォルトは`DefaultAlgebra()`です。
  * `mode`: プログラムに使用する最適化モード。可能なモードは：

      * `:debug`: プログラムをデバッグモードで実行し、境界チェックとより良いエラーハンドリングを行います。
      * `:safe`: プログラムを安全モードで実行し、パフォーマンスと正確性のための控えめなチェックを行います。
      * `:fast`: プログラムを高速モードで実行し、チェックや警告は行わず、このモードはパワーユーザー向けです。

    デフォルトは`:safe`です。

参照： [`@finch_code`](@ref)
