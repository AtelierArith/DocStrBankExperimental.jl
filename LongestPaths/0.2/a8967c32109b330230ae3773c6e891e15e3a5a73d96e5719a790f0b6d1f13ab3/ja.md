```
find_longest_path(graph, first_vertex = 1, last_vertex = 0)
```

`first_vertex`から始まり`last_vertex`で終わる`graph`内の最長単純パスを見つけます。どの頂点も一度しか訪問できません。`last_vertex`が0の場合、パスはどこででも終わることができます。`first_vertex`は0にすることはできません。

```
find_longest_cycle(graph, first_vertex = 0)
```

`first_vertex`を含む`graph`内の最長単純サイクルを見つけます。どの頂点も一度しか訪問できません。`first_vertex`が0の場合、サイクルはどこにでも存在できます。

十分な時間とメモリがあれば、これらは最長パスまたはサイクルを見つけることに成功しますが、最長パス/サイクルを見つけることはNP困難な問題であるため、必要な時間はグラフのサイズに応じて急速に増加します。

当面の間、`graph`は`Graphs`パッケージからの**有向**グラフでなければなりません。このアルゴリズムは、両方向のエッジのペアで表現された無向グラフにも適用されます。

```
find_longest_path(...; kwargs)
find_longest_cycle(...; kwargs)
```

キーワード引数を追加することで、検索をガイドしたり、最適でない解や上限を短時間で得ることが可能です。

注意: 特に指定がない限り、以下ではパスとサイクルは「パス」と呼ばれ、常に単純であると仮定されます。すなわち、繰り返しの頂点は許可されません。

*キーワード引数:*

  * `weights`: 重み付き最長パス検索のためのエッジの重み。省略した場合、すべての重みは暗黙的に1になります。タプルを数値にマッピングする辞書として指定します。`(v1, v2) => w`は、`v1`から`v2`へのエッジの重みが`w`であることを意味します。
  * `initial_path`: 頂点のベクトルとしてパスを提供することで、検索をウォームスタートできます。提供された頂点が有効な単純パスに従わない場合、それらは無視されます。
  * `lower_bound`: ユーザー提供の下限。上限が`lower_bound`に達したとき、たとえその長さのパスが見つからなくても検索は停止します。検索中により強い上限が見つかった場合、提供された`lower_bound`は無視されます。
  * `upper_bound`: ユーザー提供の上限。下限が`upper_bound`に達したとき、たとえより長いパスが存在しても検索は停止します。検索中により強い下限が見つかった場合、提供された`upper_bound`は無視されます。
  * `solver_mode`: 検索は3つの異なるモード、`"lp"`、`"ip"`、または`"lp+ip"`で行うことができます。デフォルトの`"ip"`モードでは、整数プログラムが解かれます。これは遅くなる可能性がありますが、最終的には最適解を見つけることが保証されています。`"lp"`モードでは、線形プログラムの緩和のみが解かれます。これは長いパスを見つける可能性は低いですが、良い上限を迅速に見つけることができます。最終的な`"lp+ip"`モードは、`"lp"`と`"ip"`モードの間で交互に切り替わり、最適解を見つけるために`"ip"`のみよりも効率的な場合があります。
  * `cycle_constraint_mode`: 検索中に、パスに接続されていないサイクルが見つかり、整数プログラムや線形プログラムの緩和に制約を追加することで反復的に排除されます。この目的のために異なる種類の制約を追加でき、`cycle_constraint_mode`は`"cutset"`、`"cycle"`、または`"both"`に設定できます。デフォルトの`"cutset"`オプションが最良の選択である可能性が高いです。
  * `initial_cycle_constraints`: これをデフォルト値0より大きく設定することで、この数までの長さのすべてのサイクルが検索開始前に排除されます。これは必要な反復回数と各反復に必要な時間のトレードオフを提供します。これを3以上に設定することはおそらく無駄であり、0が最良の設定である可能性があります。
  * `max_iterations`: この数の反復後に検索を停止します。デフォルトは非常に高い数です。
  * `time_limit`: この数の秒後に検索を停止します。デフォルトは非常に高い数です。
  * `solver_time_limit`: 整数プログラムを解くために各反復で費やす最大時間。IPソルバーが許可された時間内に有用な解を見つけない場合、これは徐々に増加します。LP解はこのオプションの影響を受けず、常に最適性に解かれます。デフォルトは10秒です。
  * `max_gap`: IP解の許可されるギャップ。これは自動的に下限と上限の間の距離よりも小さくなるように減少します。デフォルトは0です。高い値は`"ip"`モードの初期反復を加速することができます。
  * `use_ip_warmstart`: 整数プログラムを解く際にウォームスタートを使用します。通常、これにより解決が大幅に加速されますが、Cbcソルバーがトレース出力を出力する原因にもなります。デフォルトはtrueです。
  * `log_level`: 検索中の冗長性の量。0は最大限静かです。デフォルト値1は各反復の進行状況のみを印刷します。高い値はIPソルバー呼び出しからの診断情報を追加します。
  * `new_longest_path_callback`: ここで提供された関数は、新しい最長パスが見つかるたびに呼び出されます。これは非常に長い検索の部分解を保存する機会を提供します。関数は、最長パスを頂点のベクトルとして表現した1つの引数を受け入れる必要があります。デフォルトは何もしない関数です。関数の戻り値は無視されます。
  * `iteration_callback`: ここで提供された関数は各反復中に呼び出されます。関数は診断情報を含む名前付きタプルを引数として受け取る必要があります。検索を続けるには`true`を返し、検索を停止するには`false`を返します。デフォルトは`print_iteration_data`関数です。
  * `preprocess`: 検索を開始する前にグラフを前処理するかどうか。デフォルトはtrueです。これにより、以下のステップが実行されます：

    1. 無向グラフを有向グラフに変換します。
    2. 自己ループを削除します。
    3. 最適解の一部になり得ない頂点とエッジを削除します。

    これを無効にする主な理由は、前処理が役に立たないとわかっている場合に時間やメモリを節約するためです。`preprocess`が有効な場合、`iteration_callback`と返される結果の内部は前処理されたグラフに関連しますが、頂点は提供された`vertex_mapping`を介して元のグラフにマッピングできます。
  * `reduce_unbranched`: 可能な限り隣接する2つの頂点を排除するようにグラフを最適化するかどうか。デフォルトはfalseです。これにより、無重みの検索が重み付き検索に変わります。`preprocess`に関する同様の注意が適用されます。

戻り値は`LongestPathOrCycle`型で、以下のフィールドを含みます：

  * `is_cycle`: 検索がサイクルを生成したかパスを生成したか。
  * `lower_bound`: 最長パスの長さの下限。
  * `upper_bound`: 最長パスの長さの上限。
  * `longest_path`: 見つかった最長パスの頂点のベクトル。
  * `internals`: 検索に関するさまざまな情報を含む辞書。

ノート：

  * パスの長さはエッジの数で報告され、頂点の数ではありません。サイクルの場合、これらは同じですが、パスの場合、エッジの数は頂点の数より1少なくなります。重み付き検索の場合、長さはパスに沿った重みの合計です。
  * パス検索で`first_vertex`からどこにも出て行くエッジがない場合、長さは0として報告され、返される`longest_path`には単一の頂点`first_vertex`が含まれます。これは`first_vertex == last_vertex`の場合も同様です。
  * 他の検索では、仕様に一致するパスやサイクルが存在しない場合、長さは0として報告され、返される`longest_path`は空です。
  * 重み付き検索では、重みが`Integer`型である場合、最適解が整数値であることを知っており、境界をより積極的に丸めることができます。
  * 重みはゼロまたは負である可能性があります。すべての重みが非正の場合、問題は実質的に最短パス問題に変わりますが、他の方法でかなり効率的に解決できます。
