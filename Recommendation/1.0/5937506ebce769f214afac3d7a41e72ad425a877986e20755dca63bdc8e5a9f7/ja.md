```
ItemKNN(
    data::DataAccessor,
    n_neighbors::Integer
)
```

[アイテムベースのCF](https://dl.acm.org/citation.cfm?id=963776)は、CFパラダイムにおけるアイテム間の類似性を利用してアイテム-アイテムの概念をモデル化する方法を提供します。`n_neighbors`は隣接するアイテムの数$k$を表します。

アイテムの特性はユーザーの嗜好に比べて比較的安定しており、アイテムの数は一般的にユーザーの数よりも少ないです。したがって、ユーザーに基づくCFがユーザーの複雑な嗜好の類似性をうまく捉える一方で、アイテム-アイテムの概念をモデル化することは、スケーラビリティと全体的な精度の両方の観点からはるかに有望である可能性があります。

アイテムベースのCFは、アイテム$i$と$j$の間の類似性を次のように定義します：

$$
s_{i,j} = \frac{ \sum_{u \in \mathcal{U}_{i \cap j}}  (r_{u, i} - \overline{r}_i) (r_{u, j} - \overline{r}_j)}
{ \sqrt{\sum_{u \in \mathcal{U}_{i \cap j}} (r_{u,i} - \overline{r}_i)^2} \sqrt{\sum_{u \in \mathcal{U}_{i \cap j}} (r_{u, j} - \overline{r}_j)^2} },
$$

ここで、$\mathcal{U}_{i \cap j}$は$r_{u,i}$と$r_{u, j}$の両方が欠損していないユーザーの集合であり、$\overline{r}_i, \overline{r}_j$は$R$の$i$-列目と$j$-列目の平均値です。ユーザーに基づくアルゴリズムと同様に、$t$-番目の最近傍アイテム$\tau(t)$について、予測はターゲットユーザーのフィードバックのトップ-$k$加重和によって行うことができます：

$$
r_{u,i} = \frac{\sum^k_{t=1} s_{i,\tau(t)} \cdot r_{u,\tau(t)} }{ \sum^k_{t=1} s_{i,\tau(t)} }.
$$

アイテムの数がユーザーよりも少ない場合、アイテムベースのCFはユーザーに基づくアプローチよりもより合理的な選択となる可能性があります。
