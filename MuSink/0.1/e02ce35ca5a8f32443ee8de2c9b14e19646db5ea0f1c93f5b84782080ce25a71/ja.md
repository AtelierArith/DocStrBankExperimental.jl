UMOT問題を解決するためのコア構造。`Problem`によって提供される静的プロパティ（ツリーのトポロジー、ターゲットおよび参照測定、コストおよびペナルティ関数）に加えて、`Workspace`は最適化問題のさまざまなパラメータと補助変数も格納します。

ワークスペースは、Sinkhorn反復の内部ループの高速実装によって動作します。これらの反復は、指数領域（高速だが、小さな正則化パラメータ`eps`では崩壊する）または対数領域（遅いが、小さな`eps`では安定している）で実行できます。領域はキーワード引数`logdomain`を介して指定できます。デフォルトは`logdomain = true`です。

### Sinkhornステップと更新ルール

`Workspace`を変更するSinkhornステップ（より正確には、ワークスペースに格納されたポテンシャルと補助α配列を変更するステップ）は、`step!`または`steps!`関数を介して便利に実行できます。ワークスペースの配列タイプ、コスト関数の特性（分離可能かどうか）、および動作領域（logdomainまたはexpdomain）に基づいて、特化したカーネルが使用されます。

更新の順序がアルゴリズムの安定性/収束に影響を与える可能性があるため、いくつかの異なる更新ルール（キーワード引数`stepmode`を介してアクセス可能）が実装されています：

  * `stepmode = :legacy`：ツリーを通るバックワードパス（すなわち、親から葉へのα配列の値を更新）に続いて、ポテンシャルも更新するフォワードパス（すなわち、葉から親へのα配列の値を更新）が行われます。この更新ルールは、元のUMOT原稿の著者によって提案されており、ほとんどの構成でうまく機能するようです。しかし、特定の状況では、更新ルールがツリーを通る情報の伝播を妨げ、ステップ内のポテンシャル更新が互いに認識しないまま残ることがあります。可能な結果は、収束を妨げる質量の振動です。この挙動はバリセンター問題（例えば、中心ノードが`rho = 0`を介して固定されたポテンシャルを持つ星型ツリーのトポロジー）で明示的です**IF**ルートノードが中心に設定されている場合。ルートノードがツリーの葉に設定されている場合、`stepmode = :legacy`は常に機能するはずです。
  * `stepmode = :stable`：ツリーを通るバックワードパスに続いて、ポテンシャルを更新する混合フォワード/バックワードパスが行われます。この更新ルールは、`:legacy`メソッドの問題を修正しますが、ステップごとにより多くの計算を必要とします。
  * `stepmode = :alternate`：ポテンシャルを更新する混合フォワード/バックワードパスのみが実行されます。この更新ルールは、`:legacy`メソッドと同じだけの計算をステップごとに使用します（すなわち、`:stable`メソッドよりも高速です）が、有害な情報の障壁に対して保護されるべきです。それでも、このメソッドはより攻撃的であり、したがって`:stable`よりも不安定性に対してより敏感である可能性があります。
  * `stepmode = :symmetric`：バックワードパスの後にフォワードパスが続きます。これらのパスは両方ともαの値のみを更新します。その後、すべてのポテンシャルが同時に更新されます。**この更新ルールは、2つ以上の測定に対して深刻に壊れており、変更または非推奨の対象となる可能性があります。**

### パラメータ

UMOT問題は、ユーザーによって選択されるいくつかのパラメータに依存しています。例えば、`eps`（エントロピー正則化の強さ）、`reach`（相互作用半径）、または`rho`（周辺ペナルティの強さ）などです。後者はノードごとに設定できます。ツリーの個々のエッジの重みを指定することも可能で、これはそのエッジに沿ったコスト関数のスケーリングに対応します。
