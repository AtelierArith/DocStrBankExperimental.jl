```
setulb(n, m, x, l, u, nbd, f, g, factr, pgtol, wa, iwa, task, iprint, csave, lsave, isave, dsave)
```

この関数は、L-BFGS-BのFortranサブルーチン`setulb`をラップし、作業配列`wa`と`iwa`を分割し、次に制約付き最適化問題を解決するために制限付きメモリBFGS法を使用して`mainlb`を呼び出します。

注意、`nmax`は解決される最大の問題の次元であり、`mmax`は使用される制限付きメモリ補正の最大数です。

# 引数

  * `n::Ref{Cint}`: 問題の次元。
  * `m::Ref{Cint}`: 制限付きメモリ行列を定義するために使用される変数メトリック補正の最大数。
  * `x::Vector{Cdouble}`: 長さnの解の近似。
  * `l::Vector{Cdouble}`: xの下限、長さn。
  * `u::Vector{Cdouble}`: xの上限、長さn。
  * `nbd::Vector{Cint}`: 変数に課せられた境界のタイプを表し、次のように指定する必要があります：

    1. nbd[i]=0 ならば x[i] は無制約です；
    2. nbd[i]=1 ならば x[i] は下限のみを持ちます；
    3. nbd[i]=2 ならば x[i] は下限と上限の両方を持ちます；
    4. nbd[i]=3 ならば x[i] は上限のみを持ちます。
  * `f::Ref{Cdouble}`: xにおける関数の値（最初のエントリではfは未指定です）。
  * `g::Vector{Cdouble}`: xにおける勾配の値（最初のエントリではgは未指定です）。
  * `factr::Ref{Cdouble}`: (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch のときに反復が停止します。ここで、epsmchはコードによって自動的に生成される機械精度です。factrの典型的な値：

      * 低精度の場合は1.e12；
      * 中程度の精度の場合は1.e7；
      * 非常に高精度の場合は1.e1。
  * `pgtol::Ref{Cdouble}`: max{|proj g*i | i = 1, ..., n} <= pgtol のときに反復が停止します。ここで、pg*iは投影勾配のi番目の成分です。
  * `wa::Vector{Cdouble}`: 長さ(2mmax + 5)nmax + 12mmax^2 + 12mmaxの作業配列。
  * `iwa::Vector{Cint}`: 長さ3nmaxの整数作業配列。
  * `task::Vector{Cuchar}`: この関数に入るときと退出するときの現在のジョブを示す長さ60の作業文字列。
  * `iprint::Ref{Cint}`: 出力の生成頻度とタイプを制御します：

    1. iprint<0 の場合、出力は生成されません；
    2. iprint=0 の場合、最後の反復で1行のみ印刷されます；
    3. 0<iprint<99 の場合、iprint反復ごとにfと|proj g|も印刷されます；
    4. iprint=99 の場合、nベクトルを除くすべての反復の詳細が印刷されます；
    5. iprint=100 の場合、アクティブセットの変更と最終的なxも印刷されます；
    6. iprint>100 の場合、xとgを含むすべての反復の詳細が印刷されます。
    7. iprint > 0 の場合、反復を要約するためにiterate.datファイルが作成されます。
  * `csave::Vector{Cuchar}`: 長さ60の作業文字列。
  * `lsave::Vector{Bool}`: 次元4の論理作業配列。`task` = NEW_X の場合、次の情報が利用可能です：

    1. lsave[1] == true の場合、初期Xは実行可能なセット内のその投影に置き換えられました；
    2. lsave[2] == true の場合、問題は制約付きです；
    3. lsave[3] == true の場合、各変数には上限と下限があります。
  * `isave::Vector{Cint}`: 次元44の整数作業配列。`task` = NEW_X の場合、次の情報が利用可能です：

    1. isave[22] = Cauchy点の探索で探索された区間の総数；
    2. isave[26] = 現在の反復の前にスキップされたBFGS更新の総数；
    3. isave[30] = 現在の反復の番号；
    4. isave[31] = 現在の反復の前のBFGS更新の総数；
    5. isave[33] = 現在の反復のCauchy点の探索で探索された区間の数；
    6. isave[34] = 関数と勾配の評価の総数；
    7. isave[36] = 現在の反復の関数値または勾配評価の数；
    8. isave[37] = 0 の場合、部分空間argminはボックス内にあります；
    9. isave[37] = 1 の場合、部分空間argminはボックスの外にあります；
    10. isave[38] = 現在の反復の自由変数の数；
    11. isave[39] = 現在の反復のアクティブ制約の数；
    12. n + 1 - isave[40] = 現在の反復でアクティブ制約のセットを離れる変数の数；
    13. isave[41] = 現在の反復でアクティブ制約のセットに入る変数の数。
  * `dsave::Vector{Cdouble}`: 次元29の倍精度作業配列。`task` = NEW_X の場合、次の情報が利用可能です：

    1. dsave[1] = BFGS行列の現在の'theta'；
    2. dsave[2] = 前の反復におけるf(x)；
    3. dsave[3] = factr*epsmch；
    4. dsave[4] = 線形探索方向ベクトルの2ノルム；
    5. dsave[5] = コードによって生成された機械精度epsmch；
    6. dsave[7] = Cauchy点の探索に費やされた累積時間；
    7. dsave[8] = 部分空間最小化に費やされた累積時間；
    8. dsave[9] = 線形探索に費やされた累積時間；
    9. dsave[11] = 現在の線形探索の点における線形探索関数の傾き；
    10. dsave[12] = 線形探索で課せられた最大相対ステップ長；
    11. dsave[13] = 投影勾配の無限ノルム；
    12. dsave[14] = 線形探索における相対ステップ長；
    13. dsave[15] = 線形探索の開始点における線形探索関数の傾き；
    14. dsave[16] = 線形探索方向ベクトルの2ノルムの平方。

```
