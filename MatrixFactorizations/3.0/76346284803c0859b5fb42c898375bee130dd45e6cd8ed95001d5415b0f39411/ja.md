```
ql(A, pivot=Val(false)) -> F
```

行列 `A` の QL 因子分解を計算します：直交行列（または `A` が複素数値の場合はユニタリ行列）`Q` と、次のような下三角行列 `L` です。

$$
A = Q L
$$

返されるオブジェクト `F` は、パック形式で因子分解を格納します：

  * `F` は [`QL`](@ref) オブジェクトです。

分解の個々のコンポーネント `F` はプロパティアクセサを介して取得できます：

  * `F.Q`: 直交/ユニタリ行列 `Q`
  * `F.L`: 下三角行列 `L`

分解を反復すると、コンポーネント `Q`、`L`、および存在する場合は `p` が得られます。

`QL` オブジェクトに対して利用可能な関数は次のとおりです：[`inv`](@ref)、[`size`](@ref)、および [`\`](@ref)。`A` が長方形の場合、`\` は最小二乗解を返し、解が一意でない場合は最小ノルムのものが返されます。`A` がフルランクでない場合、最小ノルム解を得るために（列）ピボットを用いた因子分解が必要です。

フル/正方行列または非フル/正方行列 `Q` に関しての乗算が許可されています。すなわち、`F.Q*F.L` と `F.Q*A` の両方がサポートされています。`Q` 行列は [`Matrix`](@ref) を使用して通常の行列に変換できます。この操作は「薄い」Q 因子を返します。すなわち、`A` が `m`×`n` で `m>=n` の場合、`Matrix(F.Q)` は直交正規列を持つ `m`×`n` 行列を生成します。「フル」Q 因子を取得するには、`m`×`m` の直交行列を使用して `F.Q*Matrix(I,m,m)` を使用します。`m<=n` の場合、`Matrix(F.Q)` は `m`×`m` の直交行列を生成します。

# 例

```jldoctest
julia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia> F = ql(A)
LinearAlgebra.QLCompactWY{Float64,Array{Float64,2}}
Q 因子:
3×3 LinearAlgebra.QLCompactWYQ{Float64,Array{Float64,2}}:
 -0.6   0.0   0.8
 -0.8   0.0  -0.6
  0.0  -1.0   0.0
L 因子:
2×2 Array{Float64,2}:
 -5.0  10.0
  0.0  -1.0

julia> F.Q * F.L == A
true
```
