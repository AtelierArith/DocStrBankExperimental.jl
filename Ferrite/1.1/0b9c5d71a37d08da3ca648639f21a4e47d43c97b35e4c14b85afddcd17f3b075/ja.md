```
apply_zero!(K::SparseMatrixCSC, rhs::AbstractVector, ch::ConstraintHandler)
```

行列 `K` と右辺 `rhs` を調整して、指定されたディリクレ境界条件とアフィン制約を考慮し、`du = K \ rhs` が期待される結果を与えるようにします（例：指定された自由度に対して `du` がゼロになる）。

```
apply_zero!(v::AbstractVector, ch::ConstraintHandler)
```

指定された自由度に対応する `v` の値をゼロにし、アフィン制約によって指定された値を更新します。したがって、もし `a` が制約を満たすなら、`a ± v` も満たすことになります。

これらのメソッドは、例えばニュートンソルバーで使用されることが多く、増分 `du` は非均質境界条件であってもゼロに指定されるべきです。

参照: [`apply!`](@ref).

# 例

```julia
u = un + Δu                 # 現在の推測
K, g = assemble_system(...) # 現在の推測のための残差と接線を組み立てる
apply_zero!(K, g, ch)       # 指定された値を考慮して接線と残差を調整する
ΔΔu = K \ g                # （負の）増分を計算する、指定された値は「おおよそ」ゼロ
apply_zero!(ΔΔu, ch)        # 値が正確にゼロであることを確認する
Δu .-= ΔΔu                  # 現在の推測を更新する
```

!!! note
    最後の `apply_zero!` の呼び出しは、アフィン制約に対してのみ厳密に必要です。しかし、`apply!(K, g, ch)` の後にディリクレ境界条件が満たされるべきであっても、線形システムのソルバーは正確ではありません。`apply!(ΔΔu, ch)` を使用して、指定された自由度の値が正確に満たされることを確認できます。

