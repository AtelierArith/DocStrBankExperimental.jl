```
dep(m::ModelList, nsteps=1; verbose::Bool=true)
dep(mapping::Dict{String,T}; verbose=true)
```

モデルリストまたはマルチスケールモデルマッピングを与えられたときにモデル依存グラフを取得します。1つのグラフが返される場合、すべてのモデルは結合されています。複数のグラフが返される場合、各グラフ内のモデルのみが結合されており、異なるグラフ内のモデルは結合されていません。`nsteps`は依存グラフが使用されるステップ数です。これは、グラフ内の各ソフト依存関係の`simulation_id`引数の長さを決定するために使用されます。マルチスケールマッピングの場合は`1`に設定されます。

# 詳細

依存グラフは、各プロセスの入力をそのスケールの出力または他のスケールの出力の中から検索することによって計算されます。各モデル（1つのモデルが1つのプロセスをシミュレートします）には5つのケースがあります：

1. プロセスに入力がありません。それは完全に独立しており、依存グラフの根の1つとして配置されます。
2. プロセスは自分のスケールのモデルからの入力を必要とします。この他のプロセスの子として配置します。
3. プロセスは別のスケールからの入力を必要とします。この別のスケールのプロセスの子として配置します。
4. プロセスは自分のスケールと別のスケールの両方からの入力を必要とします。両方の子として配置します。
5. プロセスは別のプロセスのハード依存関係です（同じスケールでのみ可能）。この場合、プロセスは他のプロセスのハード依存関係として設定され、そのシミュレーションはこのプロセスから直接処理されます。

4番目のケースでは、プロセスには2つの親プロセスがあります。これは問題ありません。なぜなら、プロセスはシミュレーション中に1回だけ計算されるからです。両方の親が実行されたかどうかを確認してからプロセスを実行します。

5番目のケースでは、他のスケールから変数が必要かどうかを確認する必要があります。この場合、親ノードは他のスケールのプロセスの子として使用されます。ハード依存グラフには複数のレベルがある可能性があるため、これは再帰的に行われます。

これらすべてをどのように行うのでしょうか？まず、ハード依存関係を特定します。次に、必要に応じてハード依存関係の根の入力/出力を他のスケールにリンクします。次に、これらのノードをすべてソフト依存関係に変換し、Dict of Scale => Dict(process => SoftDependencyNode)に配置します。次に、これらをすべて横断し、他のノードから出力を必要とするノードを子/親として設定します。ノードに依存関係がない場合、それは根ノードとして設定され、新しいDict（independant*process*root）にプッシュされます。このDictが返される依存グラフです。そして、それは根ノードを独立したサブグラフの出発点として提示します。これらは結合されたモデルです。これらのグラフを独立して横断して、結合されたモデルを実行順序で取得できます。

# 例

```@example
using PlantSimEngine

# サンプルプロセスとモデルを含める：
using PlantSimEngine.Examples;

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

dep(models)

# またはプロセスを直接使用：
models = (
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
    process7=Process7Model(),
)

dep(;models...)
```
