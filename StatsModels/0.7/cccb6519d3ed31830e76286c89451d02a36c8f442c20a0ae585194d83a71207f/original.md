Interface to describe contrast coding systems for categorical variables.

Concrete subtypes of `AbstractContrasts` describe a particular way of converting a categorical data vector into numeric columns in a `ModelMatrix`. Each instantiation optionally includes the levels to generate columns for and the base level. If not specified these will be taken from the data when a `ContrastsMatrix` is generated (during `ModelFrame` construction).

# Constructors

For `C <: AbstractContrast`:

```julia
C()                                     # levels are inferred later
C(levels = ::Vector{Any})               # levels checked against data later
C(base = ::Any)                         # specify base level
C(levels = ::Vector{Any}, base = ::Any) # specify levels and base
```

# Arguments

  * `levels`: Optionally, the data levels can be specified here.  This allows you to specify the order of the levels.  If specified, the levels will be checked against the levels actually present in the data when the `ContrastsMatrix` is constructed. Any mismatch will result in an error, because levels missing in the data would lead to empty columns in the model matrix, and levels missing from the contrasts would lead to empty or undefined rows.
  * `base`: The base level may also be specified.  The actual interpretation of this depends on the particular contrast type, but in general it can be thought of as a "reference" level.  It defaults to the first level.

# Contrast coding systems

  * [`DummyCoding`](@ref) - Code each non-base level as a 0-1 indicator column.
  * [`EffectsCoding`](@ref) - Code each non-base level as 1, and base as -1.
  * [`HelmertCoding`](@ref) - Code each non-base level as the difference from the mean of the lower levels
  * [`SeqDiffCoding`](@ref) - Code for differences between sequential levels of the variable.
  * [`HypothesisCoding`](@ref) - Manually specify contrasts via a hypothesis matrix, which gives the weighting for the average response for each level
  * [`StatsModels.ContrastsCoding`](@ref) - Manually specify contrasts matrix, which is directly copied into the model matrix.

The last two coding types, `HypothesisCoding` and `StatsModels.ContrastsCoding`, provide a way to manually specify a contrasts matrix. For a variable `x` with `k` levels, a contrasts matrix `M` is a `k×k-1` matrix, that maps the `k` levels onto `k-1` model matrix columns.  Specifically, let `X` be the full-rank indicator matrix for `x`, where `X[i,j] = 1` if `x[i] == levels(x)[j]`, and 0 otherwise. Then the model matrix columns generated by the contrasts matrix `M` are `Y = X * M`.

The *hypothesis matrix* is the `k-1×k` matrix that gives the weighted combinations of group mean responses that are represented by regression coefficients for the generated contrasts.  The contrasts matrix is the generalized pseudo-inverse (e.g. `LinearAlgebra.pinv`) of the hypothesis matrix. See [`HypothesisCoding`](@ref) or Schad et al. (2020) for more information.

# Extending

The easiest way to specify custom contrasts is with `HypothesisCoding` or `StatsModels.ContrastsCoding`.  But if you want to actually implement a custom contrast coding system, you can subtype `AbstractContrasts`.  This requires a constructor, a `contrasts_matrix` method for constructing the actual contrasts matrix that maps from levels to `ModelMatrix` column values, and (optionally) a `coefnames` method:

```julia
mutable struct MyCoding <: AbstractContrasts
    ...
end

contrasts_matrix(C::MyCoding, baseind, n) = ...
coefnames(C::MyCoding, levels, baseind) = ...
```

# References

Schad, D. J., Vasishth, S., Hohenstein, S., & Kliegl, R. (2020). How to capitalize on a priori contrasts in linear (mixed) models: A tutorial. *Journal of Memory and Language, 110*, 104038. https://doi.org/10.1016/j.jml.2019.104038
