```
τ, acf = autocov(t::AbstractVector, y::AbstractVector{T}, maxlag; normalize=false) where T <: Number
```

信号 `y` の自己共分散関数をサンプル時間 `t` で計算します。これは、信号が非等間隔でサンプリングされている場合に便利です。

`y` と `t` がベクトルのベクトルである場合、すべてのデータの acf が推定され、出力に連結されます。出力は常に2つの数値ベクトルです。

返されるベクトルは、遅延 `τ` における acf のサンプルです。`τ` には `t` のエントリ間の差が含まれますが、`autocov` の標準メソッドに供給される `lags` は比較するための `y` の *インデックス* 間の差です。結果は一般的に標準の `autocov` よりもノイズが多く、さらなる推定が必要になる場合があります。例えば、ガウス過程回帰や分位点回帰を用いることが考えられます。次の条件が成り立つべきです `mean(acf[τ.==0]) ≈ var(y)`。

# 引数:

  * `t`: サンプル位置/時間のベクトル
  * `y`: 信号
  * `maxlag`: ACF を計算するために `t` の2つの値間の最大差を指定します
  * `normalize`: false（デフォルト）の場合、動作は StatsBase の標準メソッドを模倣し、理論的な ACF がそうでない場合でも、ACF は自動的に高い遅延に対して減少します。`true` の場合、理論的な ACF が推定されます。`normalize = true` は、ACF の fft を取る際により鋭いスペクトル推定をもたらします。`true` の場合、大きな遅延に対して推定された ACF の分散は高くなることに注意してください。
