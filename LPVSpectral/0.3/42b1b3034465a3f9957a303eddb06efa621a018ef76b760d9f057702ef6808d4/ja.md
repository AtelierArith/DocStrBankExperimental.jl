```
τ, acf = autocor(t::AbstractVector, y::AbstractVector{T}, maxlag; normalize=false) where T <: Number
```

信号 `y` の自己相関関数をサンプル時間 `t` で計算します。これは、信号が非等間隔でサンプリングされている場合に便利です。

`y` と `t` がベクトルのベクトルである場合、すべてのデータのacfが推定され、出力に連結されます。出力は常に2つの数値ベクトルです。

返されるベクトルは、ラグ `τ` におけるacfのサンプルです。`τ` には `t` のエントリ間の差が含まれていますが、`autocov` の標準メソッドに供給される `lags` は、比較するための `y` の *インデックス* 間の差です。結果は一般的に標準の `autocov` よりもノイズが多く、さらなる推定が必要になる場合があります。例えば、ガウス過程回帰や分位点回帰を用いることが考えられます。次の条件が成り立つべきです `mean(acf[τ.==0]) ≈ var(y)`。

# 引数:

  * `t`: サンプル位置/時間のベクトル
  * `y`: 信号
  * `maxlag`: ACFを計算するために `t` の2つの値間の最大差を指定します
  * `normalize`: false（デフォルト）の場合、動作はStatsBaseの標準メソッドを模倣し、理論的なACFがそうでない場合でも、ACFは自動的に高いラグに対して減少します。`true` の場合、理論的なACFが推定されます。`normalize = true` は、ACFのfftを取る際により鋭いスペクトル推定をもたらします。`true` の場合、大きなラグに対して推定されたACFの分散は高くなることに注意してください。
