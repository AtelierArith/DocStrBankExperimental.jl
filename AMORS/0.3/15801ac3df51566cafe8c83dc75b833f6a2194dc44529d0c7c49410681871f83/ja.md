```
AMORS.solve!(f, x, y) -> info, x, y
```

AMORS法によって*双線形モデル*の成分を推定します。引数`f`は目的関数を表します（以下を参照）。入力時、引数`x`と`y`は問題の初期変数であり、解によって上書きされます（アルゴリズムの非破壊版については[`AMORS.solve`](@ref)を呼び出してください）。結果は更新された変数と、アルゴリズムの最終状態を格納する`info`を含む3タプルです。例えば、`info.status == :convergence`は、アルゴリズムが与えられた許容範囲内で変数`x`と`y`に収束した場合に成立し、`info.status == :too_many_iterations`は、アルゴリズムが最大反復回数を超えた場合に成立します（詳細については[`AMORS.Info`](@ref)を参照してください）。

AMORSの目的は、`x ∈ 𝕏`および`y ∈ 𝕐`において次の形式の目的関数を最小化することです：

```
F(x,y,μ,ν) = G(x⊗y) + μ*J(x) + ν*K(y)
```

ここで、`G`は*双線形モデル* `x⊗y`の関数であり、`J`および`K`はそれぞれの変数`x`および`y`の非負同次関数であり、`μ > 0`および`ν > 0`はハイパーパラメータです。記法`x⊗y`は、次の不変性特性を持つ*双線形モデル*を示します：

```
(α*x)⊗(y/α) = x⊗y
```

任意の`x`、`y`、およびスカラー因子`α > 0`に対して成り立ちます。同次関数、例えば`J: 𝕏 → ℝ`の次数`q`は、任意の`α ∈ ℝ`および任意の`x ∈ 𝕏`に対して`J(α*x) = abs(α)^q*J(x)`が成り立つものです。次の特性がすべての`α ∈ ℝ`に対して成り立つ必要があることに注意してください：`x ∈ 𝕏`は`α*x ∈ 𝕏`を意味します。言い換えれば、`𝕏`はコーンでなければなりません。

引数`f`は、目的関数`F(x,y,μ,ν)`を計算するために必要なデータ、作業空間、パラメータなどを収集する呼び出し可能なオブジェクトです。引数`f`は`f(Val(task), args...)`として呼び出され、ここで`task`は実行する操作を指定する記号名です：

```
f(Val(:degJ))       -> deg(J)  # キーワード`q`が指定されていない限り
f(Val(:degK))       -> deg(K)  # キーワード`r`が指定されていない限り
f(Val(:Jx), x)      -> J(x)
f(Val(:Ky), y)      -> K(y)
f(Val(:x), x, y, μ) -> x⁺, G(x⁺⊗y), J(x⁺)
f(Val(:y), x, y, ν) -> y⁺, G(x⊗y⁺), K(y⁺)
```

ここで、`deg(J)`および`deg(K)`はそれぞれの関数`J`および`K`の同次次数を示し、次のようになります：

```
x⁺ ≈ argmin_{x ∈ 𝕏} G(x⊗y) + μ*J(x)
y⁺ ≈ argmin_{y ∈ 𝕐} G(x⊗y) + ν*K(y)
```

`argmin_{x ∈ 𝕏} F(x, y)`および`argmin_{y ∈ 𝕐} F(x, y)`の解は正確でない場合があり、ストレージを節約するためにインプレースで計算されることがあります。つまり、解`x⁺`（または`y⁺`）によって`x`（または`y`）が上書きされます。アルゴリズムの型安定性のために、`f(Val(:x),x,y,μ)[1]::typeof(x)`および`f(Val(:y),x,y,ν)[1]::typeof(y)`が成り立つ必要があります。

引数`x`と`y`は問題の変数を定義するために必要です。最初は、`J(x) > 0`および`K(y) > 0`である必要がありますが、これは自動的な最適スケーリングが`autoscale=false`によって無効にされていない限り（推奨されません）。

次のキーワードを指定できます：

  * `μ`は`J(x)`の乗数です；デフォルトは`μ = 1.0`です。
  * `ν`は`K(y)`の乗数です；デフォルトは`ν = 1.0`です。
  * `q`は`J(x)`の同次次数です；デフォルトは`q = f(Val(:degJ))`です。
  * `r`は`K(y)`の同次次数です；デフォルトは`r = f(Val(:degK))`です。
  * `α`は初期スケーリング因子です；デフォルトは`α = 1.0`です。`autoscale`が`false`の場合、すべての反復で`α`の値は変更されません。
  * `autoscale`はスケーリング因子`α`を自動的に設定するかどうかを指定します；デフォルトは`autoscale = true`です。このキーワードはAMORSアルゴリズムの効率をテストするために提供されており、オートスケーリングを無効にしないことを推奨します。
  * `Float`はスカラー計算の浮動小数点型です；デフォルトは`Float = Float64`です。
  * `first`は`Val(:x)`または`Val(:y)`のいずれか（デフォルト）で、他の変数を考慮して最初に更新するコンポーネントを指定します。
  * `αtol ≥ 0`は相対許容誤差（デフォルトは`αtol = 0.3`）で、アルゴリズムの初期反復におけるスケーリング因子`α`の収束を確認します。`αtol = Inf`を使用すると、収束を確認せずに単に`α`を更新します。`autoscale`が`false`の場合、`αtol`の値は影響を与えません。
  * `xtol ≥ 0`は相対許容誤差（デフォルトは`xtol = 0.0001`）で、変数`x`の収束を確認します。
  * `ytol ≥ 0`は相対許容誤差（デフォルトは`ytol = xtol`）で、変数`y`の収束を確認します。
  * `maxiter`はアルゴリズムの最大反復回数（デフォルトは`1000`）です。アルゴリズムの1回の反復は、双線形モデルのコンポーネントの1つ、`x`または`y`を更新することから成ります。したがって、モデルを完全に更新するには2回の反復が必要です。
  * `has_converged`は反復の収束を確認するために使用される関数です（デフォルトは[`AMORS.has_converged`](@ref)）。
  * `observer`は、各反復後に呼び出されるユーザー定義関数で、`observer(io,info,f,x,y)`として呼び出されます。ここで、`io`は対応するキーワードによって設定されたストリーム、`info`はアルゴリズムの現在の状態を持つ[`AMORS.Info`](@ref)のインスタンス、`f`は問題を定義するオブジェクト、`x`および`y`はモデルコンポーネントの現在の推定値です。この関数は、シンボリックなステータスを返すことができます。このステータスが`:searching`でない場合、アルゴリズムは終了し、結果の`info`はこのステータスで設定されます。オブザーバーが返す値は、`Symbol`でない場合は無視されます。
  * `io`はオブザーバーのためのストリームで、デフォルトは`stdout`です。

```
