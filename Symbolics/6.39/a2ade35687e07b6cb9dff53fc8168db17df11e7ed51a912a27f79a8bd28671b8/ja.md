```julia
parse_expr_to_symbolic(ex, mod::Module)
```

現在のモジュールで `parse_expr_to_symbolic` 関数を適用します。すなわち、`parse_expr_to_symbolic(ex, mod)` で、`mod` は関数呼び出し元のモジュールです。

## 引数

  * `ex`: 解析する式
  * `mod`: 解析を適用するモジュール。詳細は制限事項のセクションを参照してください。

## 例

```julia
ex = :(y(t) ~ x(t))
parse_expr_to_symbolic(ex,Main) # 空の Main での記号式 `y(t) ~ x(t)` を返します

# では、全体のシステムを行いましょう

ex = [:(y ~ x)
      :(y ~ -2x + 3 / z)
      :(z ~ 2)]
eqs = parse_expr_to_symbolic.(ex, (Main,))

@variables x y z
ex = [y ~ x
      y ~ -2x + 3 / z
      z ~ 2]
all(isequal.(eqs,ex)) # true
```

## 制限事項

### 環境定義に結びついた記号性

記号式への解析は、関数、数値、および自分の Julia 環境内で定義されたグローバル変数と、記号的にするべきものとの違いを認識できる必要があります。この機能がこの問題を処理する方法は、選択した `mod` モジュール内で既に定義されているものを記号的として定義しないことです。たとえば、`f(x,y)` は、関数 `f`（名前が `f`）が `mod` に定義されている場合、`f` は非記号的になります。すなわち、`isdefined(mod,:f)` が true の場合です。シンボルが定義されると、その値に置き換えられます。特に、これは解析の動作が適用される環境によって変わることを意味します。

たとえば：

```julia
parse_expr_to_symbolic(:(x - y),@__MODULE__) # x - y
x = 2.0
parse_expr_to_symbolic(:(x - y),@__MODULE__) # 2.0 - y
```

これは、`-` のような標準関数が記号的なシンボルではなく関数であることを検出するために必要です。安全のために、無名モジュールや他のサブ環境を作成して、迷子の変数が定義されないようにするべきです。

### メタデータは空白

式によって定義されたすべての変数は標準の `@variables` で定義されていないため、生成された変数に関連付けられるメタデータはありません。代わりに、すべてのメタデータは空白ですが、`Real` ドメインで定義されています。したがって、この解析から出てくる変数は、他の場所で定義された記号変数と等しいと評価されない可能性があります。
