```
 pschur!(A::Array{Float64,3}, Z::AbstractArray{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); rev = true, sind = 1, withZ = true) -> (ev, sind, α, γ)
 pschur!(wspace::Tuple, A::Array{Float64,3}, Z::AbstractArray{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); rev = true, sind = 1, withZ = true) -> (ev, sind, α, γ)
```

正方行列の積 `A(p)*...*A(2)*A(1)` のシュア分解を計算します。`rev = true`（デフォルト）の場合、または `A(1)*A(2)*...*A(p)` の場合、`rev = false` で、積を評価することなく行います。行列 `A(1)`, `...`, `A(p)` は `n×n×p` 配列 `A` に含まれており、`i` 番目の行列 `A(i)` は `A[:,:,i]` に含まれています。範囲 `ilh = (ilo, ihi)` を指定することができ、すべての行列 `A(j), j = 1, ..., p` はすでに行と列の `1:ilo-1` および `ihi+1:n` において周期的シュア形式になっています。ここで、`n` は `A` の最初の次元です。結果として得られる縮小行列 `S(1)`, `...`, `S(p)` は、周期的シュア分解を表し、入力行列 `A(1)`, `...`, `A(p)` を上書きします。`withZ = true` の場合、`Z` は入力時に `n×n×p` 配列を含む必要があり、出力時に縮小に使用される直交行列 `Z(1)`, `...`, `Z(p)` で上書きされます。`withZ = false` の場合、直交変換は計算されず、`Z` は任意の三次元配列（例：空の `0×0×0` 配列）で構いません。結果として得られる縮小行列 `S(1)`, `...`, `S(p)` と直交変換行列 `Z(1)`, `...`, `Z(p)` は、`rev = true` の場合に次の条件を満たします。

```
       Z(2)' * A(1) * Z(1) = S(1),
       Z(3)' * A(2) * Z(2) = S(2),
              ...
       Z(1)' * A(p) * Z(p) = S(p),
```

`rev = false` の場合は次のようになります。

```
       Z(1)' * A(1) * Z(2) = S(1),
       Z(2)' * A(2) * Z(3) = S(2),
              ...
       Z(p)' * A(p) * Z(1) = S(p).
```

`sind = ischur` の場合、`1 ≤ ischur ≤ p`（デフォルト `ischur = 1`）で、`S(i)` は `i = 1, ..., p` の周期的シュア形式になり、`S(ischur)` は準上三角（またはシュア）形式になり、`S(i)` は `i` $\neq$ `ischur` の場合は上三角になります。ベクトル `ev` には適切な行列積の固有値が含まれています。固有値は `α .* γ` としても表現でき、ここで `γ` は固有値の表現におけるオーバーフローやアンダーフローを避けるための適切なスケーリングパラメータを含みます。

周期的シュア分解を繰り返し計算する必要がある場合に、内部で必要なワークスペースを事前にタプル `wspace` に割り当てることで、割り当ての数を減らすことができます。このために関数 [`PeriodicMatrices.ws_pschur`](@ref) を使用します。 ```
