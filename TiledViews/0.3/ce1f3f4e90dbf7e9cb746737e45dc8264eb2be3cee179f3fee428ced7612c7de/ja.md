```
function TiledWindowView(data::AbstractArray{T,M}, tile_size::NTuple{M,Int};
                         rel_overlap::NTuple{M,Float64}=tile_size .*0 .+ 1.0,
                         window_function=window_hanning, get_norm=false, verbose=false, offset=CtrFT) where {T, M}
```

データをタイルサイズ、タイルオーバーラップ、オプションでタイルセンターによって指定されたようにタイル状に配置することで、2N次元のデータビューを作成します。さらに、このビューにウィンドウが適用されます。IndexFunArraysで定義されたウィンドウタイプが1に合計される場合（これはwindow*linearおよびwindow*hanningの場合です）、データの線形分解が得られますが、境界効果がある可能性があります。`data`。TiledViewに分解するための入力データ。TiledViewのためにコピーは作成されず、生データはmyview.parentを介してアクセスできます。

`tile_size`。各タイルのサイズを記述するタプル。このサイズは、size(myview)の最初のN次元を形成します。2番目のN次元はN次元タイル番号を指します。

`rel_overlap`。連続するタイル間の相対オーバーラップを指定するタプル。絶対オーバーラップは、`round.(Int,tile_size./2.0 .* rel_overlap)`として計算されます。

`window_function`。TiledViewに適用するためにIndexFunArraysで定義されたウィンドウ関数。結果は現在、ウィンドウを適用しないTiledViewも返され、代入に使用できます。デフォルトでは、von Hannウィンドウ（window_hanning）が使用されます。

`get_norm`。境界ピクセルの正規化マップも取得できるオプションのブール引数。これらのピクセルは、必ずしもすべての必要なウィンドウ操作を受けるわけではありません。将来のバージョンでは、この効果を回避できるようにウィンドウを自動的にレイアウトできる可能性があります。

`verbose`。trueの場合、ウィンドウレイアウトに関する診断情報が印刷されます。

`offset`。ウィンドウの中心が配置される場所を定義します。詳細については`IndexFunArrays.jl`を参照してください。

# 戻り値

myview, matching*window = TiledWindowView ... 2つまたは3つ（get*norm=true）のタプルで

`myview`。ウィンドウなしのデータのTiledViewで、書き込みも可能です。

`matching_window`。myviewに対して乗算を介して適用できるウィンドウ myview.*matching_window これは、書き込みアクセスに関して概念的に機能を分離するために意図的に製品として提供されていません。

`normalized`。get_norm=trueの場合のみ返されます。ウィンドウを元のデータに戻すことによって正規化情報を含む配列です。これは、タイルの不完全なカバレッジや、タイル処理中に1に合計されないウィンドウを使用する際に便利です。

単純な .+= 操作を介してビューに直接アクセスすることは危険な場合があることに注意してください。これは、参照された配列のいくつかのポイントが複数回アクセスされるため、常に読み書き操作との競合条件が発生しないことが保証されているかどうかは明確ではありません。このような効果を回避するために、たとえば、各次元で毎回2番目のタイルのみを1回の呼び出しでアクセスすることができます。

# 例

```jldoctest
julia> data = ones(10,10).+0.0;

julia> myview, matching_window = TiledWindowView(data, (5, 5); verbose=true);
[ Info: タイルのピッチ (3, 3) は (2, 2) ピクセルでオーバーラップします。
[ Info: ウィンドウは (0.5, 0.5) で始まり、(2.5, 2.5) で終了します。

julia> size(myview)
(5, 5, 5, 5)

julia> matching_window
5×5 IndexFunArrays.IndexFunArray{Float64, 2, IndexFunArrays.var"#360#362"{Float64, Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}, Tuple{Float64, Float64}}}:
 0.0214466  0.125     0.146447  0.125     0.0214466
 0.125      0.728553  0.853553  0.728553  0.125
 0.146447   0.853553  1.0       0.853553  0.146447
 0.125      0.728553  0.853553  0.728553  0.125
 0.0214466  0.125     0.146447  0.125     0.0214466

julia> windowed = collect(myview .* matching_window);

julia> myview[:,:,:,:].=0;  # 元の配列をクリアします

julia> myview.parent
10×10 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0

julia> myview .+= windowed;  # ウィンドウデータを配列に書き戻します

julia> data # 重みが正しく1に合計されるか確認しますか？
10×10 Matrix{Float64}:
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0

julia> # この結果は、後続の正規化にも使用できますが、直接取得することもできます。
 
julia> myview, matching_window, normalized = TiledWindowView(rand(10,10).+0, (5, 5); get_norm=true);
```
