```
tiled_processing(data, fct, tile_size, tile_overlap = tile_size .* 0; verbose=true, dtype=eltype(data), keep_center=false, window_function=nothing)
```

生データセットをタイルビューを使用して処理し、`data`をTiledViewでラップし、各タイルを関数`fct`に送信し、`window_function`を介して結果をマージします。結果のTiledViewを返します。タイルが適用されていない結果は、`.parent`メンバーを介してアクセスできます。この`tile_size`を使用したバージョンは、ビューの便利さを追加します：タイルサイズがデータよりも少ない次元を指定する場合、末尾の次元はデータの全サイズに一致するように自動的に拡張されます。デフォルトの`nothing`のウィンドウ*関数は、オーバーラップが使用されていない場合にウィンドウが適用されないことを保証します。オーバーラップがある場合、これは自動的にハニングウィンドウに変更されます。さらに、他のバージョンとは異なり、keep*centerオプションのデフォルト値はfalseであり、これは配列を一致する方法でタイルするだけのほとんどのアプリケーションにとってより便利です。

最初に処理されたタイルが、入力タイルサイズと等しくないか、またはその投影でないサイズの配列を返す場合、結果は入力タイルサイズと同じサイズの配列のタプルであり、各タイルのための配列の配列が返されます。

## 引数

  * `data`: TiledViewに分解する入力データ。TiledViewのためにコピーは作成されず、生データは`.parent`を介してアクセスできます。
  * `fct`: 各タイルに適用される関数。この関数は、タイルデータという単一の引数を受け入れる必要があります。
  * `tile_size`: 各タイルのサイズを記述するタプル。このサイズは、`size(myview)`の結果の最初のN次元を形成します。次のN次元はN次元タイル番号を指します。
  * `tile_overlap`: ボクセルでの連続タイル間のオーバーラップを指定するタプル。これは暗黙的にタイル間のピッチを`(tile_size .- tile_overlap)`として定義します。
  * `verbose`: trueの場合、ウィンドウレイアウトに関する診断情報が印刷されます。
  * `dtype`: 新しい配列の要素タイプ。デフォルトでは、`data`の親配列と同じタイプです。
  * `keep_center`: このブール値（デフォルト: false）は、親`data`の中心が中央タイルの中心と整列されるかどうかを指定します。`false`の場合、最初のタイルはオフセットゼロから始まります。
  * `window_function`: TiledViewに適用するためにIndexFunArraysで定義されたウィンドウ関数。現在、結果はもはやビューではなく、乗算をビューにラップする方法が不明なためです。この理由から、ウィンドウが適用されていないTiledViewも返され、代入に使用できます。デフォルトではハニングウィンドウ（window_hanning）が使用されます。

## 例

```jldoctest
julia> res = tiled_processing(ones(10,10), (a)->10*a, (2,2), (0,0), verbose=false).parent
10×10 Matrix{Float64}:
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0
 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0

julia> tiled_processing(ones(10,20), (a)->sum(a, dims=2), (2,), verbose=false).parent
10×1 Matrix{Float64}:
 20.0
 20.0
 20.0
 20.0
 20.0
 20.0
 20.0
 20.0
 20.0
 20.0

julia> fct = (a)->[3 .*a, sum(a, dims=2), "result: $(sum(a))"]; # 異なるタイプの3つの値のタプルを返す関数

julia> tiled_processing(ones(5,6), fct, (2,), verbose=false)
3-element Vector{AbstractArray}:
 [3.0 3.0 … 3.0 3.0; 3.0 3.0 … 3.0 3.0;;; 3.0 3.0 … 3.0 3.0; 3.0 3.0 … 3.0 3.0;;; 3.0 3.0 … 3.0 3.0; 0.0 0.0 … 0.0 0.0;;;;]
 [6.0; 6.0;;; 6.0; 6.0;;; 6.0; 0.0;;;;]
 ["result: 12.0"; "result: 12.0"; "result: 6.0";;]
```
