```
SSHT(s, ℓₘₐₓ; [method="Direct"], [T=Float64], [kwargs...])
```

スピン重み付き球面調和モード重みと関数値の間で変換する `SSHT` オブジェクトを構築します — $s$-SHT を実行します。

このオブジェクトは、変換を実行するために代数の意味論を使用する能力において、`AbstractFFTs.Plan` オブジェクトに似た動作をします。たとえば、関数値がベクトル `f` として保存され、モード重みが `f̃` として、`SSHT` が `𝒯` として表される場合、モード重みから関数値を計算することができます。

```
f = 𝒯 * f̃
```

または、関数値からモード重みを解くことができます。

```
f̃ = 𝒯 \ f
```

`f̃` の最初の次元はモード重みをインデックスする必要があります（通常通り、`ℓ∈abs(s):ℓₘₐₓ` および `m∈-ℓ:ℓ` に対して）し、`f` の最初のインデックスは関数が評価される位置をインデックスする必要があります。続く次元はブロードキャストされます。特定のタイプは、Julia スレッドを使用してブロードキャストされる一方、他のタイプは BLAS スレッドを使用してブロードキャストされることに注意してください。関連するスレッド数は適切に設定する必要があります。

特定の `SSHT` タイプ（現在は `Minimal` と `Direct` のみ）は、*常に* インプレースで動作するオプションも持っています — これは、`𝒯 \ f` のような式で使用される場合でも、単に入力ストレージを再利用することを意味します。このオプションは、コンストラクタに `inplace` 引数として渡す必要があり、結果のオブジェクトのタイプの一部です。そのオプションの値に関係なく、そのオプションが存在するタイプに対しては、`LinearAlgebra` パッケージの `mul!` および `ldiv!` を使用してインプレースでの操作を強制することも可能です。

異なるアルゴリズムは、関数を評価するための異なる「ピクセル化」または `Rotor` のセットを必要とすることに注意してください。これらは、[`pixels`](@ref) および [`rotors`](@ref) 関数を使用して `SSHT` オブジェクトから取得できます。
