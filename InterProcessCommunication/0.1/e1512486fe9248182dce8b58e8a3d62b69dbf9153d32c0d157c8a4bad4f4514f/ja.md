```julia
WrappedArray(mem, [T [, dims...]]; offset=0)
```

は、要素が「メモリ」オブジェクト `mem` に格納されている Julia 配列を生成します。引数 `T` は返される配列の要素のデータ型であり、引数 `dims` は配列の次元を指定します。 `dims` が省略された場合、結果は最大長のベクトルになります（オフセットと `mem` オブジェクトのサイズを考慮）。 `T` が省略された場合、`UInt8` が仮定されます。

キーワード `offset` は、配列の最初の要素が `pointer(mem)` に対して格納されているアドレス（バイト単位）を指定するために使用できます。

`mem` に提供されるメモリのサイズは、すべての要素を格納するのに十分でなければならず（オフセットを考慮）、メモリ内の要素のアライメントは `Base.datatype_alignment(T)` の倍数でなければなりません。

別の可能性は次の通りです：

```julia
WrappedArray(mem, dec)
```

ここで `mem` は「メモリ」オブジェクトであり、`dec` はメモリオブジェクトに基づいて配列の型とレイアウトをデコードする役割を持つ関数です。デコーダは次のようにメモリオブジェクトに適用されます：

```julia
dec(mem) -> T, dims, offset
```

これは、配列要素のデータ型 `T`、配列の次元 `dims`、および `pointer(mem)` に対する最初の要素のオフセットを返さなければなりません。

## 制限事項

`mem` オブジェクトは、`pointer(mem)` と `sizeof(mem)` メソッドを拡張しなければならず、それぞれ `mem` に提供されるメモリのベースアドレスと利用可能なバイト数を返さなければなりません。さらに、このメモリは、オブジェクト `mem` がガーベジコレクタによって回収されるまで利用可能であると仮定されます。

## 共有メモリ配列

```julia
WrappedArray(id, T, dims; perms=0o600, volatile=true)
```

は、要素（およびヘッダー）が `id` によって識別される共有メモリに格納されている新しいラップされた配列を作成します（`id` の説明とキーワードについては [`SharedMemory`](@ref) を参照してください）。別のプロセスでこの配列を取得するには、次のようにします：

```julia
WrappedArray(id; readonly=false)
```

## 参照

[`SharedMemory`](@ref).
