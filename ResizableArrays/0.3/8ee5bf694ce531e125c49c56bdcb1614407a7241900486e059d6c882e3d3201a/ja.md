```
ResizableArray{T}(undef, dims...)
```

は、型 `T` の未初期化要素を持つ可変サイズの配列を生成し、次元は `dims...` です。次元は整数のタプルまたは整数のリストである場合があります。次元の数 `N` は明示的に指定することができます：

```
ResizableArray{T,N}(undef, dims...)
```

指定されたランクと要素型の空の可変サイズ配列を作成するには、次のように呼び出します：

```
ResizableArray{T,N}()
```

可変サイズ配列 `A` の次元は、`resize!(A,dims)` を呼び出すことで変更できます。ここで `dims` は新しい次元です。次元の数は変更できませんが、配列の長さは変更可能です。配列のストレージを支えるオブジェクトの型によっては、配列の要素数を増やすことができる場合とできない場合があります。配列要素が通常のJuliaベクターに格納されている場合、要素数は常に増やすことができます。可変サイズ配列の最後の次元のみを変更すると、その内容は保持されます。

可変サイズ配列は、可能な限りストレージを再利用するように設計されており、ガーベジコレクタを呼び出すのを避けることができます。これはリアルタイムアプリケーションに役立つ場合があります。その結果、可変サイズ配列 `A` が使用するストレージは、`shrink!(A)` が呼び出されて最小に減少されない限り、成長することしかできません。呼び出し `ResizableArray(A)` は、可変サイズ配列のコピーである `A` を生成します。

パフォーマンスを向上させるために、`sizehint!(A,n)` を呼び出して、`A` に事前に割り当てる最小要素数を示します（`n` は要素数または配列の次元数であることができます）。

`ResizableArray` コンストラクタと `convert` メソッドを使用して、配列 `A` を可変サイズ配列に変換できます：

```
ResizableArray(A)
convert(ResizableArray, A)
```

可能であれば、`convert` メソッドは入力配列を返しますが、`ResizableArray` コンストラクタは常に新しいインスタンスを返します。要素型 `T` と次元数 `N` を指定することができます：

```
ResizableArray{T[,N]}(A)
convert(ResizableArray{T[,N]}, A)
```

`N` は `ndims(A)` と一致しなければなりませんが、`T` は `eltype(A)` とは異なっても構いません。

デフォルトでは、可変サイズ配列の要素のストレージは通常のJuliaベクターによって提供されます。可変サイズ配列の要素を格納するためにオブジェクト `buf` を使用するには、次のいずれかを使用します：

```
A = ResizableArray(buf, dims)
A = ResizableArray{T}(buf, dims)
A = ResizableArray{T,N}(buf, dims)
```

バッファ `buf` は、1ベースのインデックスを使用して線形インデックススタイルで要素を連続して格納し、要素型 `T` を持っている必要があります。つまり、`IndexStyle(typeof(buf))` と `eltype(buf)` はそれぞれ `IndexLinear()` と `T` を返さなければなりません。`IndexStyle`、`eltype`、`length`、`getindex` および `setindex!` メソッドは、`buf` の型に対して適用可能でなければなりません。もし `resize!` メソッドが `buf` に適用可能であれば、`A` の要素数を増やすことができます。そうでない場合、`A` の最大要素数は `length(buf)` です。

!!! warning
    可変サイズ配列 `A` のストレージを支えるために明示的に可変バッファ `buf` を提供する場合、呼び出し元は同じバッファが他の場所でサイズ変更されないことを確認する責任があります。そうでないと、`A` が誤ったバッファサイズを仮定するため、セグメンテーションフォルトが発生する可能性があります。これを避けるためには、`A` のみが `buf` を所有し、`A` のみがそのサイズを管理することを確認するのが最善です。現在の実装では、内部バッファのサイズは自動的に減少することはないため、`shrink!` がこれらの配列に対して呼び出されない限り、同じバッファは異なる可変サイズ配列によって安全に共有されることができます。

