```
time_scale(sys::AbstractStateSpace{Continuous}, a; balanced = false)
time_scale(G::TransferFunction{Continuous},     a; balanced = true)
```

`sys`の時間軸を再スケールします（時間単位を変更します）。

支配的な時間定数が1から非常に遠いシステム、例えば電子機器では、時間軸の再スケーリングが数値性能に有益である場合があります。特に連続時間シミュレーションにおいてです。

ラプラス変換$F(s)$を持つ関数$f(t)$の時間スケーリングは次のように表現できます。

$$
f(at) \leftrightarrow \dfrac{1}{a} F\big(\dfrac{s}{a}\big)
$$

キーワード引数`balanced`は、`B`および`C`行列にバランスの取れたスケーリングを適用するかどうかを示します。状態空間システムの場合、これはデフォルトでfalseであり、状態表現が変更されるため、`B`のみがスケーリングされます。伝達関数の場合、これはデフォルトでtrueです。

# 例:

次の例は、時間定数が1マイクロ秒のオーダーのシステムが再スケーリングされ、時間定数が1になるように、すなわち時間単位が秒からマイクロ秒に変更される様子を示しています。

```julia
Gs  = tf(1, [1e-6, 1])     # マイクロ秒の時間スケールを秒でモデル化
Gms = time_scale(Gs, 1e-6) # マイクロ秒の時間スケールに変更
Gms == tf(1, [1, 1])       # Gmsは現在マイクロ秒を時間単位として持つ
```

次の例は、時間スケーリングによって時間領域シミュレーションの時間軸がどのように変化するかを示しています。

```julia
t = 0:0.1:50 # 元の時間軸
a = 10       # スケーリング因子
sys1 = ssrand(1,1,5)
res1 = step(sys1, t)      # 元のシミュレーションを実行
sys2 = time_scale(sys, a) # 時間をスケーリング
res2 = step(sys2, t ./ a) # スケーリングされた時間軸でシミュレーション、`1/a`に注意
isapprox(res1.y, res2.y, rtol=1e-3, atol=1e-3)
```
