```
result = lsim(sys, u[, t]; x0, method])
result = lsim(sys, u::Function, t; x0, method)
```

システム `sys` の入力 `u` に対する時間応答を計算します。`x0` が省略された場合、ゼロベクトルが使用されます。

結果の構造体には `y, t, x, u` のフィールドが含まれており、例えば以下のように自動的に分解できます。

```julia
y, t, x, u = result
```

`result::SimResult` は直接プロットすることもできます：

```julia
plot(result, plotu=true, plotx=false)
```

`y`, `x`, `u` は第二次元に時間を持っています。初期状態 `x0` はデフォルトでゼロです。

連続時間システムは、`u` が関数である場合にODEソルバーを使用してシミュレーションされます（ControlSystemsを使用する必要があります）。`u` が配列である場合、シミュレーションの前にシステムは離散化されます（デフォルトでは `method=:zoh`）。より低レベルのインターフェースについては、`?Simulator` および `?solve` を参照してください。連続時間システムの場合、キーワード引数はODEソルバーに転送されます。デフォルトでは、オプション `dtmax = t[2]-t[1]` が使用され、ソルバーが `u(x, t)` の不連続性を越えないようにします。これにより、ソルバーが大きすぎるステップを取るのを防ぎますが、`u` が滑らかな場合にはシミュレーションが遅くなることがあります。この動作を無効にするには、`dtmax = Inf` を設定します。

`u` は関数または事前計算された制御信号の *行列* であり、次元は `(nu, length(t))` でなければなりません。`u` が関数である場合、`u(x,i)`（離散システムの場合）または `u(x,t)`（連続システムの場合）が呼び出され、各イテレーション（ソルバーが使用する時間インスタンス）で制御信号が計算されます。これは、`lqr` によって計算された状態フィードバック `u(x,t) = -L*x` のような制御則を提供するために使用できます。`t=t₀` で単位ステップをシミュレートするには `(x,t)-> t ≥ t₀` を使用し、ランプの場合は `(x,t)-> t` を使用し、`t=5` でのステップの場合は `(x,t)-> (t >= 5)` を使用します。

*注意:* 関数 `u` はシミュレーションの前に一度呼び出され、正しい次元の配列を返すことを確認します。`u` が状態を持つ場合や他の副作用がある場合、問題が発生する可能性があります。このチェックを無効にするには、`check_u = false` を渡してください。

最大のパフォーマンスを得るには、離散時間システム専用の関数 [`lsim!`](@ref) を参照してください。

使用例：

```julia
using ControlSystems
using LinearAlgebra: I
using Plots

A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(x,t) = -L*x # 制御則を形成
t  = 0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x', lab=["位置" "速度"], xlabel="時間 [s]")

# プロットの別の方法
res = lsim(sys,u,t,x0=x0)
plot(res)
```
