```
@rule Rulename(a::A_Type, b::B_Type, ...) begin ... end
```

`Rulename`という名前のルールを定義します。ルールを表すために`Rulename`という名前のシングルトン型が定義されます。その型には、ルールを実装するために必要なノードと接続をReteに追加するために使用できる[`install`](@ref)メソッドが定義されています。

ルール構造体のデフォルトのスーパタイプは`Rule`です。ルールをグループ化することが望ましい場合、[`Rule`](@ref)の型の子孫である抽象型を定義し、それを`RuleName`のドット接頭辞として使用できます。`@rule`呼び出しの`RuleName`が`MyGroup.MyRule`の場合、MyRuleのスーパタイプは`MyGroup`になります。

ルールは任意の数のパラメータを持つことができます。パラメータリストには、変数名のない句も含めることができます。このような句は、ルールが主張する可能性のある事実の型を特定します。これらの型のメモリノードは、すでに存在しない場合、Reteに追加されます。自動生成された`install`メソッドによって追加されます。CUSTOM_INSTALLを参照してください。ルールによって発生するすべての型がここにリストされることは強制されませんが、さまざまな内省ツールや適切なルールのインストールはこれに依存します。

`@rule`式の本体は、ルールの動作を実装します。どの事実が主張されるべきかを判断するために必要なテストを実行できます。このコードは、ルール自体と同じ名前の関数に含まれます。この関数は、ルールを実装する[`JoinNode`](@ref)の`join_function`として使用されます。この関数は、デフォルト値が[`emit`](@ref)を呼び出すキーワード引数`emit`を宣言します。テストやデバッグの目的で、ルール関数はJulia REPLから呼び出すことができ、`emit=println`を渡してネットワークの残りから独立してルール関数を試すことができます。

本体内では、`@reject`、`@rejectif`、および`@continueif`を使用できます。

`@reject`は、無条件にルール本体を終了し、デバッグログメッセージを発行します。

他の2つは条件式を取ります。

`@rejectif`は、条件が成功した場合にルール本体を終了し、メッセージをログに記録します。

`@continueif`は、条件がfalseを返した場合に終了し、ログに記録します。

ルールの最初の式は、RULE_DECLARATIONSの呼び出しのような式であることができます。その「パラメータ」は、次の形式の宣言であることができます。

``FORWARD*TRIGGERS(argument*names...)`

指定された引数名の入力のみが前方トリガーとして機能します。後方互換性のために、`RULE_DECLARATIONS`式がない場合、すべての入力が前方トリガーとなります。

`RULE_DECLARATIONS`句が含まれている場合、すべての前方トリガーは明示的に宣言する必要があることに注意してください。

``CUSTOM_INSTALL()`

自動的に`install`メソッドは生成されません。開発者はこのルールのために`install`メソッドを実装する必要があります。 ```
