```
data = simulate(Y, final_time, nb_time_points=250) # Y(s)を逆変換する

LTIシステムの出力$y(t)$を、出力のラプラス変換$Y(s)$、`Y`が与えられたときにシミュレートします。

言い換えれば、`simulate`は周波数領域の式を時間領域に逆変換します。

# 引数

  * `Y::Union{TransferFunction, ClosedLoopTransferFunction}`: 出力$y(t)$のラプラス変換。通常、$g(s)U(s)$の形で構成され、ここで$U(s)$は入力のラプラス変換、$g(s)$はシステムのダイナミクスを支配する伝達関数です。
  * `final_time::Union{Int64, Float64}`: LTIシステムの出力をシミュレートする期間で、時間ゼロから始まります。
  * `nb_time_points::Int=100`: 解$y(t)$を保存する時間点の数。

$t=0$の前の2つの時間点が含まれており、$t<0$のとき$y(t)=0$であると仮定されていることを示しています。

# 戻り値

  * `data::DataFrame`: 2つの列を含むデータフレーム：時間$t$のための`:t`と$y(t)$のための`:output`。各行は$(t_i, y(t_i))$のペアに対応します。すなわち、`:t`列の行$i$は時間$i$、$t_i$であり、`:output`列の行$i$は$y_i=y(t_i)$です。列には`data[:, :t]`および`data[:, :output]`でアクセスします。

# 例

出力のラプラス変換`Y`が与えられたときの一次のステップ応答をシミュレートします：

```

jldoctest g = 4 / (3 * s + 1)      # 一次伝達関数g(s) U = 1 / s                # 単位ステップ入力U(s) Y = g / s                # 出力Y(s) data = simulate(Y, 12.0) # 時系列データフレーム data[:, :t]              # 時間点tᵢの配列 data[:, :output]         # 対応する出力y(tᵢ)の配列 first(data, 5)           # データフレームの最初の5行を表示

# 出力

5×2 DataFrame  Row │ t          output           │ Float64    Float64     ─────┼───────────────────────    1 │ -0.6       0.0    2 │ -1.0e-5    0.0    3 │  1.0e-5    1.33333e-5    4 │  0.123721  0.161606    5 │  0.247432  0.316671 ```
