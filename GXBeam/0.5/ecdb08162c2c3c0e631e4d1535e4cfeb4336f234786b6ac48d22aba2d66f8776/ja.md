```
afmesh(xaf, yaf, chord, twist, paxis, xbreak, webloc, segments, webs; ds=nothing, dt=nothing, ns=nothing, nt=nothing, wns=4, wnt=nothing)
```

翼型の構造メッシュを作成します。翼型の座標は、翼型に対して接線方向のメッシング密度を定義します。一方、層の数は翼型に対して法線方向の解像度を定義します。すべてのセグメントは、最も層の多いセグメントによって定義されたグリッドポイントの数を使用して、法線方向で同じ解像度でメッシュ化されます。

**引数**

  * `xaf, yaf::Vector{float}`: 翼型を定義する点は、後縁から始まり、反時計回りに後縁に戻ります（鈍いまたは鋭い後縁が可能）。
  * `chord::float`: コード長
  * `twist::float`: ねじれ角（ラジアン）
  * `paxis::float`: ピッチ軸（コードで正規化）。例：0.25は四分の一コードの周りのねじれを意味します。
  * `xbreak::Vector{float}`: セグメント間のブレークポイントを定義するx位置（コードで正規化）。0から始まり1で終わる必要があります。例：[0, 0.2, 0.4, 0.7, 1.0]は4つのセグメントを定義します。
  * `webloc::Vector{float}`: ウェブの中心を定義するx位置（コードで正規化）（ベクトルの長さはウェブの数）。例：[0.25, 0.55]は25%コードにウェブがあり、55%コードに2番目のウェブがあることを意味します。
  * `segments::Vector{Vector{Layer}}`: レイヤーは、プライ（または同じ材料/方向の複数のプライ）を定義します。特定のx位置で、プライスタック（セグメント）は外側の表面から内側に向かって始まるレイヤーのベクトルとして定義されます。セグメントは、xbreakによって定義されたセグメント間の特性を定義するこれらのセグメントのベクトルです。
  * `webs::Vector{Vector{Layer}}`: セグメントと同じ構造ですが、各内部ベクトルは左から右に（通常は対称ですが）、各外部ベクトルは別々のウェブのためのものです。
  * `ds::float`: 提供される場合、翼型の間隔はこの間隔で再サンプリングされます（コードで正規化）。例：0.01は、翼型上の点が約1%コードの間隔であることを意味します。
  * `dt::float`: 提供される場合、厚さはこの最大メッシュサイズで再サンプリングされます（厚さは絶対値です）。翼型に沿ったセルの総数は一定に保たれるため、ほとんどの厚さははるかに少なくなります。例：0.01は最大メッシュ厚さ0.01（絶対値）を目指します。
  * `ns::vector{int}`: 提供される場合、ターゲットサイズdsを使用するのではなく、各セグメントで使用するセルの数を指定します。これは、翼型の座標が変更された場合に、リサイズ操作中にメッシュが伸縮するようにするため、勾配ベースの最適化に望ましいです。例えば、ns=[15, 20, 40, 30]は、xbreak[1]とxbreak[2]の間に15要素を使用し、など。
  * `nt::vector{vector{int}}`: 提供される場合、接線方向に使用する要素の数を定義します。再び、厚さが最適化中に変更される場合、勾配ベースの最適化のためにdtよりも好まれます。各エントリは、元のレイアップの順序に従って、そのレイヤーに配置するセルの数を定義します。例えば、nt=[[1, 2, 1], [1, 3]]は、最初のセクターで1要素、2要素（細分化）、次に1要素を使用します。
  * `wns::int`: ウェブに沿った要素の数の離散化レベル。
  * `wnt::vector{vector{int}}`: ウェブ用のntと同じ定義

**戻り値**

  * `nodes::Vector{Node{Float64}}`: このメッシュのノード
  * `elements::Vector{MeshElement{Float64}}`: このメッシュの要素
