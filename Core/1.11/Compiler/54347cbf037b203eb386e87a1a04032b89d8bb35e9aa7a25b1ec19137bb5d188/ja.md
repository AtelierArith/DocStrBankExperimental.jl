```
ir_inline_unionsplit!
```

この関数の主な目的は、ユニオン分割ディスパッチ候補のシグネチャに対応するフラットな `isa` チェックを生成することによって、ディスパッチの動作をエミュレートすることです。これらのチェックにより、メソッド本体をそれぞれの `isa` 条件付きブロックにインライン化することができます。

このエミュレーションが正しく機能するためには、2つの前提条件が必要です。

1. 順序付きディスパッチ候補

ディスパッチ候補は、その特異性の順序で処理されなければなりません。生成される `isa` チェックはこの順序を反映する必要があります。特に、メソッドシグネチャが具体的でない場合があります。例えば、次のメソッドがあるとします：

```
f(x::Int)    = ...
f(x::Number) = ...
f(x::Any)    = ...
```

呼び出しサイト `f(x::Any)` に対する正しい `isa` ベースのディスパッチエミュレーションは次のようになります：

```
if isa(x, Int)
    [インライン化/解決された f(x::Int)]
elseif isa(x, Number)
    [インライン化/解決された f(x::Number)]
else
    [インライン化/解決された f(x::Any)]
end
```

`ml_matches` は、あいまいなケースを除いて、すでに一致したメソッド候補を正しくソートしているはずです。

2. 型等価制約

もう一つの要因は、型変数によって課せられる型等価制約です。単純な `isa` チェックでは、いくつかのケースで意味を捉えるには不十分です。例えば、次のメソッド定義を考えてみましょう：

```
g(x::T, y::T) where T<:Integer = ...
```

`g(x::Any, y::Any)` のような呼び出しサイトを次のように最適化することは *無効* です：

```
if isa(x, Integer) && isa(y, Integer)
    [インライン化/解決された g(x::Integer, y::Integer)]
else
    g(x, y) # フォールバック動的ディスパッチ
end
```

なぜなら、`x` と `y` が等しい型であることも確認する必要があるからです。

しかし、私たちはすでにこの時点でそのようなケースを除外しています。主に `case.sig::UnionAll` をフィルタリングすることによって、したがってこの時点で型等価について心配する必要はありません。

本質的に、私たちはディスパッチ候補を順次処理することができ、`ml_matches` での発見後にその順序が変わらないと仮定します。
