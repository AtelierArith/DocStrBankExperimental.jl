```
grad(::Num; force::Bool)
grad(::Num, ::Vector{Num}; base_level::Bool, force::Bool)
```

与えられた象徴的な式に対して、凸および凹緩和のサブ勾配を表す式のベクトルを返します。入力は、サブ勾配が要求される式と、オプションで必要な次元です。`Vector{Num}`が指定されていない場合、サブ勾配は式内で見つかったすべての変数に関して生成されます。

デフォルトでは、`grad`は入力がより大きな式の一部であるサブ式であると仮定します。そのため、勾配の値は作成された関数への入力として必要になります。代わりに、`base_level`が`true`に設定されている場合、勾配は`Vector{Num}`で与えられた変数の順序に基づいて`0`と`1`で構成されます。

この関数には、過度に大きな置換が行われていないことを確認するチェックが含まれており、これによりJuliaが潜在的に長時間停止する可能性があります。大きな置換が検出された場合、`grad`は計算からバックアウトし、ユーザーに警告します。この機能は、`force=true`を設定することで抑制できます。

# 例

```
cvgrad, ccgrad = grad(x*y, [x,y,z], base_level=true);
```

ここでは、式`x*y`のサブ勾配が要求されています。ユーザーは、考慮されている完全な式が3次元であり、次元が`[x,y,z]`であることを示していますので、結果として得られる勾配式も3次元になります。例えば、`cvgrad`は3要素の`Vector{Num}`であり、`cvgrad[1]`は`x*y`の凸緩和のサブ勾配のx成分、`cvgrad[2]`はy成分、`cvgrad[3]`はz成分になります。`base_level`が`true`に設定されているため、`x`、`y`、`z`の勾配は内部的にそれぞれ`[1,0,0]`、`[0,1,0]`、`[0,0,1]`に設定され、`x*y`の凸緩和のサブ勾配式を作成する前に設定されます。上記のすべては、入力式の凹緩和のサブ勾配を含む`ccgrad`にも適用されます。

もし`base_level`が`true`に設定されていなかった場合（デフォルト値の`false`を保持していた場合）、結果として得られるサブ勾配式はそれぞれ`[dx/dx, dx/dy, dx/dz]`、`[dy/dx, dy/dy, dy/dz]`、`[dz/dx, dz/dy, dz/dz]`の関数になります。これは、式がサブ式に分割され、それぞれが`grad`に供給される場合に重要です。例えば：

```
cvgrad, ccgrad = grad(a*b, [x,y,z])
```

この場合、`a`と`b`は、基底変数`x`、`y`、`z`を含む合成の中間項である可能性があります。この`grad`の呼び出しから得られる結果の式は、`a`と`b`のマコーミックタプルの入力と、`[da/dx, da/dy, da/dz]`および`[db/dx, db/dy, db/dz]`の値を必要とします。

もし`grad`が最初の引数のみで呼び出された場合、`base_level`は`true`であると仮定されます（つまり、ユーザーが式を書いており、サブ勾配式の作成に使用される変数が式内に存在する変数のみであることを望んでいる場合、その式はおそらく基底変数のみで構成されていると仮定されます）。
