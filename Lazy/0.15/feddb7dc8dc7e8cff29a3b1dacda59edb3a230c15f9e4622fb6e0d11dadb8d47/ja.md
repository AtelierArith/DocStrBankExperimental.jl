効率的な再帰関数を有効にします。例えば：

```
@rec reduce(f::Function, v, xs::List) =
  isempty(xs) ? v : reduce(f, f(v, first(xs)), tail(xs))
```

`@rec`なしでは、この関数は80,000以上の要素を持つリストでスタックオーバーフローを引き起こします。

注意点：

  * トランポリンのサポートはありません。つまり、与えられた関数への呼び出しのみが最適化されます。
  * 複数のディスパッチは無視されます。関数の名前は常に与えられた定義を指すと仮定されています。
  * let内で関数の名前を再バインドしないでください（上記参照）。
  * varargs関数と一緒に使用しないでください。

これらの問題を避けるために、より柔軟ですが遅い[`@bounce`](@ref)を使用してください。
