```
aws_host_resolver_new_default(allocator, options)
```

デフォルトの動作を持つホストリゾルバを作成します。動作は次のとおりです。

信頼できる方法でノンブロッキングDNSを行うことは、存在するすべてのUnixシステムで数年のテストが必要なリスクの高い作業が必要なため、スレッド実装を行うことで回避しています。

アドレスをリクエストすると、キャッシュをチェックします。エントリがキャッシュにない場合は、新しいエントリを作成します。各エントリには、レコードのttlに基づいた短命のバックグラウンドスレッドが存在する可能性があります。キャッシュが populated され、リゾルバがアクティブな状態を維持している場合、解決コールバックは即座に呼び出されます。アイドル状態のときは、バックグラウンドスレッドでさらに取得し、TTLを評価するのに少し時間がかかります。この場合、コールバックはバックグラウンドスレッドから呼び出されます。

---

TTLと接続失敗に関するいくつかの注意点。

最大TTLを尊重しようとしますが、DNSクエリが失敗している場合や、すべての接続が失敗としてマークされている場合は尊重しません。DNSを再度クエリできるようになったら、TTLを再評価します。

接続失敗の通知を受けた場合、それらを別のリストに移動します。最終的には、エンドポイントが再び正常である可能性が高いときや、他に選択肢がない場合に再試行しますが、ホットパスからはできるだけ外すようにします。

---

最後に、この設計全体は、開発者が大きなTTL（つまり、スティッキーホスト）と短いTTL（つまり、良好なフリート利用）を選択しなければならない問題を防ぐことを試みていますが、今ではレイテンシが高くなります。この設計では、バックグラウンドで毎秒解決します（実際にレコードを使用している間のみ）。ただし、最大TTLが経過するまで、以前に解決されたアドレスは期限切れになりません。

たとえば、これにより、1つまたは2つのホストではなく、Amazon S3フリート内の数千のホストにアクセスできるようになります。

### プロトタイプ

```c
struct aws_host_resolver *aws_host_resolver_new_default( struct aws_allocator *allocator, const struct aws_host_resolver_default_options *options);
```
