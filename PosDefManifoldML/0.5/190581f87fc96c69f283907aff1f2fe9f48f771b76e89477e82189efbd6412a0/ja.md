```julia
function cvSetup(y            :: Vector{Int64},  
                 nCV          :: Int64;           
                 shuffle      :: Bool = false,
                 seed         :: Int = 1234)
```

与えられたラベルのベクトル `y` とパラメータ `nCV` に基づいて、この関数はクラスごとに整理された nCV-フォールド交差検証セットのインデックスを生成します。

この関数は、すべてのフォールドで同じクラス分布を維持することによって層化交差検証を実行します。これにより、各フォールドには完全なデータセットと同じ割合のサンプルが各クラスから含まれることが保証されます。

各要素は、すべてのフォールドでテストサンプルとして正確に1回使用され、データセット全体がカバーされることを保証します。

`shuffle` パラメータは、各クラス内のインデックスがランダム化されるかどうかを制御します。`shuffle` が false（デフォルト）の場合、元のインデックスの順序が保持され、複数回の実行で一貫した結果が得られます。

`shuffle` が true の場合、各クラス内のインデックスは交差検証フォールドを作成する前にランダムに置換されます。ランダム化は `seed` パラメータ（デフォルト: 1234）によって制御されます。同じ `seed` 値を使用すると、同一の交差検証セットが生成されます。異なる `seed` 値を使用すると、異なるランダムな分割が生成されます。

この `shuffle` と `seed` パラメータの組み合わせにより、一貫した実験のための再現可能なランダム分割を生成し、結果の堅牢性を評価するために異なるランダムな分割を作成し、交差検証実験の正確な再現性を維持することができます。

この関数は [`crval`](@ref) で使用されます。カスタマイズされた交差検証手続きを実装するための基本的な基盤を構成します。

2-タプル (indTr, indTe) を返します。ここで：

  * indTr は、indTr[i][f] にフォールド f のクラス i のトレーニングインデックスが含まれる配列の配列です。
  * indTe は、indTe[i][f] にフォールド f のクラス i のテストインデックスが含まれる配列の配列です。

各配列はクラスごとに整理され、その後フォールドごとに整理され、交差検証セット全体で層化サンプリングが保証されます。

**例**

```julia
using PosDefManifoldML, PosDefManifold

y = [1,1,1,1,2,2,2,2,2,2]

cvSetup(y, 2)
# returns:
# Training Arrays:
#   Class 1: Array{Int64}[[3, 4], [1, 2]]
#   Class 2: Array{Int64}[[4, 5, 6], [1, 2, 3]]
# Testing Arrays:
#   Class 1: Array{Int64}[[1, 2], [3, 4]]
#   Class 2: Array{Int64}[[1, 2, 3], [4, 5, 6]]

cvSetup(y, 2; shuffle=true, seed=1)
# returns:
# Training Arrays:
#   Class 1: Array{Int64}[[1, 4], [2, 3]]
#   Class 2: Array{Int64}[[1, 3, 4], [2, 5, 6]]
# Testing Arrays:
#   Class 1: Array{Int64}[[2, 3], [1, 4]]
#   Class 2: Array{Int64}[[2, 5, 6], [1, 3, 4]]

cvSetup(y, 3)
# returns:
# Training Arrays:
#   Class 1: Array{Int64}[[2, 3], [1, 3, 4], [1, 2, 4]]
#   Class 2: Array{Int64}[[3, 4, 5, 6], [1, 2, 5, 6], [1, 2, 3, 4]]
# Testing Arrays:
#   Class 1: Array{Int64}[[1, 4], [2], [3]]
#   Class 2: Array{Int64}[[1, 2], [3, 4], [5, 6]]
```
