```julia
function tsWeights(y::Vector{Int}; classWeights=[])
```

与えられたラベルの[IntVector](@ref) `y` に対して、全クラスの全体的な重みが同じになるように1に合計される重みのベクトルを返します（バランスを取る）。これは、平均を計算するための接平面における機械学習モデルにとって有用であり、すなわち、PD行列を接平面にマッピングするための基準点です。このマッピングでは、すべての観測に等しい重みを与えると、実際には大きなクラスが過剰に重視され、小さなクラスが軽視されます。

*n* クラスのクラスラベルは最初の*n* 自然数でなければならず、すなわち、クラス1には `1`、クラス2には `2` などです。`y` のラベルは任意の順序で提供できます。

オプションのキーワード引数 `classWeights` として*n* 重みのベクトルが指定されている場合、各クラスの全体的な重みはまずバランスが取られ（上記を参照）、次に `classWeights` によって重み付けされます。これにより、各クラスの観測数に依存せずに重みをユーザー定義で制御できます。`classWeights` の重みは任意の整数または実数の非負数であることができます。返される重みベクトルはそれでも1に合計されます。

接平面モデルのために[`fit`](@ref)関数を呼び出すとき、この関数は実際には必要ありません。シンボル `:balanced`（または単に `:b`）を渡すか、オプションのキーワード引数 `w` としてクラス重みのタプルを渡すことで暗黙的に呼び出すことができます。

**例**

```julia
# データを生成する; クラスは不均衡です
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.1)

# ENLRラッソモデルをフィットさせ、交差検証によって最良のモデルを見つける
# 接平面マッピングのために重みをバランスさせる
m=fit(ENLR(), PTr, yTr; w=tsWeights(yTr))

# より簡単な構文は
m=fit(ENLR(), PTr, yTr; w=:balanced)

# 重みをバランスさせた後、クラス1に全体重0.5を与え
# クラス2に1.5を与えるには:
m=fit(ENLR(), PTr, yTr; w=(0.5, 1.5))

# これは次のように等価です
m=fit(ENLR(), PTr, yTr; w=tsWeights(yTr; classWeights=(0.5, 1.5)))

```

これがどのように機能するか:

```julia
using PosDefManifoldML

# これがラベルだと仮定します:

y=[1, 1, 1, 1, 2, 2]

# クラス1の4つの観測がクラス2の2つの観測と同じくらいの重みを持つようにしたい。

tsWeights(y)

# 6-element Array{Float64,1}:
# 0.125
# 0.125
# 0.125
# 0.125
# 0.25
# 0.25

# すなわち、0.125*4 = 1.25*2
# そしてすべての重みは1に合計されます

# さて、クラス2にクラス1の4倍の重みを与えたいとします:

tsWeights(y, classWeights=[1, 4])

# 6-element Array{Float64,1}:
# 0.05
# 0.05
# 0.05
# 0.05
# 0.4
# 0.4

# そして、再びすべての重みは1に合計されます。
```
