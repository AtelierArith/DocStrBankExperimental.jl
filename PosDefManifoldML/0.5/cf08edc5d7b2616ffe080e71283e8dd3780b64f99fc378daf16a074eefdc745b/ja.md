```julia
function transform!(𝐐 :: Union{ℍVector, ℍ}, pipeline :: Union{Pipeline, Conditioner})

```

適合された [`Pipeline`](@ref)（または単一の `Conditioner`）を使用して、フィッティングプロセス中に学習されたパラメータを用いて $𝐐$ 内のすべての行列を変換します。$𝐐$ を返します。

トレーニング-テスト設定では、フィッティングされたコンディショナーまたはパイプラインがこの関数に引数として渡され、テストデータがトレーニングデータのフィッティング中に学習されたパラメータに従って変換されることを保証します。一般的には、この関数は $𝐐$ 内のデータを任意の方法で変換するために使用できます。

`pipeline` が空のタプルの場合、何もせずに $𝐐$ を返します。

$$
𝐐
$$

は単一のエルミート行列または [ℍVector 型のベクトル](@ref) であり、インプレースで変換されます。

!!! warning "次元"
    $$
    𝐐
    $$

    内の行列の次元は、コンディショナーまたはパイプラインのフィッティングに使用された行列の次元と同じでなければなりません。


`fit!` 関数とは対照的に、インスタンス化されたコンディショナーのみが使用できます。一般的な使用において、これはユーザーにとって透明であり、[`fit!`](@ref) 関数は常にインスタンス化されたコンディショナーを持つパイプラインを返します。

**参照**: [`fit!`](@ref)

**例**

```julia
using PosDefManifoldML, PosDefManifold

## 例 1（単一のコンディショナー）

# 一部の「トレーニング」と「テスト」データを生成
PTr=randP(3, 20) # 20 のランダムな 3x3 エルミート行列
PTe=randP(3, 5) # 5 のランダムな 3x3 エルミート行列

# デフォルトの再中心化コンディショナー（ホワイトニング）をフィット
# PTr の行列が変換されます（再中心化されます）
R = fit!(PTr, Recenter()) 

# 上記の再中心化を使用して PTe を変換
# フィッティングプロセス中に PTr で学習された再中心化のパラメータを使用します。 
transform!(PTe, R)

mean(PTr)-I # ゼロ行列に近いはずです。
mean(PTe)-I # ゼロ行列に近くないはずです
# 再中心化パラメータは PTr で学習されているため、PTe ではありません。

## 例 2（パイプライン）

# 一部の「トレーニング」と「テスト」データを生成
PTr=randP(3, 20) # 20 のランダムな 3x3 エルミート行列
PTe=randP(3, 5) # 5 のランダムな 3x3 エルミート行列
QTr=copy(PTr)
QTe=copy(PTe)

p = @→ Tikhonov(0.0002) Recenter(; eVar=0.99) Compress Shrink(Fisher; radius=0.01)
pipeline = fit!(QTr, p)
transform!(QTe, pipeline)

## 例 3（単一のコンディショナーを持つパイプライン）:
P=randP(3, 5)  
# Equalize コンディショナーにはデータをフィットさせる必要はありません
transform!(P, @→ Equalize)
# これはエラーを引き起こします。Recenter はパラメータを学習する必要があります（代わりに fit! を使用してください）:
transform!(P, @→ Recenter)
```
