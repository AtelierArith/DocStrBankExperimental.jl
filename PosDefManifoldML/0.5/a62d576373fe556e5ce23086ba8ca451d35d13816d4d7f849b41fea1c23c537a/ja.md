```julia
    function fit!(𝐏 :: ℍVector, pipeline :: Union{Pipeline, Conditioner}; 
        transform = true,
        labels = nothing)
```

与えられた [`Pipeline`](@ref) （または単一の `Conditioner`）を $𝐏$ にフィットさせ、フィットした `Pipeline` オブジェクトを返します。 $𝐏$ は [ℍVector 型](@ref) でなければなりません。

単一の `Conditioner` をパイプラインの代わりに引数として指定できます。その場合、単一の要素を持つフィットしたパイプラインが返されます。条件付けの型も指定できます。その場合、デフォルトの条件付けが使用されます - 以下の例を参照してください。

`pipeline` が空のタプルの場合、何もせずに空のパイプラインを返します。

`transform` が true（デフォルト）である場合、$𝐏$ は変換されます（インプレース）、そうでない場合はパイプラインがフィットされますが、$𝐏$ は変換されません。

`labels` が $𝐏$ の点のクラスラベルを保持する整数のベクトルである場合、条件付けは監視付き（*すなわち*、ラベルを意識した）になります。そうでない場合、`nothing`（デフォルト）の場合は非監視付きになります。現在、監視付きで動作できる唯一の条件付けは [`Recenter`](@ref) です。監視付きの場合、再中心化のための重心は各クラスにバランスの取れた重みを与えて計算されます。これは、接線空間マッピングに使用される重心を計算するために [`tsWeights`](@ref) が行うことと同様です。クラスがバランスしている場合、重み付けは影響を与えません。

返されたパイプラインは、フィットしたパラメータが適切に適用されることを保証するために [`transform!`](@ref) 関数の引数として使用できます。また、[`saveas`](@ref) 関数を使用してファイルに保存し、[`load`](@ref) 関数を使用してファイルから読み込むこともできます。

引数として与えられたパイプラインは変更されないことに注意してください。

**フィット中の学習パラメータ**

一部の条件付けには、トレーニング中に学習されるパラメータがありません。それらの場合、`fit!` 関数の呼び出しは、[`transform!`](@ref) 関数の呼び出しと同等です。ただし、`fit!` 関数が呼び出されると、変換に使用されるパラメータが返されたパイプラインに保存されるという例外があります。

**関連情報**: [`transform!`](@ref)

**例**

```julia
using PosDefManifoldML, PosDefManifold

## 例 1 （単一の条件付け）:

# データを生成
P=randP(3, 5) # 5つのランダムな3x3エルミート行列
Q=copy(P)

# デフォルトの再中心化条件付け（ホワイトニング）をフィット
pipeline = fit!(P, Recenter) 

# これは次と同等です
pipeline = fit!(Q, Recenter())

pipeline[1].Z # 学習されたパラメータ（ホワイトニング行列）

## 例 2 （パイプライン）:

# ティコノフ正則化、再中心化、圧縮、フィッシャー計量に従った縮小を含むパイプラインをフィット。
# Pの行列は最初に正則化され、次に再中心化され、次に圧縮され、最後に縮小されます。

P=randP(3, 5)  
Q=copy(P)

pipeline = fit!(P, 
        @→ Tikhonov(0.0001) → Recenter → Compress → Shrink(Fisher; radius=0.01))

# または 
pipeline = fit!(Q, @→ Recenter Compress Shrink(Fisher; radius=0.01))

# 再中心化条件付けのホワイトニング行列、
pipeline[1].Z

# 圧縮条件付けのスケーリングファクター、
pipeline[2].β

# そして縮小条件付けのステップサイズ
pipeline[3]

## 例 3 （単一の条件付けを持つパイプライン）:
P=randP(3, 5)  
pipeline = fit!(P, @→ Recenter)
```
