```
statistics(
    parent_list::Vector{Vector{Int}},
    ncategories::AbstractVector{Int},
    data::AbstractMatrix{Int},
    )
```

離散データセットから離散ベイジアンネット構造のための十分統計量を計算します。

入力:     parents:         親インデックスのリストのリスト         インデックスiの変数はncategories[i]を持ち         data[i,:]の行にあります         非循環性のチェックは行われません     ncategories:         変数のビンカウントのリスト、または         変数が取ることができる離散値の数、v ∈ {1 : ncategories[i]}     data:         離散値のテーブル [n×m]         ここでnはノードの数         mはサンプルの数です。

出力:     N :: Vector{Matrix{Int}}         各変数のための十分統計量テーブル         インデックスiの変数は統計量テーブルN[i]を持ち、         これはr × qであり、         r = ncategories[i]は変数のインスタンス化の数であり、         qは変数iの親のインスタンス化の数です。

```
    r値は1 → ncategories[i]の順に並べられます。
    q値はJulia Baseのind2sub()と同じ順序で並べられます。
        したがって、最初の親のインスタンス化（parents[i]で与えられた順序による）は
        最も速く変化します。

    例:
        変数1は親2と3を持ち、r₁ = 2, r₂ = 2, r₃ = 3です。
        変数1のqはq = r₂×r₃ = 6です。
        N[1]は6×2の行列になります。ここで:
            N[1][1,1]はv₁ = 1, v₂ = 1, v₃ = 1の回数です。
            N[1][2,1]はv₁ = 1, v₂ = 2, v₃ = 1の回数です。
            N[1][3,1]はv₁ = 1, v₂ = 1, v₃ = 2の回数です。
            N[1][4,1]はv₁ = 1, v₂ = 2, v₃ = 2の回数です。
            N[1][5,1]はv₁ = 1, v₂ = 1, v₃ = 3の回数です。
            N[1][6,1]はv₁ = 1, v₂ = 2, v₃ = 3の回数です。
            N[1][6,2]はv₁ = 2, v₂ = 1, v₃ = 1の回数です。
            ...
```

この関数はスパース行列のブラックマジックを使用しており、Ed Schmerlingから無慈悲に盗まれました。
