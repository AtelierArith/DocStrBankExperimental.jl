```
sparse_triangular_solve(U::CSR{F}, B::CSR{F}, k::Int, xj::Vector{Int32}, x::Vector{ZZp{F}}, qinv::Vector{Int32})
```

x * U = B[k] を解きます。ここで、U は（順序が変更された）三角行列（上三角または下三角のいずれか）です。

x は m のサイズ（U の列数）を持たなければならず、初期化する必要はありません。xj はサイズ 3*m で事前に割り当てられ、ゼロ初期化されている必要があります（これは問題ありません）。qinv は U のピボットを特定します。

出力では、解は x に散在し、そのパターンは xj[top:m] に示されます。正確な意味は次のとおりです。定義します:          x*a = { j in [0:m] : qinv[j] < 0 }          x*b = { j in [0:m] : qinv[j] >= 0 } すると、x*b * U + x*a == B[k] となります。したがって、x * U == y の解が存在するのは x_a が空である場合に限ります。

top は戻り値です。

これは、ピボットが行の最初のエントリである必要はありません。これは、U のピボットがすべて 1 であることを要求します。
