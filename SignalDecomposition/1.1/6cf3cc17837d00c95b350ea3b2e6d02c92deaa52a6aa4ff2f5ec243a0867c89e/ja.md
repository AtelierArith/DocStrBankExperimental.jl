```
ProductInversion(r, μ; verbose=false) <: Decomposition
```

時系列 `s` を **積** `x * r` に分解します。ここで、第二の要素 `r`（"入力"）の良い推定値があり、`x`（"乗数"）が必要ですが、単純に `x = s ./ r` を行うことはできません。なぜなら `r` にゼロが含まれているからです。

このメソッドは、`x` の特性時間スケールが `r` のそれと比較可能であるか、またはそれより大きいが、あまり小さくない場合にうまく機能します。

第二の引数 `μ` は正則化パラメータです。簡単に言うと、私たちは `x` が `s/r` に近いことと `x` が滑らかであることの2つの要素を持つコストを最小化することによって `r` を推定します。`μ` は滑らかさコストの乗数です。

ベクトルを `μ` として指定することができます。このプロセスはすべての `μ` に対して繰り返され、推定された `x * r` と `s` の間の [`rmse`](@ref) が計算されます。最も少ない誤差を与える `x` が最終的に返されます。`verbose = true` の場合、メソッドは各 `μ` に対してペア `(μ, err)` も印刷します。

エラー値を取得するには、低レベルの `SignalDecomposition.matrix_invert(s, r, μ::Real) → x, err` を使用してください。
