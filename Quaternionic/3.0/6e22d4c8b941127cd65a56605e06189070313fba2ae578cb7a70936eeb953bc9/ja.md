```
align(A, B, [w])
```

セットのローター `A` を対応するセット `B` に整列させる `Rotor` を見つけ、最初のセットと回転された第二のセットとの距離を最小化します。

ここで、`A` と `B` は等しいサイズの `AbstractQuaternion` の配列でなければなりません。もし存在する場合、`w` は等しいサイズの実数の配列でなければなりません。存在しない場合は、1と見なされます。損失関数を次のように定義します。

$$
L(R) ≔ Σᵢ wᵢ |Aᵢ - R Bᵢ|²
$$

ここで $R$ は `Rotor` であり、この関数を最小化する最適な $R$ に対応するクォータニオンを返します。

入力データがローターを一意に決定しない可能性があることに注意してください。これは、下の合計がゼロになるときに発生します。この場合、結果には `NaN` が含まれますが、エラーは発生しません。合計がゼロに非常に近いが、正確にはゼロでない場合、結果の精度は制限されます。しかし、その場合、損失関数は結果に強く依存しません。

この関数は入力クォータニオンの符号に敏感であることに注意してください。符号に関連する問題を回避する方法の一つとして、[`unflip`](@ref) 関数を参照してください。

## ノート

損失関数が最小化されることを保証するために、$R$ に指数を掛け、指数の引数に関して微分し、その引数を0に設定します。この導関数は最小値で0であるべきです。次のようになります。

$$
∂ⱼ Σᵢ wᵢ |Aᵢ - \exp[vⱼ] R Bᵢ|²  →  2 ⟨ eⱼ R Σᵢ wᵢ Bᵢ Āᵢ ⟩₀
$$

ここで → は $vⱼ→0$ を取ることを示し、記号 $⟨⟩₀$ はスカラー部分を取ることを示し、$eⱼ$ は $j$ 方向の単位クォータニオンベクトルです。この量が各 $j$ の選択に対してゼロになる唯一の方法は、

$$
R Σᵢ wᵢ Bᵢ Āᵢ
$$

が純粋なスカラーである場合です。これは、(1) 合計が0であるか、(2) $R$ が合計の*共役*に比例する場合にのみ発生します。

$$
R ∝ Σᵢ wᵢ Aᵢ B̄ᵢ
$$

したがって、$R$ をローターにしたいので、単に正規化された合計として定義します。 ```
