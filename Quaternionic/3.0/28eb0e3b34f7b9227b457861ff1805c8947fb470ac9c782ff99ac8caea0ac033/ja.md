```
Rotor{T<:Number} <: Number
```

単位の大きさを持つ四元数で、要素の型は `T` です。これらのオブジェクトは、回転を表す特定の操作において、かなり高速かつより正確である可能性があります。

ロターは通常、群 $\mathrm{Spin}(3) ≃ \mathrm{SU}(2)$ の要素と見なされ、これはノルムが 1 の四元数の部分群と考えることができます。ロター $R$ はベクトル $\vec{v}$ に「共役作用」を行い、

$$
\vec{v}' = R\, \vec{v}\, R^{-1}.
$$

と表されます（これはコードでは `R * v / R` または、より効率的には `R(v)` として表現できます）。この操作は、この方法で共役された任意の二つのベクトル間の内積を保持するため、回転となります。ここに $R$ が二つの因子があるため、$R$ の符号は結果に影響を与えません。したがって、$\mathrm{Spin}(3)$ は回転群 $\mathrm{SO}(3)$ の *二重* カバーを形成します。この理由から、`Rotor` の符号を無視したり恣意的に変更したりすることが時折有用です（例えば [`distance`](@ref) 関数のように） — ただし、これは一般的にはデフォルトではなく、対応する回転がそれほど異ならない場合に入力ロターが符号を変更すると問題を引き起こす可能性があります（cf. [`unflip`](@ref)）。

`RotorF16`、`RotorF32` および `RotorF64` はそれぞれ `Rotor{Float16}`、`Rotor{Float32}` および `Rotor{Float64}` のエイリアスです。さらに [`Quaternion`](@ref) および [`QuatVec`](@ref) も参照してください。

関数

```
rotor(w, x, y, z)
rotor(w)
```

は、与えられた成分を持つ新しいロターを作成します（成分は [`Quaternion`](@ref) に記載されている通りです）、入力時に自動的に正規化されます。この正規化ステップは `Rotor` と `rotor` 関数の主な違いです。正規化をバイパスしたい場合は、次のように呼び出すことができます。

```
Rotor{T}(w, x, y, z)
Rotor{T}(w)
```

この場合、`w, x, y, z` は型 `T` に変換されます。あるいは、次のように呼び出すこともできます。

```
Rotor{T}(v)
```

ここで `v<:AbstractArray` は `SVector{4, T}` に変換可能です。正規化ステップを処理したい場合は、[`normalize`](@ref) を使用できます。

ただし、一度 `Rotor` が作成されると、そのノルムはしばしば *正確に* 1 であると仮定されます。したがって、真のノルムが大きく異なる場合、奇妙な結果が見られる可能性があります — 例えば、非単位の `Rotor` による「回転」後に非常に異なる長さのベクトルが得られることがあります。

ノルムが 1 である四元数を単に作成することは、それを `Rotor` にすることにはなりません。ただし、そのような `Quaternion` を `rotor` 関数に渡すことで、望ましい結果を得ることができます。

# 例

```jldoctest
julia> rotor(1, 2, 3, 4)
rotor(0.18257418583505536 + 0.3651483716701107𝐢 + 0.5477225575051661𝐣 + 0.7302967433402214𝐤)
julia> rotor(quaternion(1, 2, 3, 4))
rotor(0.18257418583505536 + 0.3651483716701107𝐢 + 0.5477225575051661𝐣 + 0.7302967433402214𝐤)
julia> Rotor{Float16}(1, 2, 3, 4)
rotor(1.0 + 2.0𝐢 + 3.0𝐣 + 4.0𝐤)
julia> normalize(Rotor{Float16}(1, 2, 3, 4))
rotor(0.1826 + 0.3652𝐢 + 0.548𝐣 + 0.7305𝐤)
julia> rotor(1.0)
rotor(1.0 + 0.0𝐢 + 0.0𝐣 + 0.0𝐤)
```
