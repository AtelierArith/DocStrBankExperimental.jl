モデル方程式を解析し、それらをオブジェクトに割り当てます。

# 引数

  * `𝓂`: モデル情報を含むオブジェクトの名前。
  * `ex`: 方程式

# `𝓂` と `ex` の間に置くオプション引数

  * `max_obc_horizon` [デフォルト: `40`, 型: `Int`]: 偶発的に制約が適用される予想されるショックの最大長さと、それに対応する無条件予測のホライズン。この制約を適用する解が見つからない場合は、この数値を増やしてください。

変数は、時間の添字を角括弧内に定義する必要があります。内生変数は以下のようにすることができます：

  * 現在: `c[0]`
  * 非確率的定常状態: `c[ss]` の代わりに、非確率的定常状態の有効なフラグとして以下のいずれかも使用できます: `ss`, `stst`, `steady`, `steadystate`, `steady_state`、パーサーは大文字小文字を区別しません（`SS` または `sTst` も有効です）。
  * 過去: `c[-1]` または任意の負の整数: 例: `c[-12]`
  * 未来: `c[1]` または任意の正の整数: 例: `c[16]` または `c[+16]`

符号付き整数はそのように認識され、解析されます。

外生変数（ショック）は以下のようにすることができます：

  * 現在: `eps_z[x]` の代わりに、外生変数の有効なフラグとして以下のいずれかも使用できます: `ex`, `exo`, `exogenous`、パーサーは大文字小文字を区別しません（`Ex` または `exoGenous` も有効です）。
  * 過去: `eps_z[x-1]`
  * 未来: `eps_z[x+1]`

パラメータは角括弧なしで方程式に入ります。

方程式に `max` または `min` 演算子が含まれている場合、モデルのデフォルトの動的（一次）解は偶発的に制約を適用します。関連する関数呼び出しで `ignore_obc = true` を設定することで、これを無視することができます。

# 例

```julia
using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end
```

# プログラムによるモデル記述

パラメータと変数は波括弧を使用してインデックス付けできます: 例: `c{H}[0]`, `eps_z{F}[x]`, または `α{H}`。

`for` ループを使用してモデルをプログラム的に記述できます。これらは、時間インデックスまたは波括弧内のインデックスを反復する式を生成するために使用できます：

  * 波括弧内の異なるインデックスを持つ方程式を生成: `for co in [H,F] C{co}[0] + X{co}[0] + Z{co}[0] - Z{co}[-1] end = for co in [H,F] Y{co}[0] end`
  * 波括弧内の異なるインデックスを持つ複数の方程式を生成: `for co in [H, F] K{co}[0] = (1-delta{co}) * K{co}[-1] + S{co}[0] end`
  * 異なる時間インデックスを持つ方程式を生成: `Y_annual[0] = for lag in -3:0 Y[lag] end` または `R_annual[0] = for operator = :*, lag in -3:0 R[lag] end`
