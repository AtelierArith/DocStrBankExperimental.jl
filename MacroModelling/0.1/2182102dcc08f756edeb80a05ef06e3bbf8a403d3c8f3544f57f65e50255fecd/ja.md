以前に定義されたモデルにパラメータ値とキャリブレーション方程式を追加します。非確率的定常状態（NSSS）の初期推測を提供することができます。

# 引数

  * `𝓂`: モデル情報を含む以前に作成されたオブジェクトの名前。
  * `ex`: パラメータ、パラメータ値、およびキャリブレーション方程式

パラメータは以下のいずれかの方法で定義できます：

  * 単純な数値: `δ = 0.02`
  * 数字を含む式: `δ = 1/50`
  * 他のパラメータを含む式: `δ = 2 * std_z` この場合、`std_z` が前または後に定義されているかは無関係です。他のパラメータを含む定義は方程式のシステムとして扱われ、それに応じて解決されます。
  * 目標パラメータと非確率的定常状態の内生変数を含む方程式、他のパラメータ、または数値を含む式: `k[ss] / (4 * q[ss]) = 1.5 | δ` または `α | 4 * q[ss] = δ * k[ss]` この場合、目標パラメータはそれに定義された方程式を使用して非確率的定常状態と同時に解決されます。

# `𝓂` と `ex` の間に配置するオプション引数

  * `guess` [タイプ: `Dict{Symbol, <:Real}, Dict{String, <:Real}}`]: 非確率的定常状態の推測。キーは変数（およびキャリブレーションパラメータ）の名前で、値は推測です。欠落している値は標準の開始値で埋められます。
  * `verbose` [デフォルト: `false`, タイプ: `Bool`]: 非確率的定常状態がどのように解決されるかについての詳細情報を印刷します。
  * `silent` [デフォルト: `false`, タイプ: `Bool`]: 何の情報も印刷しません。
  * `symbolic` [デフォルト: `false`, タイプ: `Bool`]: 非確率的定常状態を象徴的に解決し、可能でない場合は数値解にフォールバックします。
  * `perturbation_order` [デフォルト: `1`, タイプ: `Int`]: この段階で指定された次数までの導関数のみを取ります。後で高次の摂動を扱いたい場合は、その段階でそれに応じた導関数が取られます。
  * `simplify` [デフォルト: `true`, タイプ: `Bool`]: 冗長な変数を排除し、非確率的定常状態（NSSS）問題を簡素化するかどうか。これを `false` に設定するとプロセスが速くなる可能性がありますが、NSSSを見つけるのが難しくなるかもしれません。モデルが全く解析できない場合（ステップ1または2で）、このオプションを `false` に設定すると解決できるかもしれません。

# 例

```julia
using MacroModelling

@model RBC begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC verbose = true begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    α = 0.5
    β = 0.95
end

@model RBC_calibrated begin
    1  /  c[0] = (β  /  c[1]) * (α * exp(z[1]) * k[0]^(α - 1) + (1 - δ))
    c[0] + k[0] = (1 - δ) * k[-1] + q[0]
    q[0] = exp(z[0]) * k[-1]^α
    z[0] = ρ * z[-1] + std_z * eps_z[x]
end

@parameters RBC_calibrated verbose = true guess = Dict(:k => 3) begin
    std_z = 0.01
    ρ = 0.2
    δ = 0.02
    k[ss] / q[ss] = 2.5 | α
    β = 0.95
end
```

# プログラムによるモデル記述

波括弧でインデックス付けされた変数とパラメータは、特定に参照することも（例: `c{H}[ss]`）、一般に参照することもできます（例: `alpha`）。一般に参照される場合、解析はすべてのインスタンス（インデックス）が意図されていると仮定します。たとえば、`alpha` に `H` と `F` の2つのインデックスがあるモデルでは、式 `alpha = 0.3` は2つの式として解釈されます: `alpha{H} = 0.3` と `alpha{F} = 0.3`。キャリブレーション方程式についても同様です。
