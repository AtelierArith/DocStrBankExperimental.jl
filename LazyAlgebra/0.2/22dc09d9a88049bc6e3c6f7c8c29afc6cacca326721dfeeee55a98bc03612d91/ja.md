`Mapping`は2つの変数空間間の任意の関数です。大文字のラテン文字がマッピングを示し、小文字のラテン文字が変数を示し、ギリシャ文字がスカラーを示すと仮定すると：

  * `A*x`または`A⋅x`は、マッピング`A`を`x`に適用した結果を返します；
  * `A\x`は、`A`の逆を`x`に適用した結果を返します；

単純な構成は、任意の種類のマッピングに対して許可されており、正しく動作する新しいマッピングのインスタンスを作成するために使用できます。例えば：

  * `B = α*A`（ここで`α`は実数）は、`A`に`α`を掛けたように動作するマッピングです；つまり、`B⋅x`は`α*(A⋅x)`と同じ結果を返します。
  * `C = A + B + ...`は、マッピング`A`、`B`、...の和として動作するマッピングです；つまり、`C⋅x`は`A⋅x + B⋅x + ...`と同じ結果を返します。
  * `C = A*B`または`C = A⋅B`は、マッピング`A`と`B`の合成として動作するマッピングです；つまり、`C⋅x`は`A⋅(B.x)`と同じ結果を返します。マッピングの和と同様に、合成には任意の数のマッピングが含まれる場合があります；例えば、`D = A*B*C`の場合、`D⋅x`は`A⋅(B⋅(C⋅x))`と同じ結果を返します。
  * `C = A\B`は、`C⋅x`が`A\(B⋅x)`と同じ結果を返すマッピングです。
  * `C = A/B`は、`C⋅x`が`A⋅(B\x)`と同じ結果を返すマッピングです。

これらの構成は、より複雑なマッピングを構築するために組み合わせることができます。例えば：

  * `D = A*(B + C)`は、`C⋅x`が`A⋅(B⋅x + C⋅x)`と同じ結果を返すマッピングです。

`LinearMapping`は、2つの空間間の任意の線形マッピングです。この`Mapping`の抽象サブタイプは、*行列*と*ベクトル*の概念を拡張するために導入されます。`A`の型が`LinearMapping`から継承されると仮定すると：

  * `A'⋅x`および`A'*x`は、マッピング`A`の随伴を`x`に適用した結果を返します；
  * `A'\x`は、マッピング`A`の逆の随伴を`x`に適用した結果を返します。
  * `B = A'`は、`B⋅x`が`A'⋅x`と同じ結果を返すマッピングです。

特定の型`M <: Mapping`のマッピング`A`に対して、以下のメソッドを実装する必要があります：

```julia
vcreate(::Type{P}, A::M, x, scratch::Bool) -> y
apply!(α::Number, ::Type{P}, A::M, x, scratch::Bool, β::Number, y) -> y
```

任意のサポートされている操作`P ∈ Operations`（`Direct`、`Adjoint`、`Inverse`および/または`InverseAdjoint`）。これらのメソッドの説明については、ドキュメントを参照してください。オプションとして、`P(A)`メソッドを拡張することができます。*例*：操作`P`が禁止されている場合（または実装されていない場合）に例外をスローします。デフォルトでは、これらの操作はすべて可能であると仮定されます（非線形マッピングに対する`Adjoint`および`InverseAdjoint`を除く）。

また、次も参照してください：[`apply`](@ref)、[`apply!`](@ref)、[`vcreate`](@ref)、           [`LinearType`](@ref)、[`Scalar`](@ref)、[`Direct`](@ref)、           [`Adjoint`](@ref)、[`Inverse`](@ref)、[`InverseAdjoint`](@ref)。
