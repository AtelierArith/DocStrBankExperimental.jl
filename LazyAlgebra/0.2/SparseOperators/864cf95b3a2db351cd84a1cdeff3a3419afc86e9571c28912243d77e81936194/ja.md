*圧縮スパース座標* (COO) 形式のスパース演算子は、重要なエントリを特に順序付けることなく、値のベクトル、線形行インデックスのベクトル、および線形列インデックスのベクトルとして格納します。繰り返しエントリを持つことも可能です。この形式は、スパース線形演算子を構築するのに非常に便利です。スパース線形マッピングまたはその随伴の高速な適用のために、*圧縮スパース列* (CSC) または *圧縮スパース行* (CSR) のようなより効率的な形式に変換できます。

COO ストレージ形式のスパース演算子は、必要なすべての情報を提供することで構築できます：

```
SparseOperatorCOO(vals, rows, cols, rowsiz, colsiz)
```

ここで `vals` はスパースエントリの値のベクトル、`rows` と `cols` はスパースエントリの線形行および列インデックスを持つ整数値のベクトル、`rowsiz` と `colsiz` は行および列の次元のサイズです。`k` 番目のスパースエントリの値とそれに対応する線形行および列インデックスはそれぞれ `vals[k]`、`rows[k]`、`cols[k]` で与えられます。効率の理由から、スパース演算子は現在 *高速* 配列に制限されています。なぜなら、それらは性能を損なうことなく線形にインデックス付けできるからです。`vals`、`rows`、および/または `cols` が高速配列でない場合、自動的に線形インデックス配列に変換されます。

COO ストレージ形式のスパース演算子は、2 次元の Julia 配列 `A` から直接構築できます：

```
SparseOperatorCOO(A, sel = (v,i,j) -> (v != zero(v)))
```

ここで、オプションの引数 `sel` はセレクタ関数であり、`sel(v,i,j)` として呼び出され、`v`、`i`、`j` はそれぞれ `A` の各エントリの値、行、列の線形インデックスであり、スパース構造で選択されるべき `A` のエントリに対して `true` を返し、破棄されるべき `A` のエントリに対して `false` を返すと仮定されます。デフォルトのセレクタは、`A` のすべての非ゼロを選択するようになっています。

スパース係数の要素型、例えば `T`、は上記の例を次のように書き換えることで指定できます：

```
SparseOperatorCOO{T}(args...)
```

一般化された行列-ベクトル乗算を実装する COO ストレージ形式のスパース演算子は、`L` 次元の Julia 配列 (ここで `L ≥ 2`) `A` からも直接構築できます：

```
SparseOperatorCOO{T,M}(A[, sel])
```

ここで `M` は演算子の *行* に対応する `A` の先頭次元の数であり、末尾の `N = L - M` 次元は演算子の *列* に対応すると仮定されます。これらの次元は、演算子を適用する際の出力および入力配列のサイズです。パラメータ `N` は指定できます (自動的に決定されることもあります)：

```
SparseOperatorCOO{T,M,N}(A[, sel])
```

ただし、等式 `M + N = ndims(A)` が成り立つ必要があります。

最後のパラメータ `V` は、スパース演算子の係数を格納するベクトルの型を指定できます：

```
SparseOperatorCOO{T,M,N,V}(args...)
```

ただし、`V` は標準の線形インデックスを実装している必要があります。デフォルトは `V = Vector{T}` です。特別なケースとして、スパース係数を格納するために `StructuredArrays` パッケージから均一なブールベクトルを選択できます：

```
SparseOperatorCOO{T,M,N,UniformVector{Bool}}(args...)
```

これにより、値が不変の均一な真のベクトルであり、ストレージを必要としない圧縮スパース演算子が COO 形式で得られます。これは、演算子のスパース構造、すなわちスパース係数の値ではなく COO 形式のインデックスのみを格納するのに便利です。

`SparseOperatorCOO` コンストラクタは、他のストレージ形式のスパース演算子を COO 形式に変換するためにも使用できます。その場合、パラメータ `T` もスパース係数の型を変換するために指定できます。
