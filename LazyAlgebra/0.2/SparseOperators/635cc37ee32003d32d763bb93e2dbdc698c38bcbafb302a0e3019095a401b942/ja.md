*圧縮スパース列* (CSC) 形式のスパース演算子は、重要なエントリを列ごとに順序付けて格納し、値のベクトル、対応する線形行インデックスのベクトル、および各列に対して値と行インデックスのベクトル内のインデックス範囲を示すオフセットのベクトルを持ちます。このストレージ形式は、特にその随伴演算子の高速な適用に非常に適しています。

CSC ストレージ形式のスパース演算子は、必要なすべての情報を提供することで構築できます：

```
SparseOperatorCSC(vals, rows, offs, rowsiz, colsiz)
```

ここで `vals` はスパースエントリの値のベクトル、`rows` はスパースエントリの線形行インデックスの整数値ベクトル、`offs` はこれらの配列のオフセットの列ごとのテーブル、`rowsiz` と `colsiz` は行と列の次元のサイズです。`j` 番目の列のエントリ値とそれに対応する線形行インデックスは、`vals[k]` と `rows[k]` で与えられ、`k ∈ offs[j]+1:offs[j+1]` です。線形列インデックス `j` は `1:n` の範囲にあり、ここで `n = prod(colsiz)` は列の同等の数です。効率の理由から、スパース演算子は現在 *高速* 配列に制限されています。なぜなら、それらは性能の損失なしに線形にインデックス付けできるからです。`vals`、`rows` および/または `offs` が高速配列でない場合、自動的に線形インデックス配列に変換されます。

CSC ストレージ形式のスパース演算子は、2 次元の Julia 配列 `A` から直接構築できます：

```
SparseOperatorCSC(A, sel = (v,i,j) -> (v != zero(v)))
```

ここでオプションの引数 `sel` はセレクタ関数であり、`sel(v,i,j)` として呼び出され、`v`、`i`、`j` はそれぞれ `A` の各エントリの値、行、列の線形インデックスであり、スパース構造に選択される `A` のエントリに対して `true` を返し、破棄される `A` のエントリに対して `false` を返すと仮定されます。デフォルトのセレクタは、`A` のすべての非ゼロを選択するようになっています。

スパース係数の要素型、たとえば `T` は、上記の例を次のように書き換えることで指定できます：

```
SparseOperatorCSC{T}(args...)
```

一般化された行列-ベクトル乗算を実装する CSC ストレージ形式のスパース演算子は、`L` 次元の Julia 配列 (ここで `L ≥ 2`) `A` からも直接構築できます：

```
SparseOperatorCSC{T,M}(A[, sel])
```

ここで `M` は、演算子の *行* に対応する `A` の先頭次元の数であり、末尾の `N = L - M` 次元は演算子の *列* に対応すると仮定されます。これらの次元は、演算子を適用する際の出力および入力配列のサイズです。パラメータ `N` は指定できます (自動的に決定されることもあります)：

```
SparseOperatorCSC{T,M,N}(A[, sel])
```

ただし、等式 `M + N = ndims(A)` が成り立つ必要があります。

最後のパラメータ `V` は、スパース演算子の係数を格納するベクトルの型を指定できます：

```
SparseOperatorCSC{T,M,N,V}(args...)
```

ただし、`V` は標準の線形インデックスを実装している必要があります。デフォルトは `V = Vector{T}` を取ります。特別なケースとして、スパース係数を格納するために `StructuredArrays` パッケージから均一なブールベクトルを選択できます：

```
SparseOperatorCSC{T,M,N,UniformVector{Bool}}(args...)
```

これにより、値が不変の均一な真の値のベクトルであり、ストレージを必要としない圧縮スパース演算子が CSC 形式で得られます。これは、演算子のスパース構造、すなわちスパース係数のインデックスを CSC 形式で格納するためにのみ役立ちます。

`SparseOperatorCSC` コンストラクタは、他のストレージ形式のスパース演算子を CSC 形式に変換するためにも使用できます。その場合、パラメータ `T` もスパース係数の型を変換するために指定できます。
