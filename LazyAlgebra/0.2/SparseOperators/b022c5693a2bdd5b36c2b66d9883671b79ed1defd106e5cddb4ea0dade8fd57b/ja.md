*Compressed Sparse Row* (CSR) 形式のスパース演算子は、重要なエントリを行単位で格納し、値のベクトル、対応する線形列インデックスのベクトル、および各行の値と列インデックスのベクトル内のインデックスの範囲を示すオフセットのベクトルを持ちます。このストレージ形式は、演算子の高速な適用に非常に適しています。

CSR ストレージ形式のスパース演算子は、必要なすべての情報を提供することで構築できます：

```
SparseOperatorCSR(vals, cols, offs, rowsiz, colsiz)
```

ここで `vals` はスパースエントリの値のベクトル、`cols` はスパースエントリの線形列インデックスの整数値ベクトル、`offs` はこれらの配列内のオフセットの列単位のテーブル、`rowsiz` と `colsiz` は行と列の次元のサイズです。`i` 行目のエントリの値とそれに対応する線形列インデックスは、`vals[k]` と `cols[k]` で与えられ、`k ∈ offs[i]+1:offs[i+1]` です。線形行インデックス `i` は `1:m` の範囲にあり、ここで `m = prod(rowsiz)` は行の同等数です。効率の理由から、スパース演算子は現在 *fast* 配列に制限されています。なぜなら、それらは性能の低下なしに線形にインデックス付けできるからです。もし `vals`、`cols` および/または `offs` がファスト配列でない場合、自動的に線形インデックス配列に変換されます。

CSR ストレージ形式のスパース演算子は、2 次元の Julia 配列 `A` から直接構築できます：

```
SparseOperatorCSR(A, sel = (v,i,j) -> (v != zero(v)))
```

ここでオプションの引数 `sel` はセレクタ関数で、`sel(v,i,j)` として呼び出され、`v`、`i` および `j` は `A` の各エントリの値、行および列の線形インデックスであり、スパース構造で選択されるべき `A` のエントリに対して `true` を返し、破棄されるべきエントリに対して `false` を返すと仮定されます。デフォルトのセレクタは、`A` のすべての非ゼロを選択するようになっています。

スパース係数の要素型、例えば `T` は、上記の例を次のように書き換えることで指定できます：

```
SparseOperatorCSR{T}(args...)
```

一般化された行列-ベクトル乗算を実装する CSR ストレージ形式のスパース演算子は、次のようにして `L` 次元の Julia 配列 (ここで `L ≥ 2`) `A` から直接構築できます：

```
SparseOperatorCSR{T,M}(A[, sel])
```

ここで `M` は演算子の *行* に対応する `A` の先頭次元の数であり、末尾の `N = L - M` 次元は演算子の *列* に対応すると仮定されます。これらの次元は、演算子を適用する際の出力および入力配列のサイズです。パラメータ `N` は指定できます (自動的に決定されることもあります)：

```
SparseOperatorCSR{T,M,N}(A[, sel])
```

ただし、等式 `M + N = ndims(A)` が成り立つ必要があります。

最後のパラメータ `V` は、スパース演算子の係数を格納するベクトルの型を指定できます：

```
SparseOperatorCSR{T,M,N,V}(args...)
```

ただし、`V` は標準の線形インデックスを実装している必要があります。デフォルトは `V = Vector{T}` を取ります。特別なケースとして、スパース係数を格納するために `StructuredArrays` パッケージから均一なブールベクトルを選択できます：

```
SparseOperatorCSR{T,M,N,UniformVector{Bool}}(args...)
```

これにより、値が不変の均一な真の値のベクトルであり、ストレージを必要としない圧縮スパース演算子が CSR 形式で得られます。これは、演算子のスパース構造、すなわちスパース係数の CSR 形式のインデックスのみを格納するのに便利です。

`SparseOperatorCSR` コンストラクタは、他のストレージ形式のスパース演算子を CSR 形式に変換するためにも使用できます。その場合、パラメータ `T` もスパース係数の型を変換するために指定できます。
