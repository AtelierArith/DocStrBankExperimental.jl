```
fletcher_checksum(T, data, init::T = zero(T), modulo::T = typemax(T), blocksize::Integer = 1)
```

Fletcherのチェックサムを使用して`data`のハッシュを計算します。

Fletcherのチェックサムは、`c0`という値と、いくつかの数のモジュロの累積和である`c1`という値の2つを計算します。これら2つの値は、ビット単位で連結されて単一の符号なし整数になります。

この関数は高速で、小さなエラーを検出するのに優れています。考慮すべき欠点は次のとおりです：

1. `data`の先頭にあるゼロ値は、チェックサムの値に全く影響を与えません（初期値がゼロ以外に設定されていない限り）。
2. このアルゴリズムの最悪のパフォーマンスは、データが真にランダムな場合に発生しますが、長さ`modulo * (sizeof(T)*4)`ビットのすべてのデータの実行で最大2ビットのすべてのエラーが検出されます。

## 引数

  * `T`: 符号なし整数型。
  * `data`: 単一の`Unsigned`値または値のイテレータ。
  * `init::Unsigned = zero(T)`: オプションの開始値。
  * `modulo::T = typemax(T)`: オプションのモジュロ値で、各ブロックが合計された後、合計と合計の合計に独立して適用されます。
  * `blocksize::Integer = 1`: モジュロ演算を適用する前に合計するためのオプションのブロックサイズ。`blocksize`は、合計演算がオーバーフローしないように、`modulo`、`T`、および`eltype(data)`を考慮して選択する必要があります。

事前定義された便利な関数には、チェックサムのビット数の半分だけ右にシフトされた標準モジュロ値`typemax(T)`のための`fletcher16`、`fletcher32`、および`fletcher64`、およびチェックサムのビット数の半分だけ左にシフトされた代替モジュロ値`1`のための`fletcher16a`、`fletcher32a`、および`fletcher64a`があります。

参照： [adler32](@ref)。
