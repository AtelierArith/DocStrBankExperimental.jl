```
additive_checksum(T, data, init::T = zero(T), modulo::T = typemax(T)) where {T<:Unsigned}
```

データ内の値の単純な加算ハッシュを計算します。

`data`内のすべての値を合計し、次に`modulo`で剰余を計算します。オプションで、ゼロの代わりに`init`から開始することができます。合計はオーバーフローを許可されており、合計がゼロにリセットされます。

この関数は非常に高速ですが、多くの衝突に悩まされます。考慮すべき欠陥は次のとおりです。

1. `data`内のゼロ値はチェックサム値に全く影響を与えません。
2. `data`内の値の順序は、チェックサム値を変更することなく入れ替えることができます。
3. 剰余演算のため、すべてのゼロのチェックサムはすべての`modulo`値のチェックサムと等しくなります。

## 引数

  * `T`: 符号なし整数型。
  * `data`: 単一の`Unsigned`値または値のイテレータ。
  * `init::Unsigned = zero(T)`: オプションの開始値。
  * `modulo::T = typemax(T)`: 加算のための剰余として使用する数。典型的な選択肢は`typemax(T)`（デフォルト）または`typemax(T)`よりも近いが小さい素数です。

あらかじめ定義された便利関数は`additive16`、`additive32`、および`additive64`です。

別の方法で合計を固定ビット数に折りたたむには、[`sysv16`](@ref)も参照してください。
