```
LFSR(taps::NTuple{N, Int} ; seed = trues(N), mapping = (true, false))
```

Create an infinite, stateful iterator that returns values generated by a linear shift register with the specified taps. Taps must be specified in descending order, assuming Fibonacci notation.

The shift register is initialized to all ones by default, but a different starting state may be specified using the `seed` keyword argument.

By default, the iterator produces values of type `Bool`. Using the `mapping` keyword, a tuple `(outputwhentrue, outputwhenfalse)` may be used to specify different iterator output values.

# Examples

```jl
# Create a maximum-length LFSR with period 16
julia> l = LFSR((4,3))
LFSR{2, Bool}((4, 3), Bool[1, 1, 1, 1], (true, false))

# Get the first five values from the sequence
julia> first(l, 5)
5-element Vector{Bool}:
 0
 0
 0
 1
 0

# Change the output to `1.0` and `-1.0` for `true` and `false`, respectively
julia> l = LFSR((4,3), mapping = (1.0, -1.0))
LFSR{2, Float64}((4, 3), Bool[1, 1, 1, 1], (1.0, -1.0))

julia> first(l, 5)
5-element Vector{Float64}:
 -1.0
 -1.0
 -1.0
  1.0
 -1.0

# use `lfsrtaps` to define a sequence of length `2^16-1`
julia> l = LFSR(lfsrtaps[16])
LFSR{4, Bool}((16, 15, 13, 4), Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], (true, false))
```

See also `lfsrtaps`.
