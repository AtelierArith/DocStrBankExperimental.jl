```
quadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing, eval_segbuf=nothing)
```

関数 `f(x)` を `a` から `b` まで数値的に積分し、オプションで追加の区間 `b` から `c` なども積分します。キーワードオプションには、相対誤差許容値 `rtol` （`atol==0` の場合、デフォルトは端点の精度で `sqrt(eps)`）、絶対誤差許容値 `atol` （デフォルトは 0）、最大関数評価回数 `maxevals` （デフォルトは `10^7`）、および積分則の `order` （デフォルトは 7）が含まれます。推定された積分値 `I` と絶対誤差の推定上限 `E` のペア `(I,E)` を返します。`maxevals` を超えない場合、`E <= max(atol, rtol*norm(I))` が成り立ちます。（`norm(I)` がゼロになる可能性がある場合には、正の `atol` を指定することが有用です。）

端点 `a` などは複素数でも構いません（この場合、積分は複素平面の直線セグメントに沿って行われます）。端点が `BigFloat` の場合、積分も `BigFloat` 精度で行われます。

!!! note
    積分の `order` を精度に応じて増加させることが推奨されます。滑らかな被積分関数に対して。


より一般的には、精度は積分端点の精度によって設定されます（浮動小数点型に昇格されます）。

積分領域を別々の引数 `a,b,c...` として渡す代わりに、端点の配列 `[a,b,c...]` または区間タプルの配列 `[(a,b), (b,c)]` として単一の引数として渡すこともできます。（後者は、分離した領域に対して積分することを可能にします。）

被積分関数 `f(x)` は、任意の数値スカラー、ベクトル、または行列型、または実値による加算、減算、乗算、及び `norm` をサポートする任意の型を返すことができます（すなわち、任意のノルム付きベクトル空間）。あるいは、`norm` キーワード引数として `norm` に似た関数を渡すことで異なるノルムを指定することもできます（デフォルトは `norm` です）。

!!! note
    この関数は一次元の積分のみを提供します。多次元積分（立体積分）には、多くの異なるアルゴリズムがあり（しばしば単純なネストされた1d積分よりもはるかに優れています）、最適な選択は非常に問題依存です。多次元積分や他の専門的なタスク（例えば、高度に振動する関数や特異関数の積分）に利用可能なアルゴリズムについては、Juliaの外部パッケージリストを参照してください。


このアルゴリズムは適応型ガウス-クロンロッド積分技術です：各区間の積分はクロンロッド則（`2*order+1` 点）を使用して推定され、誤差は埋め込まれたガウス則（`order` 点）を使用して推定されます。最大の誤差を持つ区間は2つの区間に分割され、このプロセスは所望の誤差許容値が達成されるまで繰り返されます。

これらの数値積分則は、各区間内の滑らかな関数に対して最も効果的に機能しますので、関数に既知の不連続点や他の特異点がある場合は、不連続点を端点に置くように区間を分割するのが最善です。例えば、`f` が `x=0.7` で不連続であり、0から1まで積分したい場合は、`quadgk(f, 0,0.7,1)` を使用して不連続点で区間を分割する必要があります。被積分関数は区間の端点で正確に評価されることはないため、特異点が可積分である限り、端点で発散する関数を積分することが可能です（例えば、`log(x)` や `1/sqrt(x)` の特異点）。

実数値の端点の場合、開始点および/または終了点は無限大である可能性があります。（無限の区間を有限のものにマッピングするために、内部で座標変換が行われます。）

通常の使用では、`quadgk(...)` はセグメント用のバッファを割り当てます。代わりに、`alloc_segbuf(...)` を使用して割り当てられた事前割り当てバッファを `segbuf` 引数として渡すことができます。あるいは、最初の `quadgk(...)` 呼び出しを `quadgk_segbuf(...)` に置き換えて、特定の呼び出しからセグメントバッファを返すこともできます。このバッファは、繰り返しの割り当てを避けるために複数の呼び出しで使用できます。`quadgk` から戻ると、`segbuf` 配列には最終的な数値積分評価に使用されたサブ区間の配列が含まれます。

次の `quadgk` 呼び出しに `eval_segbuf=segbuf` を渡すことで、これらのサブ区間を次の被積分関数評価（同じ領域内）に対する出発点として再利用できます。異なる結果型の被積分関数に対しても可能です。また、`maxevals=0` を渡すことで、これらのサブ区間のさらなる精緻化が禁止され、同じ数値積分則を使用することが強制されます（これは、近似積分の導関数を評価するのに便利です）。
