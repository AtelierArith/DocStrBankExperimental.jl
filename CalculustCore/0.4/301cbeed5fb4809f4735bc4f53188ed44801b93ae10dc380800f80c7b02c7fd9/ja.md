# CalculustCore.jl

偏微分方程（PDE）解法のための共通インターフェース

PDEは厄介です：奇妙な境界条件、移動する領域、特異な演算子、何でもあります！ そして、解法は離散化スキーム、安定性特性、性能トレードオフでさらに複雑になります。 ソフトウェアスタックやコンピュータアーキテクチャ、前処理/後処理パイプラインによって追加される複雑さは言うまでもありません。

数値PDE問題は高性能コンピューティングを駆動します。 地球上で最も大きなスーパーコンピュータは、数百万のMPIランクで物理シミュレーションを数年にわたって実行します。 最適化されたワークフローは、解を得ることと、手ぶらで帰ることの違いであり、すべてのパフォーマンスを絞り出さなければなりません。 そのため、特定の問題クラスに特化した高度に調整されたソフトウェアパッケージが市場を支配しています。 しかし、特化することで、一般性や相互運用性が損なわれます。

`CalculustCore.jl`は、パッケージの著者が新しい勾配スキーム`∇`が登場するたびに`Δ`（ラプラシアン）のメソッドを書く必要がないように設計されています。 我々は、PDEソルバーのコンポーネントに対する抽象化を提供し、新しいソルバーが必要とするボイラープレートコードの量を減らし、ソルバー間の相互運用性を向上させます。 さらに、機械学習ベースのPDEソルバーの開発に必要な要件は、最先端の離散化と大規模なニューラルネットワークモデルをAD互換でアクセラレータフレンドリーなテストベンチで混合する能力です。 Juliaのマルチディスパッチベースのプログラミングモデルは、抽象的に型付けされた、合成可能なコードを可能にし、パッケージがプラグアンドプレイできるようにします。 エンジニアは車輪を再発明するために時間を無駄にするべきではなく、新しく興味深いことに集中すべきです！

我々は、「フーリエスペクトルコロケーション法」から「不連続ガレルキン有限要素」への切り替えは、ユーザーにとって1行の変更であるべきだと考えています。 そして、ユーザーは境界条件を指定するためのソルバー間の不一致な構文に対処する必要はありません。

最後に、`CalculustCore.jl`は`SciML.ai`エコシステムと完全に互換性があるため、問題を記述した後、関連する`DiffEq`パッケージを使用して解決できる正しい`BoundaryValuePDEProblem`または`ODEProblem`を出力するはずです。

## 抽象インターフェース

`CalculustCore.jl`は、多次元領域、ベクトル計算演算子、関数空間のための別々の抽象インターフェースを含んでいます。 これは、誰でも自分の離散化（すなわち、内積演算子と勾配演算子を定義する）をプラグインして、境界値問題や時間発展問題を解決し始めることができるほど一般的です。

離散化をプラグインすると、空間に任意の変形を適用するなど、多くのクールなことができます。 CalculustCore.jlは、すべてのベクトル計算演算子を正しく変換します。 つまり、同じコードが追加の作業なしで正方形や環状の対流拡散を解決でき、基本的に精度を保ちます。

### `AbstractDomain`インターフェース

具体的な型、境界タグ

  * `deform` - すべてのマッピング関連
  * `\otimes`

具体的な型

  * `IntervalDomain`
  * `BoxDomain`

### `AbstractSpace`インターフェース

これらのメソッドを定義する（grad、mass、共通関数）

  * `deform`
  * `\otimes`
  * `transform`

### `AbstractDiscretization`インターフェース

  * `GalerkinProjection`
  * `Collocation`

### 演算子インターフェース - `SciMLOperators.jl`

### `BoundaryValueProblem`インターフェース

通常はランク不足のシステム

## 関連パッケージ

  * [FourierSpaces.jl](https://github.com/vpuri3/FourierSpaces.jl)
  * [NodalPolynomialSpaces.jl](https://github.com/vpuri3/NodalPolynomialSpaces.jl)

## ロードマップ

  * [ ] `AbstractDomain`インターフェース

      * [ ] 具体的な型を別のパッケージに移動 - `PDEDomains.jl`
      * [X] 論理的に長方形の領域
      * [X] 領域を変形
      * [X] 境界タグ
      * [ ] 内部タグ（多相流、共役熱伝達用）
      * [ ] ゴードンホール補間（超限補間）
      * [ ] メッシュ領域
      * [ ] 符号付き距離幾何
      * [ ] 時間変化する領域
      * [ ] `DomainSets.jl`を使用してメタデータ情報を追加することは可能か？
  * [ ] `AbstractField <: AbstractVector`インターフェース - 特殊な配列型

      * [X] スペクトル多項式（特別なものは不要）
      * [X] 変換ベースのスペクトル（フーリエ、チェビー） （特別なものは不要）
      * [ ] ボックス/完全スペクトル要素
  * [ ] 演算子インターフェース - `SciMLOperators.jl`に移動

      * [X] 線形代数演算
      * [X] 遅延合成
      * [X] 配列の削減を使用できる
      * [X] キャッシング
      * [ ] `NNlib`を使用したGather-Scatter演算子
      * [ ] 要素メッシュ上の一般的な補間演算子
  * [ ] 空間

      * [X] 変形空間
      * [ ] テンソル積空間
      * [X] 変換された空間
      * [X] 直交多項式 - `NodalPolynomialSpaces.jl`
      * [ ] 変換を伴うスペクトル

          * [X] フーリエ - `FourierSpaces.jl`
          * [ ] コサイン/サイン空間
      * [ ] ボックス、完全スペクトル要素 - `SpectralElementSpaces.jl`を作成
  * [X] `Space`と`Discretization`の区別を作成

      * [X] Spaceは関数を表現する方法
      * [X] Discretizationは演算子を形成する方法
      * [ ] "discretization"を"scheme"または"solve_scheme"などに名前変更する。なぜなら、discretizationはあいまいだからです。空間の離散化を指しているのか？それとも時間の離散化を指しているのか？このパッケージでは、"discretized"空間上の微分演算子を形成するための"scheme"として使用しています。
      * [ ] 明確さのために`Galerkin`を`GalerkinProjection`に名前変更
      * [ ] 不連続ガレルキン/有限体積におけるフラックス処理
      * [ ] 安定化有限要素におけるすべての雑事
  * [ ] 境界条件インターフェース（"その"領域境界に基づいて"この"境界条件を適用）

      * [X] ディリクレ
      * [X] ノイマン
      * [ ] ロビン
  * [ ] 問題

      * [ ] `ModelingToolkit.jl`を使用した問題フロントエンド
      * [ ] 境界値問題

          * [ ] 境界情報をRHSに移動
          * [ ] `LinearSolve.jl`にディスパッチ
          * [ ] `NonlinearSolve.jl`にディスパッチ（`LinearSolve.jl`、`NonlinearSolve.jl`統合後）
      * [ ] 時間発展問題

          * [X] `OrdinaryDiffEq`と仲良くする
          * [ ] 暗黙的時間ステッパーの場合、各時間ステップでBVPを解決。演算子に境界条件を課す（`SciMLOperators`、`OrdinaryDiffEq`統合を待つ）
          * [ ] 自動的にODEProblemを出力する
