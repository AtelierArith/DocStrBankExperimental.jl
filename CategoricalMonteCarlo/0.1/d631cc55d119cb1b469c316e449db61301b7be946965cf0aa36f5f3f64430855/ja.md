```
algorithm4(𝐰₁::Vector{<:Real}, 𝐰₂::Vector{<:Real})
```

次のアルゴリズムに従って構築された確率のベクトルを返します：

定義：

I = {1,…,N}

J₁ = {i: 𝐰₁ᵢ = 0},    I₁′ = {i: 𝐰₁ᵢ ≠ 0} = I ∖ J₁

J₂ = {i: 𝐰₂ᵢ = 0},    I₂′ = {i: 𝐰₂ᵢ ≠ 0} = I ∖ J₂

𝐰₁ ∈ ℝᴺ : 初期重み, 0 ≤ 𝐰₁ᵢ < Inf

𝐰₂ ∈ ℝᴺ : 拡張重み, 0 ≤ 𝐰₂ᵢ < Inf; ゼロの値は再重み付けがないことを示します

次に：

pᵢ = 𝐰₁ᵢ / ∑ₗ₌₁ᴺ 𝐰₁ₗ,                                       i ∈ I ∖ I₂′

pᵢ = (𝐰₂ᵢ * ∑ₗ 𝐰₁ₗ, l ∈ I₂′) / (∑ₗ₌₁ᴺ 𝐰₂ₗ * ∑ₗ₌₁ᴺ 𝐰₁ₗ),     i ∈ I₂′

このアルゴリズムは、J₁、J₂、I₁′、および I₂′ から形成されるさまざまな交差の組み合わせの結果として、さまざまな確率ベクトルを生成することができます。しかし、出力の複雑さは別として、動機となる概念は非常にシンプルです：重みのベクトル `𝐰₁` を取り、その重みの一部のサブセット (I₂′) を、`𝐰₂` という第二の重みのセットを使用して再重み付けし、`𝐰₁` から導かれる確率質量の比率を保持します。すなわち、`p = algorithm4(𝐰₁, 𝐰₂)` が与えられたとき、次の関係が保持されます：`sum(p[J₂]) ≈ sum(𝐰₁[J₂]) / sum(𝐰₁[I₁′])`、`sum(w₁[J₂]) / sum(w₁[I₂′]) ≈ sum(p[J₂]) / sum(p[I₂′])`。

参照： [`algorithm4!`](@ref)

# 例

```jldoctest
julia> w₁ = [1, 1, 1, 1, 0];

julia> algorithm4(w₁, [2, 1, 3, 4, 0])    # J₁ ∩ I₂′ = ∅
5-element Vector{Float64}:
 0.2
 0.1
 0.30000000000000004
 0.4
 0.0

julia> algorithm4(w₁, [2, 1, 3, 0, 5])    # J₂ = [4] は再重み付けされていない; I₂′ は再重み付けされている
5-element Vector{Float64}:
 0.13636363636363635
 0.06818181818181818
 0.20454545454545453
 0.25
 0.3409090909090909

julia> w₁ = [1, 1, 1, 0, 0];

julia> algorithm4(w₁, [2, 1, 3, 4, 0])    # J₂ = [5] は再重み付けされていない; I₂′ は再重み付けされている
5-element Vector{Float64}:
 0.2
 0.1
 0.30000000000000004
 0.4
 0.0

julia> w₁ = [1, 1, 0, 1, 0];

julia> algorithm4(w₁, [0, 1, 0, 4, 0])    # J₂ = [1,3,5] は再重み付けされていない; I₂′ は再重み付けされている
5-element Vector{Float64}:
 0.3333333333333333
 0.13333333333333333
 0.0
 0.5333333333333333
 0.0

julia> algorithm4(w₁, [0, 0, 3, 4, 0])    # J₂ = [1,2,5] は再重み付けされていない; I₂′ は再重み付けされている
5-element Vector{Float64}:
 0.3333333333333333
 0.3333333333333333
 0.14285714285714285
 0.19047619047619047
 0.0

julia> algorithm4(w₁, [2, 0, 3, 0, 0])    # J₂ = [2,4,5] は再重み付けされていない; I₂′ は再重み付けされている
5-element Vector{Float64}:
 0.13333333333333333
 0.3333333333333333
 0.2
 0.3333333333333333
 0.0
```
