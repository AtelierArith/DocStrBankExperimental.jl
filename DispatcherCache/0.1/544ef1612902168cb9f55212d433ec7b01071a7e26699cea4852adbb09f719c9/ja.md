```
add_hash_cache!(graph, endpoints=[], uncacheable=[]
                [; compression=DEFAULT_COMPRESSION, cachedir=DEFAULT_CACHE_DIR])
```

遅延実行グラフ `graph::DispatchGraph` を最適化し、ディスクキャッシュとグラフの状態に応じて、個々のノードを実行および保存ラッパーでディスクから読み込むようにラップします。この関数は入力グラフをインプレースで変更し、各実行後に変更されていない同じ `graph` に対して呼び出す必要があり、変更されたグラフに対しては呼び出さないでください。

元のグラフが変更されると、`run!` を呼び出すと、キャッシュがすでに存在する場合は、最上位の一貫したキーを読み込むか、あるいは新しい状態を持つノードの出力を再実行して保存します。

# 引数

  * `exec::Executor` `Dispatcher.jl` のエグゼキュータ
  * `graph::DispatchGraph` 入力ディスパッチグラフ
  * `endpoints::AbstractVector` キャッシュが発生するリーフノード;

これに依存するノードはキャッシュされません。ノードはラベルまたはノードオブジェクト自体で指定できます。

  * `uncacheable::AbstractVector` 決してキャッシュされず、

常に実行されるノード（これらのノードは依然としてハッシュ化され、そのハッシュは上流ノードのハッシュにも影響を与えます）

# キーワード引数

  * `compression::String` ノード出力の圧縮を有効にします。

利用可能なオプションは、圧縮なしの `"none"`、BZIP 圧縮のための `"bz2"` または `"bzip2"`、GZIP 圧縮のための `"gz"` または `"gzip"` です。

  * `cachedir::String` キャッシュディレクトリ。

注意: この関数は入力ディスパッチグラフを変更するため、注意して使用する必要があります。この問題を処理する方法の一つは、ディスパッチグラフを生成する関数を作成し、各時間に `add_hash_cache!` を呼び出すことです。
