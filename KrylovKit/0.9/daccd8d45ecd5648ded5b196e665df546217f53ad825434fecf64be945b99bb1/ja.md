```
svdsolve(A::AbstractMatrix, [x₀, howmany = 1, which = :LR, T = eltype(A)]; kwargs...)
svdsolve(f, m::Int, [howmany = 1, which = :LR, T = Float64]; kwargs...)
svdsolve(f, x₀, [howmany = 1, which = :LR]; kwargs...)
# expert version:
svdsolve(f, x₀, howmany, which, algorithm; alg_rrule=...)
```

行列 `A` または関数 `f` にエンコードされた線形写像から `howmany` 個の特異値を計算します。特異値、左特異ベクトル、右特異ベクトル、および `ConvergenceInfo` 構造体を返します。

### 引数:

線形写像は `AbstractMatrix`（密または疎）または一般的な関数または呼び出し可能オブジェクトであることができます。特異値を計算するためには、線形写像の作用とその随伴が必要であるため、`f` は二つの呼び出し可能オブジェクトのタプル（それぞれが単一の引数を受け取る）であるか、二つの入力引数を受け取る単一の呼び出し可能オブジェクトである必要があります。この場合、第二の引数は、随伴または線形写像の通常の作用を計算する必要があるかどうかを示す `Val{true}` または `Val{false}` 型のフラグです。後者の形式は、次のように Julia の `do` ブロック構文ともうまく組み合わせることができます。

```julia
vals, lvecs, rvecs, info = svdsolve(x₀, howmany, which; kwargs...) do x, flag
    if flag === Val(true)
        # y = 随伴写像の x に対する作用を計算
    else
        # y = 線形写像の x に対する作用を計算
    end
    return y
end
```

タプルまたは二引数形式を使用してエンコードされた一般的な線形写像の場合、最良のアプローチは、開始ベクトル `x₀` を提供することです（線形写像のコドメイン、すなわち列空間内）。あるいは、線形写像の行数 `m` を指定することもでき、その場合 `x₀ = rand(T, m)` が使用されます。ここで、`T` のデフォルト値は `Float64` ですが、異なる値が指定されていない限りです。`AbstractMatrix` が使用される場合、開始ベクトル `x₀` を提供する必要はありません。`x₀` は `rand(T, size(A, 1))` として選択されます。

次の引数はオプションですが、通常は指定するべきです。`howmany` は計算すべき特異値とベクトルの数を指定します。`which` はターゲットとする特異値を指定します。`which` の有効な指定は次の通りです。

  * `LR`: 最大特異値
  * `SR`: 最小特異値 ただし、最大特異値はより迅速に収束する傾向があります。

### 戻り値:

戻り値は常に `vals, lvecs, rvecs, info = svdsolve(...)` の形式であり、

  * `vals`: 特異値を含む `Vector{<:Real}` で、長さは少なくとも `howmany` ですが、同じコストで収束した特異値がより多くなる可能性があります。
  * `lvecs`: `vals` と同じ長さの対応する左特異ベクトルの `Vector` です。
  * `rvecs`: `vals` と同じ長さの対応する右特異ベクトルの `Vector` です。特異ベクトルは行列として返されず、線形写像はベクトルのような振る舞いを持つ任意のカスタム Julia 型に作用する可能性があるためです。すなわち、リスト `lvecs`（`rvecs`）の要素は、開始推測 `x₀`（`A' * x₀`）に類似したオブジェクトであり、異なる `eltype` を持つ可能性があります。線形写像が単純な `AbstractMatrix` の場合、`lvecs` と `rvecs` は `Vector{Vector{<:Number}}` になります。
  * `info`: [`ConvergenceInfo`] の型のオブジェクトで、次のフィールドを持ちます。

      * `info.converged::Int`: 実際に指定された許容誤差 `tol` に収束した特異値とベクトルの数を示します（キーワード引数の下で参照）。
      * `info.residual::Vector`: `vals` と同じ長さのリストで、残差 `info.residual[i] = A * rvecs[i] - vals[i] * lvecs[i]` を含みます。
      * `info.normres::Vector{<:Real}`: `vals` と同じ長さのリストで、残差のノルム `info.normres[i] = norm(info.residual[i])` を含みます。
      * `info.numops::Int`: 線形写像が適用された回数、すなわち `f` が呼び出された回数、またはベクトルが `A` または `A'` と掛けられた回数です。
      * `info.numiter::Int`: Krylov 部分空間が再起動された回数（以下を参照）。

!!! warning "収束の確認"
    すべての要求された特異値が収束しなかった場合、警告は表示されないため、常に `info.converged >= howmany` を確認してください。


### キーワード引数:

キーワード引数とそのデフォルト値は次の通りです。

  * `verbosity::Int = 0`: 冗長性レベル

      * 0（すべてのメッセージを抑制）
      * 1（警告のみ）
      * 2（最後に収束情報を含む1つのメッセージ）
      * 3（各イテレーション後の進捗情報）
      * 4+（上記すべてと GKL イテレーションに関する追加情報）
  * `krylovdim`: 構築される Krylov 部分空間の最大次元。ベクトル空間の次元は知られていないか、チェックされないことに注意してください。たとえば、`x₀` は必ずしも `Base.length` 関数をサポートする必要はありません。実際の問題の次元がデフォルト値よりも小さいことがわかっている場合、`krylovdim` の値を減らすことが有用ですが、原則としてこれは検出されるべきです。
  * `tol`: 上記で定義された `normres` に従った要求された精度。たとえば、単精度（`Float32`）で作業する場合、デフォルト値を変更する必要があります。
  * `maxiter`: Krylov 部分空間を再構築できる回数。アルゴリズムに関する詳細は以下を参照してください。
  * `orth`: 使用される直交化方法、[`Orthogonalizer`](@ref) を参照してください。
  * `eager::Bool = false`: true の場合、Krylov 部分空間の各拡張後に SVD を即座に計算して収束をテストします。そうでない場合、Krylov 部分空間の次元が `krylovdim` になるまで待ちます。

最後のキーワード引数 `alg_rrule` は、`svdsolve` が逆モード自動微分が使用される設定で使用される場合にのみ関連します。`svdsolve` のためにカスタム `ChainRulesCore.rrule` が定義されており、`alg_rrule` を介して指定できる異なるアルゴリズムを使用して評価できます。適切なデフォルトが選択されるため、このキーワード引数は、このデフォルトの選択が失敗したり、効率的に機能しない場合にのみ使用するべきです。`alg_rrule` の可能な値とそれが使用されるアルゴリズムへの影響に関する詳細は、ドキュメントを確認してください。

### アルゴリズム

デフォルト値とキーワード引数のない最後のメソッドが最終的に呼び出され、直接使用することもできます。ここでアルゴリズムが指定されますが、現在は [`GKL`](@ref) のみが利用可能です。`GKL` は、特異値の近似を計算するための基礎を形成する部分的な Golub-Kahan-Lanczos 二重対角化を指します。この因数分解は、固有値の Krylov-Schur 因数分解に類似して、動的に縮小および拡張されます（すなわち、厚い再起動）。
