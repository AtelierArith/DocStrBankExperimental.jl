```
reallinsolve(f, b, x₀, algorithm, [a₀::Real = 0, a₁::Real = 1]; alg_rrule=algorithm)
```

線形システム `a₀ * x + a₁ * f(x) = b` の解 `x` を、実線形写像を表す `f` を用いて、初期推定値 `x₀` から計算します。近似解 `x` と `ConvergenceInfo` 構造体を返します。

!!! note "実線形写像に関する注意"
    関数 `f` は、`f(add(x,y)) = add(f(x), f(y))` および `f(scale(x, α)) = scale(f(x), α)` を満たす場合、実線形写像を実装していると言います。ここで、`x` と `y` はベクトル、`α::Real` はスカラーです。ベクトルが複素数演算を用いて表現されている場合でも、これは可能です。例えば、写像 `f=x-> x + conj(x)` は、複素スカラー `α` に対して `f(scale(x, α)) = scale(f(x), α)` を満たさないため、（複素）線形ではない実線形写像を表します。複素線形写像は常に実線形写像であるため、この文脈で使用することができますが、その場合 `linsolve` と `reallinsolve` は同じ解を対象とします。しかし、異なる算術を用いてその解を計算するため、`linsolve` の方が効率的である可能性があります。

    ベクトル `x` と `y` を実ベクトル空間の要素として解釈するために、標準内積は `real(inner(x,y))` に置き換えられます。これは、最初からベクトル `x` と `y` が実数演算を用いて表現されていた場合には影響がなく、複素ベクトルをシームレスに使用することを可能にします。


### 引数:

線形写像は `AbstractMatrix`（密または疎）または一般的な関数または呼び出し可能オブジェクトであることができます。実数 `a₀` と `a₁` はオプションの引数であり、暗黙的に適用されます。すなわち、線形写像の適用やベクトル `x` と `b` に対する演算の回数には寄与しません。

### 戻り値:

戻り値は常に `x, info = linsolve(...)` の形式であり、

  * `x`: 問題の近似解であり、右辺 `b` と同様の型ですが、異なる `scalartype` を持つ可能性があります。
  * `info`: [`ConvergenceInfo`] 型のオブジェクトで、以下のフィールドを持ちます。

      * `info.converged::Int`: 解が要求された許容誤差まで収束したかどうかに応じて 0 または 1 の値を取ります。
      * `info.residual`: 近似解 `x` の残差 `b - f(x)`。
      * `info.normres::Real`: 残差のノルム、すなわち `norm(info.residual)`。
      * `info.numops::Int`: 線形写像が適用された回数、すなわち `f` が呼び出された回数、またはベクトルが `A` と掛けられた回数。
      * `info.numiter::Int`: Krylov 部分空間が再起動された回数（以下を参照）。

!!! warning "収束の確認"
    収束した解が見つからなかった場合、警告は表示されないため、常に `info.converged == 1` を確認してください。


### アルゴリズム

最終的な（専門的な）メソッドは、デフォルト値やキーワード引数なしで呼び出されるものであり、直接使用することもできます。ここでは、アルゴリズムを明示的に指定します。現在、実装されているのは [`CG`](@ref)、[`GMRES`](@ref)、および [`BiCGStab`](@ref) のみであり、`isposdef == true` の場合は `CG` が選択され、それ以外の場合は `GMRES` が選択されます。標準の `GMRES` 用語では、私たちのパラメータ `krylovdim` は *再起動* パラメータと呼ばれ、`maxiter` パラメータは外部反復の回数、すなわち再起動サイクルの数をカウントします。`CG` では、Krylov 部分空間は短い再帰関係が使用されるため、暗黙的であり、再起動は必要ありません。したがって、`CG` アルゴリズムが使用できる最大の CG 反復回数として `krylovdim*maxiter` を渡します。 ```
