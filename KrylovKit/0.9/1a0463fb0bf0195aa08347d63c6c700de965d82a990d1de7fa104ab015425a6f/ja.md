```
# エキスパートバージョン:
schursolve(f, x₀, howmany, which, algorithm)
```

線形写像 `A` にエンコードされた部分シュール分解を計算し、`howmany` の固有値を含みます。縮小されたシュール行列、シュールベクトルの基底、抽出された固有値、および `ConvergenceInfo` 構造体を返します。

固有ベクトルを取得するには、[`eigsolve`](@ref) も参照してください。実対称または複素エルミート問題の場合、（部分）シュール分解は（部分）固有値分解と同一であり、常に `eigsolve` を使用する必要があります。

### 引数:

線形写像は、`AbstractMatrix`（密または疎）または一般的な関数または呼び出し可能オブジェクトであり、`x₀` のようなベクトルライクなオブジェクトに作用します。`x₀` は、クリロフ部分空間が構築される出発点の推測です。`howmany` は、アルゴリズムが終了する前に収束すべきシュールベクトルの数を指定します。`which` は、ターゲットとする固有値を指定します。`which` の有効な指定は次のとおりです。

  * `LM`: 最大の絶対値を持つ固有値
  * `LR`: 最大の（最も正の）実部を持つ固有値
  * `SR`: 最小の（最も負の）実部を持つ固有値
  * `LI`: 最大の（最も正の）虚部を持つ固有値（`T <: Complex` の場合のみ）
  * `SI`: 最小の（最も負の）虚部を持つ固有値（`T <: Complex` の場合のみ）
  * [`EigSorter(f; rev = false)`](@ref): `f(λ)` によってソートされたときに最初（または `rev == true` の場合は最後）に現れる固有値 `λ`

!!! 注 "固有値 `which` の選択に関する注意"     クリロフ法は、すなわち線形写像のスペクトルの周辺にある極値固有値に対してうまく機能します。`which` のすべての有効な `Symbol` はこの特性を持っていますが、`EigSorter` を使用して指定することもできます。たとえば、`:LM` は `Eigsorter(abs; rev = true)` と同等です。最小の絶対値のソートは、たとえば `EigSorter(abs; rev = false)` を使用して得られますが、（シフトおよび）反転が使用されないため、固有値がゼロに近いことがスペクトルの周辺に近いことを知っている場合にのみ成功します。

!!! 警告 "重複した固有値"     理論的な観点から、クリロフ法はターゲットとする固有値に関連付けられた単一の固有ベクトルしか見つけることができません。重複した固有値の場合、返される特定の固有ベクトルは出発ベクトル `x₀` によって決まります。大規模な問題では、数値的ノイズから生成される2つ目の線形独立な固有ベクトルがしばしば生成されるため、実際にはあまり問題になりません。ただし、この潜在的に脆弱な動作に依存しないようにすることが重要です。特に小さな問題に対しては注意が必要です。

`algorithm` 引数は現在、[`Arnoldi`](@ref) のインスタンスのみをサポートしており、クリロフ法のパラメータ（クリロフ次元や最大反復回数など）を指定できます。`schursolve` は `eigsolve` よりも一般的に使用されないため、このエキスパートモードの呼び出し構文のみをサポートしており、便利なキーワードインターフェースは現在利用できません。

### 戻り値:

戻り値は常に `T, vecs, vals, info = schursolve(...)` の形式であり、

  * `T`: 線形写像の部分シュール分解を含む `Matrix` であり、すなわちその要素は `T[i,j] = inner(vecs[i], f(vecs[j]))` で与えられます。シュール形式であり、すなわち複素算術の場合は上三角、実算術の場合はブロック上三角（最大2x2ブロック）です。
  * `vecs`: 対応するシュールベクトルの `Vector` であり、`vals` と同じ長さです。シュールベクトルは行列として返されないことに注意してください。なぜなら、線形写像はベクトルライクな動作を持つ任意のカスタムJulia型に作用する可能性があるからです。すなわち、リスト `vecs` の要素は、出発推測 `x₀` に類似したオブジェクトであり、異なる `eltype` を持つ可能性があります。線形写像が単純な `AbstractMatrix` の場合、`vecs` は `Vector{Vector{<:Number}}` になります。シュールベクトルは定義上直交しており、すなわち `inner(vecs[i],vecs[j]) = I[i,j]` です。問題（すなわち線形写像と初期推測）が実数の場合、シュールベクトルは実数です。
  * `vals`: 固有値の `Vector` であり、すなわち複素算術の場合は `T` の対角要素、実算術の場合は対角ブロックから抽出されます。`vals` は常に複素数であり、基礎となる算術に依存しません。
  * `info`: [`ConvergenceInfo`] の型のオブジェクトであり、次のフィールドを持ちます。

      * `info.converged::Int`: 実際に指定された許容誤差に収束した固有値とシュールベクトルの数を示します（以下のキーワード引数を参照）
      * `info.residuals::Vector`: `vals` と同じ長さのリストであり、実際の残差を含みます

        ```julia
        info.residuals[i] = f(vecs[i]) - sum(vecs[j] * T[j, i] for j in 1:i+1)
        ```

        ここで、複素算術の場合は `T[i+1,i]` は確実にゼロであり、実算術の場合はおそらくゼロです。
      * `info.normres::Vector{<:Real}`: `vals` と同じ長さのリストであり、各シュールベクトルの残差のノルムを含みます。すなわち、`info.normes[i] = norm(info.residual[i])`
      * `info.numops::Int`: 線形写像が適用された回数、すなわち `f` が呼び出された回数、またはベクトルが `A` と掛けられた回数
      * `info.numiter::Int`: クリロフ部分空間が再起動された回数（以下を参照）

!!! 警告 "収束の確認"     要求されたすべての固有値が収束しなかった場合、警告は表示されないため、常に `info.converged >= howmany` を確認してください。

### アルゴリズム

実際のアルゴリズムはクリロフ-シュールアルゴリズムの実装であり、[`Arnoldi`](@ref) アルゴリズムがクリロフ部分空間を生成するために使用されます。アルゴリズムの間、クリロフ部分空間は動的に成長し、縮小されます。すなわち、再起動は現在のクリロフ部分空間の一部が保持されるいわゆる厚い再起動です。 ```
