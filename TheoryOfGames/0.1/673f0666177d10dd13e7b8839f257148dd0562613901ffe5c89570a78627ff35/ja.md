```
specific_in_core(mode, player_set, utilities, optimizer; verbose)
```

コアに属し、ゲームの効用関数とプレイヤーセットの大連合によって指定された特定の分配目的を最大化する利益分配を計算する関数。この関数は、コラム生成アプローチを使用してマスタープロブレムに制約を反復的に追加する反復アプローチを実装しています。そのために、モードカテゴリに保存されたコールバック関数が利用されます。

## 入力

mode : IterMode     コールバック関数への参照を含む計算モード     利益分配スキームが与えられたとき、最悪の利益を持つ連合のセットとその共有される総利益のタプルを返します     callback*worst*coalitionは1つの引数（現在の利益分配）を受け取ります dist*objective : 関数     利益分配の目的関数を構築するための関数     JuMPモデルとプレイヤーセットの2つの引数を持つ関数であり、     JuMP @NLobjectiveまたは@objectiveコマンドを使用して目的関数を構築します optimizer : 任意     計算目的で使用されるJuMPモデルの最適化関数 start*time : （オプション、デフォルトは何も指定しない）     メソッドの初期時間を指定します。何も指定しない場合、値はtime()で初期化されます rtol : 数値（オプション、デフォルト1e-2）     収束プロセスの相対許容誤差 atol : 数値（オプション、デフォルト1e-2）     収束プロセスの絶対許容誤差 lower*bound : 数値（オプション、デフォルトは何も指定しない）     問題の変数の下限（利益分配と最悪の連合のマージン） upper*bound : 数値（オプション、デフォルトは何も指定しない）     問題の変数の上限（利益分配と最悪の連合のマージン）     何も指定しない場合、値は自動的に大連合の利益に設定されます verbose : Bool（オプション、デフォルトtrue）     trueの場合、現在の実行状況を示すプログレスバーが表示されます raw*outputs : Bool（オプション、デフォルトfalse）     trueの場合、すべての生の出力が返されます use*start*value : Bool（オプション、デフォルトfalse）     trueの場合、反復プロセスで前の反復値が次の反復の初期化に使用されます max*iter : Bool（オプション、デフォルト100）     プロセスの最大反復回数 preload*coalitions : ベクター（オプション、デフォルト空）     反復手続きが始まる前に自動的に含めるべき連合のリスト best*objective*stop*option : 文字列（オプション、デフォルトは何も指定しない）     事前に設定された値に達したときに下位問題を停止するためのオプションの名前。     このオプションが何も指定されていない場合、この機能は使用されません。     このオプションが指定されている場合、各反復で最小収束基準が追加され、     最小の実行可能な目的関数に達したときに下位問題を停止します。     ソルバーが解を返すべきこの最小目的値は、オプションbest*objective*stop*valueとして提供されます。     gurobiが使用されている場合、このオプションはBestObjStopです。 best*objective*stop*value : 数値（オプション、デフォルト-1e-2）     ソルバーが収束するために使用される最小目的関数     プロセスがループを開始するとき lower*relaxation*stop*option : 文字列（オプション、デフォルトは何も指定しない）     最低限の境界が指定された許容誤差に達したときに最適化の停止基準を設定するために使用されるオプションの名前 tolerance*lower*relaxation*stop : double（オプション、デフォルト0.0）     lower*relaxation*stop*optionが有効な場合、このオプションはループを停止するために使用される許容誤差を指定します。

## 出力

profit*distribution     プレイヤーによる利益分配 min*surplus     最小余剰を持つ連合の利益の履歴 ```
