```julia
shortest_path(
    xs,
    ys;
    min_segment_length,
    fit_threshold,
    fit_function,
    overlap
) -> Vector{Vector{Int64}}

```

`xs`を`min_segment_length`よりも長いセグメントに分割し、`fit_threshold`よりも良いフィットを持つものにします。デフォルトでは、フィットの良さは決定係数を使用して測定されます。各セグメントは`fit_threshold`の最小R²を持たなければなりません。ルート平均二乗誤差は、`fit_function = :rmse`を設定し、データセット依存の誤差閾値に`fit_threshold`を調整することで使用することもできます。この場合、ルート平均二乗誤差は`fit_threshold`よりも小さくなければなりません。

ノードがxデータポイントであり、エッジの重みがこれらのノード間の線形モデルに関連付けられたフィットの良さの測定値である有向グラフを構築します。ノードは、最小長が`min_segment_length`より大きく、フィットの良さが`fit_threshold`よりも良い場合にのみ接続されます。デフォルトでは、セグメントの終わりは次のセグメントの始まりでもありますが、`overlap`を`false`に設定することで変更できます（結果として不連続なセグメンテーションになります）。その後、A*アルゴリズムを使用して、データセット全体を網羅する最短重み付きパスが見つかります。これは、他のセグメンテーションアルゴリズムで使用される動的プログラミングアプローチにほぼ対応します。

内部でデータをソートする前処理ステップです。これは最も遅いアルゴリズムですが、セグメントができるだけ長く、フィットとのバランスを取ったセグメンテーションを返すはずです。

インデックスの配列`[idxs1, ...]`を返します。ここで、`idxs1`は最初のセグメントの`xs`のインデックスです。

# 例

```
segments = shortest_path(xs, ys; min_segment_length=1.2)
```

参照: [`sliding_window`](@ref), [`top_down`](@ref).
