```
apply!(sim, func, call, read, write; [add_existing, with_edge])
```

シミュレーション状態に遷移関数 `func` を適用します。

`call` は単一のエージェントタイプまたはエージェントタイプのコレクションでなければなりません。同様に、`read` と `write` も単一のエージェント/エッジタイプまたはエージェント/エッジタイプのコレクションでなければなりません。

`call` は、遷移関数 `func` が呼び出されるエージェントタイプを決定します。遷移関数内では、エージェントは自分自身の状態を含むエージェントの状態と、`read` コレクションにそのタイプが含まれている場合にのみエッジにアクセスできます。したがって、エージェントは自分自身の状態を変更したり、新しいエージェントやエッジを作成したりすることができるのは、そのタイプが `write` コレクションに含まれている場合のみです。

T が `call` に含まれるエージェントタイプであると仮定します。T が `read` にも含まれる場合、遷移関数は次のシグネチャを持たなければなりません: `transition_function(agent::T, id, sim)`。エージェントの型宣言は、`call` に単一のタイプのみが含まれている場合は省略可能です。T が `read` に含まれない場合、シグネチャは `transition_function(::Val{T}, id::AgentID, sim::Simulation)` でなければなりません。

T が `write` に含まれる場合、遷移関数はタイプ T のエージェントまたは `nothing` を返さなければなりません。`nothing` が返された場合、そのエージェントはシミュレーションから削除されます。そうでない場合、エージェントはすべてのエージェントに対して遷移関数が呼び出された後に返された状態を取得します。

エッジ状態タイプが `write` に含まれる場合、そのタイプの現在のエッジはシミュレーションから削除されます。特定のタイプの既存のエッジを保持したい場合は、そのタイプをオプションの `add_existing` コレクションに追加できます。

同様に、`write` に含まれるが `call` 引数には含まれないエージェントタイプは `add_existing` コレクションの一部となることができ、このタイプの既存のエージェントが保持され、追加されることができます。ただし、`call` に含まれるエージェントタイプの場合、遷移関数内でその状態を返すことによってこれが達成されます。

キーワード `with_edge` を使用すると、遷移関数が呼び出されるエージェントのセットを、タイプ `with_edge` のエッジのターゲット側にいるエージェントに制限することができます。したがって  

```
apply!(sim, AT, ET, []) do _, id, sim 
    if has_edge(sim, id, ET)
       do_something
    end
end
```

は次のように等価です。 

```
apply!(sim, AT, ET, []; with_edge = ET) do _, id, sim 
    do_something
end
```

ただし、すべての `has_edge` チェックを省略します。

この `with_edge` キーワードは、この特定のタイプのエッジを持つエージェントの小さなサブセットが存在する場合にのみ設定すべきであり、他のシナリオではパフォーマンスに悪影響を及ぼします。また、このキーワードは :SingleType ヒントのないエッジタイプにのみ使用できます。

[`apply`](@ref) および [チュートリアルの遷移関数の適用セクション](tutorial1.md#Applying-Transition-Functions) も参照してください。
