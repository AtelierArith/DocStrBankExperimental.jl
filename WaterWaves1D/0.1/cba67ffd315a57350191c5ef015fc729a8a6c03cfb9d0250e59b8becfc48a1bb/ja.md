```
SolitaryWaveWhithamBoussinesq(param; kwargs)
```

指定された速度を持つWhitham-Boussinesq孤立波を計算します。

# 引数

  * `param :: NamedTuple`: 速度 `c` と無次元パラメータ `ϵ` および `μ`、メッシュサイズ `L` とコレクションポイントの数 `N` を含む問題のパラメータ。

## キーワード（オプション）

  * `guess :: Vector{Real}`: 表面変形の初期推測（提供されない場合、SGNの正確な式が使用されます）;
  * `x₀ :: Real`: 孤立波の中心（推測が提供されていない場合）;
  * `α :: Real`: 使用されるモデルを決定します（通常は `1` または `1/2`、デフォルトは1）;
  * `Boussinesq`: `true` の場合（デフォルトは `false`）、パラメータ `a`（デフォルト `-1//3`）、`b=d`（デフォルト `1//3`）、および `c=0` を持つ標準Boussinesqシステムを計算します;
  * `iterative :: Bool`: `true` の場合はGMRESを通じてヤコビアンを反転し、`false` の場合はLU分解を使用します;
  * `verbose :: Bool`: `true` の場合は各ステップで数値誤差を印刷します;
  * `max_iter :: Int`: ニュートンアルゴリズムの最大反復回数;
  * `tol :: Real`: 一般的な許容誤差（デフォルトは `1e-10`）;
  * `ktol :: Real`: Krasnyフィルターの許容誤差（デフォルトは `0`、すなわちフィルタリングなし）;
  * `gtol :: Real`: GMRESアルゴリズムの相対許容誤差（デフォルトは `1e-10`）;
  * `dealias :: Int`: Orliczルールによるディーリアリング `1-dealias/(dealias+2)`（デフォルトは `0`、すなわちディーリアリングなし）;
  * `q :: Real`: 修正されたニュートンアルゴリズム

`u_{n+1}=q*(u_n+du)+(1-q)*u_n`（デフォルトは `1`）;

  * `β :: Real`: ヤコビアンにカーネルへのスペクトル射影を `β` 倍追加します。

# 戻り値

`(η,v,mesh)` で

  * `η :: Vector{Float64}`: 表面変形;
  * `v :: Vector{Float64}`: 速度（表面での速度ポテンシャルのトレースの導関数）;
  * `mesh :: Mesh`: メッシュコレクションポイント。
