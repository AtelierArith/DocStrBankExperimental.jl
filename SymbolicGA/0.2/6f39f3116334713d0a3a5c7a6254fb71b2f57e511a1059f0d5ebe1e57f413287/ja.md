```
@ga <sig> <T> <ex>
@ga <sig> <ex>
```

`ex`からジオメトリック要素を計算するJuliaコードを生成します。これは、`sig`というシグネチャによって定義された代数で実装されます（詳細は[`SymbolicGA.Signature`](@ref)を参照）。

サポートされている構文：

  * `sig`: 正の基底ベクトル、負の基底ベクトル、退化した基底ベクトルの数に対応する1、2、または3の整数リテラルのタプル、または指定されていない整数がデフォルトでゼロになる整数リテラル。形式は`<+++--𝟎>`のような文字列リテラルでもあり、`+`、`-`、`𝟎`の数はそれぞれ正、負、退化した基底ベクトルの数に対応します。
  * `T`: 型または`nothing`に評価される任意の式。
  * `ex`: 代数的に解析可能な任意の式。

詳細は[`codegen_expression`](@ref)を参照してください。

`ex`は単一のステートメントまたはブロックであり、代数式の構築を容易にするためのドメイン固有言語を使用します。`ex`は論理的に2つのセクションに分かれています：バインディングを定義する定義セクションと、評価の対象となる最終的な代数式です。これは3つのフェーズで処理されます：

  * バインディングが定義される定義フェーズ；
  * 最終的な代数式で特定されたバインディングが展開される展開フェーズ。定義されたバインディングには、以前に定義されたものと一連のデフォルトバインディングが含まれます。
  * コアの代数式が簡略化され、Julia式に翻訳される評価フェーズ。

# 式の解析

## バインディング定義

最後のステートメントの前のすべてのステートメントは、次の構文と意味論を使用して新しい変数または関数を定義できます：

  * 変数は`<lhs::Symbol> = <rhs::Any>`または`<lhs::Symbol>::<type>`で宣言され、後者は`<lhs> = <lhs>::<type>`に展開されます。
  * 関数は標準の短いまたは長い形式の関数定義`<name>(<args...>) = <rhs>`または`function <name>(<args...>) <rhs> end`で宣言され、単純な意味論をエンコードするために単純な形式に制限されます。制限は次のとおりです：

      * `where`句と出力型注釈はサポートされていません。
      * 関数引数は型指定されていない必要があります。例えば、`f(x, y)`は許可されますが、`f(x::Vector, y::Vector)`は許可されません。
      * 関数引数は再割り当てされてはなりません。引数として宣言されたシンボルの出現は、これらの引数を参照することが前提とされています。例えば、`f(x, y) = x + y`は、`x + y`が実際には「最初と2番目の関数引数に対して`+`を実行する」を意味することを前提としています。したがって、`f(x, y) = (x = 2; x) + y`はバグを引き起こす可能性があります。この制限を緩和するために、適切な[`SymbolicGA.Bindings`]を持つ[`codegen_expression`](@ref)を使用し、特定の呼び出しを含む関数エントリを使用してください。

## バインディング展開

参照と関数は、参照が右辺に置き換えられ、関数呼び出しがその本体と引数が補間された形で展開される、非常に単純なコピー＆ペースト方式で展開されます。`x = x::T`のような参照の自己参照バインディングを許可するために、単純なチェックが行われ、対応する式の部分木でそのパターンの単一の展開が行われます。

このような変数や関数の展開に関する詳細は、[`SymbolicGA.Bindings`](@ref)を参照してください。

関数呼び出しは、バインディングまたは組み込み関数を参照していると見なされます。関数を呼び出したい場合、例えば`my_func(x)::Vector`の場合、呼び出しを補間する必要があります：`$(my_func(x))::Vector`。

# 代数的評価

型注釈は次のように指定できます：

  * 入力がどのような型の幾何学的エンティティと見なされるべきかを指定し、コンポーネントは`getcomponent`で取得されます。
  * 中間式の1つまたは複数のグレードに対する射影を要求します。
