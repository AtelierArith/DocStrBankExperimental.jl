`Daf`ストレージフォーマットはHDF5ディスクファイル内にあります。これは、HDF5ファイルに`Daf`データを保存する「ネイティブ」な方法であり、HDF5は本質的に「ファイル内のファイルシステム」であり、「ディレクトリ」の代わりに「グループ」を、「ファイル」の代わりに「データセット」を使用するため、「何でも」含むことができます。したがって、HDF5は非常に一般的であり、特定のデータを保持するために特定の内部構造を使用するさまざまな特定のフォーマットがあります - 例えば、`h5ad`ファイルは[AnnData](https://pypi.org/project/anndata/)オブジェクトを表現するための特定の内部構造を持っています。HDF5ストレージ内で`Daf`データを表現するために、以下の内部構造を使用します（これは`h5ad`と**互換性がありません**）：

  * HDF5ファイルは、ルートグループ内に直接`Daf`データを含むことができ、その場合、単一の`Daf`データセットのみを保持することが制限されます。そのようなファイルを使用する場合、含まれている単一の`Daf`データセットに自動的にアクセスします。慣例として、そのようなファイルには`.h5df`のサフィックスが付けられます。
  * あるいは、HDF5ファイルは任意のグループ内に`Daf`データを含むことができ、その場合、ファイル内の他のグループの内容に制限はありません。そのようなグループには他の`Daf`データ（単一のファイル内に複数の`Daf`データセットを許可）や、非`Daf`データが含まれる場合があります。そのようなファイルを使用する場合、興味のある`Daf`データセットを含むグループの名前を指定する必要があります。慣例として、そのようなファイルが「主に」（またはのみ）`Daf`データセットを含む場合、`.h5dfs`のサフィックスが付けられ、ファイル内のトップレベルグループを説明するドキュメントが付随します。
  * `Daf`データグループの下には、`scalars`、`axes`、`vectors`、`matrices`の4つのサブグループと`daf`データセットがあります。
  * フォーマットを将来にわたって保護するために、`daf`データセットには2つの整数のベクトルが含まれ、最初の整数がメジャーバージョン番号、2番目がマイナーバージョン番号として機能し、[セマンティックバージョニング](https://semver.org/)を使用します。これにより、HDF5ファイル内のいくつかのグループが`Daf`データを含むかどうか、またどのバージョンの内部構造を使用しているかを簡単にテストできます。現在定義されている唯一のバージョンは`[1,0]`です。
  * `scalars`グループにはスカラー属性が含まれ、それぞれが独自の「データセット」として存在します。サポートされているスカラーデータ型は、[`StorageScalar`](@ref)に含まれるものだけです。**本当に**他のものが必要な場合は、JSONにシリアライズして結果を文字列スカラーとして保存してください。これは**非常に**まれであるべきです。
  * `axes`グループには、各軸ごとに「データセット」が含まれ、文字列のベクトル（軸エントリの名前）が含まれています。
  * `vectors`グループには、各軸ごとのサブグループが含まれています。各サブグループにはベクトルプロパティが含まれています。ベクトルが密である場合、直接「データセット」として保存されます。そうでない場合、2つのベクトル「データセット」を含むグループとして保存されます：`nzind`は非ゼロ値のインデックスを含み、`nzval`は実際の値を含みます。詳細については、Juliaの`SparseVector`実装を参照してください。サポートされているベクトル要素型は、[`StorageScalar`](@ref)に含まれるものと同じです。
  * `matrices`グループには、各行軸ごとのサブグループが含まれ、各列軸ごとのサブグループが含まれています。各サブサブグループには行列プロパティが含まれています。行列が密である場合、直接「データセット」として保存されます（列優先レイアウトで）。そうでない場合、3つのベクトル「データセット」を含むグループとして保存されます：`colptr`は`rowval`内の各列の行のインデックスを含み、`rowval`は列の非ゼロ行のインデックスを含み、`nzval`は非ゼロ行列エントリの値を含みます。詳細については、Juliaの`SparseMatrixCSC`実装を参照してください。サポートされている行列要素型は、[`StorageReal`](@ref)に含まれるものだけであり、これは文字列の行列を明示的に除外します。
  * すべてのベクトルと行列は、ファイル内で連続的に保存されており、効率的にメモリマッピングできるようにしています。

これがすべてです。上記の型とレイアウトに関する制限により、HDF5が各「データセット」に提供するメタデータはデータを完全に記述するのに十分であり、必要に応じて任意のプログラミング言語の任意のHDF5 APIを使用して直接アクセスできるはずです。ただし、通常は、Juliaの`Daf`パッケージを使用してデータにアクセスするのが最も簡単です。

HDF5構造の例：

```
example-daf-dataset-root-group/
├─ daf
├─ scalars/
│  └─ version
├─ axes/
│  ├─ cell
│  └─ gene
├─ vectors/
│  ├─ cell/
│  │  └─ batch
│  └─ gene/
│     └─ is_marker
└─ matrices/
   ├─ cell/
   │   ├─ cell/
   │   └─ gene/
   │      └─ UMIs/
   │         ├─ colptr
   │         ├─ rowval
   │         └─ nzval
   └─ gene/
      ├─ cell/
      └─ gene/
```

!!! note
    `Daf`データを含むHDF5ファイルを作成する際は、`;fapl=HDF5.FileAccessProperties(;alignment=(1,8))`を指定する必要があります。これにより、すべてのメモリバッファが効率的なアクセスのために適切に整列されます。そうでない場合、メモリマッピングは**はるかに**効率が悪くなります。したがって、適切な整列を強制しないHDF5ファイルに保存された`Daf`データにアクセスしようとすると、警告が生成されます。


!!! note
    HDF5ファイルからデータを削除しても、放棄されたストレージは再利用されません。一般的に、そのストレージを回収したい場合は、ファイルを再パックする必要があり、これにより作成されたメモリマッピングバッファは無効になります。したがって、データを削除する場合（例：[`delete_vector!`](@ref)を使用）、最終的には`H5df`オブジェクトを放棄し、HDF5ファイルを再パックし、その後再パックされたデータにアクセスするために新しい`H5df`オブジェクトを作成する必要があります。


!!! note
    ここにあるコードは、HDF5データが上記のすべての規則と制限に従っていることを前提としています（とはいえ、コードは整列されていない、チャンク化された、または圧縮された形式で保存されたベクトルや行列にアクセスできますが、これははるかに効率が悪くなります）。`H5df`を使用してHDF5ファイル内で`Daf`データを作成およびアクセスする限り、コードは期待通りに動作します（バグがないと仮定して）。ただし、他の方法（例：任意のプログラミング言語のHDF5 APIを直接使用）でこれを行い、結果が無効な場合、ここにあるコードは「あまりフレンドリーでない」エラーメッセージで失敗する可能性があります。

