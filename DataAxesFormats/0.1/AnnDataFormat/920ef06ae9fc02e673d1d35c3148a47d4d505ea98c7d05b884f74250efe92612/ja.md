`Daf`データを[AnnData](https://pypi.org/project/anndata/)からインポート/エクスポートします。私たちは、[Muon.jl](https://github.com/scverse/Muon.jl)からの`AnnData`のJulia実装を使用します。

異なるデータモデルのため、`AnnData`のすべての内容を`Daf`として表現することはできず、その逆も同様です。しかし、「ほとんど」のデータは自動的に一方の形式から他方に変換できます。両方向での変換はゼロコピーです。つまり、同じベクトルと行列の異なるビューを作成するだけです。また、パフォーマンス向上のために可能な限りメモリマッピングを使用します。

次の`Daf`データは、単純に`AnnData`に保存できません：

  * `AnnData`は、常に「obs」と「var」と呼ばれる2つの軸のデータのみを保存することに制限されています。対照的に、`Daf`は意味のある名前の軸の任意のセットのデータを保存できます。
  * `AnnData`は、これら2つの軸のために「X」と呼ばれる行列プロパティを常に含みます。幸いなことに、他の行列には意味のある名前を付けることが許可されています。対照的に、`Daf`は意味のある名前の行列の任意のセットを保存できます。
  * `AnnData`は行優先の行列しか保持できませんが、Juliaは列優先のレイアウトをデフォルトとしています。`Daf`は、パフォーマンスのためにディスクストレージを犠牲にして、両方のレイアウトを保存できます。

したがって、`Daf`データを`AnnData`として表示する際には、2つの特定の軸を選択し、それらを「obs」と「var」に名前変更し、これらの軸の特定の行列プロパティを選択して「X」と名前変更し、必要に応じて[`relayout!`](@ref)して`AnnData`が満足するようにします。破棄された軸と行列の名前は、`obs_is`、`var_is`、`X_is`と呼ばれる非構造化アノテーションに保存します。これにより、`AnnData`を`Daf`データとして再表示する際に元の名前を再構築できます。

次の`AnnData`は、単純に`Daf`に保存できません：

  * `uns`の非構造化アノテーション内の非スカラー（例：マッピング）。`Daf`の同等物はJSON文字列のバイナリを保存することであり、使用するのが不便です。TODO: このようなデータを扱うためのより良いAPIを提供する。
  * nullableエントリを使用するデータ（例：nullable整数エントリを持つ行列）。対照的に、`Daf`はゼロ値が特別であるという慣習をサポートしています。これは一部のケースでのみ機能します（例：Booleanデータには良い解決策ではありません）。もちろん、Booleanマスクを明示的に保存し、それをデータに適用することは可能ですが、これは不便です。TODO: `Daf`がnullable/マスク付き配列をネイティブにサポートするようにする。
  * カテゴリカルデータ。したがって、カテゴリカルベクトルは単純な文字列に変換されます。しかし、`Daf`は文字列の行列をサポートしていないため、カテゴリカル行列をサポートまたは変換しません。
  * 1つの軸のみを使用する行列データ（つまり、`obsm`および`varm`データ）。ここでの問題は、逆説的に、`Daf`がそのようなデータを「あまりにもよく」サポートしていることです。複数の軸を定義でき、任意の軸のペアに基づいて行列を保存できます。しかし、これには他の軸を明示的に作成する必要があり、その情報は`AnnData`データセットには存在しません。TODO: 非構造化アノテーションが他の軸のエントリを保存できるようにする。

`AnnData`を`Daf`として表示する際には、そのようなサポートされていないデータを無視、警告、またはエラーとして扱います。

!!! warning
    `Daf` APIを介してアクセスされる正方行列は、元の`AnnData`（行優先）行列の（列優先）**転置**になります。


`Daf`データモデルの制限により、正方行列は列優先レイアウトのみで保存されます。対照的に、`AnnData`の正方行列（`obsp`、`varp`）は行優先レイアウトで保存されます。これに対処するためのいくつかの悪い選択肢があります：

  * 正方行列については、すべてのアクセスされたデータが列優先であるという`Daf`の不変条件を破ることができます。これは悪いことです。なぜなら、この不変条件は`Daf`クライアントコードを大幅に簡素化するからです。クライアントにデータレイアウトを確認させ、[`relayout!`](@ref)を呼び出させることは、ユーザーに多くのエラーを引き起こすボイラープレートを追加することになります。
  * `AnnData`と`Daf`の間でデータをコピーする際に[`relayout!`](@ref)を行うことができます。これは悪いことです。なぜなら、データを重複させることを強いるからです。さらに重要なことに、データのレイアウトには通常良い理由があります。たとえば、細胞間の有向グラフを仮定します。一般的な保存方法は、各行が1つの細胞から発生するエッジの重みを含む正方行列を持つことです。これにより、コードは効率的に「すべての細胞をループし、すべての出力エッジをループする」ことができます。データを[`relayout!`](@ref)すると、そのようなループは非常に非効率的になります。
  * `Daf`から転置行列を返すことができます。これは悪いことです。なぜなら、「同じ」データを処理するJuliaコードとPythonコードがインデックスを反転させる必要があるからです（例：Pythonでは`outgoing_weight[from_cell, to_cell]`、Juliaでは`outgoing_weight[to_cell, from_cell]`）。

これらの悪い選択肢の中から選ばなければならない場合、私たちは最後の選択肢を小さな悪として選びました。前提は、JuliaコードはPythonコードとは別に書かれるということです。同じアルゴリズムが両方のシステムで実装されている場合、それは（効率的に！）機能します。つまり、開発者がこの警告を読み、インデックスの順序を反転させる限りです。

非正方行列（例：細胞ごとの遺伝子ごとの`UMIs`行列）についてはこの問題は発生しません。なぜなら、`Daf`はこの場合、同じデータの両方のレイアウトを保存およびアクセスすることを許可しているからです。私たちは単に`AnnData`から行優先データで`Daf`を埋め、他のレイアウトが要求された場合には[`relayout!`](@ref)を行い（結果を保存/キャッシュします）。
