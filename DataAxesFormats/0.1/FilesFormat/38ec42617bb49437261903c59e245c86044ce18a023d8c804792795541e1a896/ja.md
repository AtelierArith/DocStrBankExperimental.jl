`Daf`ストレージフォーマットはディスクファイルに保存されます。これは、ファイルシステムに`Daf`データを永続化する効率的な方法であり、HDF5ファイルにデータを保存するのとは異なるトレードオフを提供します。

欠点としては、ディレクトリであるため、公開したい場合は`zip`や`tar`などのアーカイブファイルを作成する必要があります。また、`FilesDaf`にアクセスすると、HDF5の1つに対して複数のファイルディスクリプタを消費します。そしてもちろん、HDF5にはほとんどのシステムでサポートするライブラリがあります。

利点としては、ファイルのフォーマットが非常にシンプルであるため、HDF5のような複雑なライブラリを必要とせず、任意のプログラミング環境から簡単にアクセスできます。さらに、各スカラー、ベクトル、または行列のプロパティが別々のファイルに保存されているため、データを削除すると自動的にストレージが解放されます（HDF5ファイルでは、実際にストレージを解放するためにファイルを手動で再パックする必要があります）。また、標準ツールを使用してデータを確認できます（例：`ls`やWindowsファイルエクスプローラーを使用してプロパティのリスト、各プロパティが使用するスペース、作成日時などを表示）。最も重要なのは、`make`のような標準ツールを使用して自動的に再現可能な処理ワークフローを作成できることです。

私たちは、以下のように、いくつかのルートディレクトリの下に`Daf`データを保存するために複数のファイルを使用します：

  * ディレクトリには、`scalars`、`axes`、`vectors`、`matrices`の4つのサブディレクトリと、`daf.json`というファイルが含まれます。
  * `daf.json`は、ディレクトリが`Daf`データを含んでいることを示します。このファイルには、`version`キーを持つマッピングがあり、その値は2つの整数の配列です。最初の整数はメジャーバージョン番号で、2番目の整数はマイナーバージョン番号で、[セマンティックバージョニング](https://semver.org/)を使用します。これにより、ディレクトリが`Daf`データを含んでいるかどうか、内部構造のどのバージョンを使用しているかを簡単にテストできます。現在定義されているバージョンは`[1,0]`のみです。
  * `scalars`ディレクトリには、各スカラープロパティが独自の`name.json`ファイルとして含まれ、`type`キーを持つマッピングがあり、その値はスカラーのデータ型（`String`スカラーの場合は`StorageScalar`タイプの1つ）で、`value`キーの値は実際のスカラー値です。
  * `axes`ディレクトリには、各軸ごとに`name.txt`ファイルが含まれ、各行には軸エントリの名前が含まれます。
  * `vectors`ディレクトリには、各軸ごとにディレクトリが含まれ、ベクトルが格納されています。各ベクトルについて、`name.json`ファイルには、ベクトル要素の型を指定する`eltype`キーと、ディスク上のデータの保存方法を指定する`format`キーが含まれ、`dense`または`sparse`のいずれかになります。

    `format`が`dense`の場合、ベクトルエントリを含むファイルがあり、文字列の場合は`name.txt`（各行に1つの値）、バイナリデータの場合は`name.data`（直接アクセスのためにメモリマップできます）になります。

    `format`が`sparse`の場合、非ゼロ値のインデックスのデータ型を指定する`indtype`キーがあり、非ゼロエントリのインデックスを含む2つのバイナリデータファイル、`name.nzind`と非ゼロエントリの値を含む`name.nzval`（直接アクセスのためにメモリマップできます）が含まれます。詳細については、Juliaの`SparseVector`実装を参照してください。
  * `matrices`ディレクトリには、行軸ごとにディレクトリが含まれ、列軸ごとにディレクトリがあり、行列が格納されています。各行列について、`name.json`ファイルには、行列要素の型を指定する`eltype`キーと、ディスク上のデータの保存方法を指定する`format`キーが含まれ、`dense`または`sparse`のいずれかになります。

    `format`が`dense`の場合、列優先レイアウトの`name.data`バイナリファイルが存在します（直接アクセスのためにメモリマップできます）。

    `format`が`sparse`の場合、非ゼロ値のインデックスのデータ型を指定する`indtype`キーがあり、非ゼロ値のインデックスを含む`name.colptr`、`name.rowval`の2つのバイナリデータファイルと、非ゼロエントリの値を含む`name.nzval`（直接アクセスのためにメモリマップできます）が含まれます。詳細については、Juliaの`SparseMatrixCSC`実装を参照してください。

例のディレクトリ構造：

```
example-daf-dataset-root-directory/
├─ daf.json
├─ scalars/
│  └─ version.json
├─ axes/
│  ├─ cell.txt
│  └─ gene.txt
├─ vectors/
│  ├─ cell/
│  │  ├─ batch.json
│  │  └─ batch.txt
│  └─ gene/
│     ├─ is_marker.json
│     └─ is_marker.data
└─ matrices/
   ├─ cell/
   │  ├─ cell/
   │  └─ gene/
   │     ├─ UMIs.json
   │     ├─ UMIs.colptr
   │     ├─ UMIs.rowval
   │     └─ UMIs.nzval
   └─ gene/
      ├─ cell/
      └─ gene/
```

!!! note
    すべてのバイナリデータは、リトルエンディアンのバイト順で要素のシーケンスとして保存され、ヘッダーやパディングはありません。（密な）行列は列優先レイアウトで保存され（これはJuliaのネイティブな行列レイアウトに一致します）。

    すべての文字列データは、1行に1エントリを保存し、OSに関係なく`


`文字で区切られています。したがって、軸エントリ名やベクトルプロパティ値の中に改行を含めることはできません。少なくとも`FilesDaf`に保存する場合はそうです。

```
`Daf`データを含むHDF5ファイルを作成する際は、`;fapl=HDF5.FileAccessProperties(;alignment=(1,8))`を指定する必要があります。これにより、すべてのメモリバッファが効率的なアクセスのために適切に整列されます。そうでない場合、メモリマッピングは**はるかに**効率が悪くなります。したがって、適切な整列を強制しないHDF5ファイルに保存された`Daf`データにアクセスしようとすると、警告が生成されます。
```

これがすべてです。フォーマットは意図的にシンプルで透明性があり、他の（標準的な）ツールによるアクセスを最大化しています。それでも、データを作成するにはJuliaの`Daf`パッケージを使用するのが最も簡単です。

!!! note
    ここにあるコードは、ファイルデータが上記のすべての規則と制限に従っていることを前提としています。`FilesDaf`を使用してファイル内でのみ`Daf`データを作成およびアクセスする限り、コードは期待通りに動作します（バグがないと仮定して）。ただし、他の方法（例：ファイルシステムとカスタムツールを直接使用）でこれを行い、結果が無効な場合、ここにあるコードは「あまり親切ではない」エラーメッセージで失敗する可能性があります。

