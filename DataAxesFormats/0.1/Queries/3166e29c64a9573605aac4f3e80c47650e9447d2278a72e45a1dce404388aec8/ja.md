```
Query(
    query::QueryString,
    operand_only::Maybe{Type{QueryOperation}} = nothing,
) <: QueryOperation
```

クエリは、[`DafReader`](@ref) からデータを抽出するための（サブ）プロセスの説明です。完全なクエリは、いくつかの [`QueryOperation`](@ref) のシーケンスであり、これを一度に1つずつ [`DafReader`](@ref) に適用すると、スカラー、ベクトル、または行列の結果が得られます。

クエリを適用するには、[`get_query`](@ref) を呼び出して、いくつかの [`DafReader`](@ref) データにクエリを適用します（$get_query(daf, query)$ の代わりに短縮形 $daf[query]$ を使用することもできます）。デフォルトでは、クエリ操作はその結果をメモリにキャッシュし、再クエリを高速化するために [`QueryData`](@ref CacheGroup) として保存します。これにより、大量のメモリがロックされる可能性があります。キャッシュを解放するには、[`empty_cache!`](@ref) を使用できます。

クエリは2つの方法で構築できます。コード内では、クエリ操作をチェーンすることでクエリを構築できます（例：式 `Axis("gene") |> Lookup("is_marker")` は、`gene` 軸の `is_marker` ベクトルプロパティを検索します）。

また、クエリは文字列から解析することもでき、これは [`Query`](@ref) オブジェクトに解析する必要があります（例：上記は `Query("/gene:is_marker")` と書くことができます）。サポートされている演算子の表については、[`QUERY_OPERATORS`](@ref) を参照してください。演算子の周りのスペース（およびコメント）はオプションです。詳細については [`tokenize`](@ref) を参照してください。また、[`Query`](@ref) を `string` に変換することもできます（または `print` するなど）ので、その表現を見ることができます。これは `error` メッセージやクエリ結果をキャッシュする際のキーとして使用されます。

クエリ文字列は `\` をエスケープ文字として使用するため、クエリには `raw` 文字列リテラルを使用する方が簡単です（例：`Query(raw"cell = ATCG\:B1 : age")` 対 `Query("cell = ATCG\\:B1 : age")`）。これをさらに簡単にするために、[`q`](@ref @q_str) マクロを提供しています（例：`q"cell = ATCG\:B1 : batch"`）これは、Julia の標準 `r` マクロと同様にリテラル `Regex` 文字列に対して機能します。

提供されたクエリ文字列がオペランドのみを含み、`operand_only` が指定されている場合、それはオペレーターとして使用されます（すなわち、`Query("metacell")` はエラーですが、`Query("metacell", Axis)` は `Axis("metacell")` と同じです）。これは、サフィックスクエリを提供する際に便利です（例：[`get_frame`](@ref) 用）。

クエリを文字列として表現できることは、設定ファイルから読み込んだり、アプリケーション UI でユーザーが入力できるようにすることを可能にします（例：ユーザーがクエリを使用して散布図の X、Y、および/または色を指定できるようにする）。同時に、コードを使用してクエリを段階的に構築できることは、便利な再利用を可能にします（例：`Daf` ビューで軸のサブクエリを再利用するなど）、文字列表現を通過する必要がありません。

`Daf` は、クエリを構築するために使用できる包括的な [`QueryOperation`](@ref) のセットを提供します。以下に示す [`QUERY_OPERATORS`](@ref) は、基本的な機能を提供します（例：[`Axis`](@ref) またはプロパティ [`Lookup`](@ref) を指定する）。さらに、`Daf` は計算操作（[`EltwiseOperation`](@ref) および [`ReductionOperation`](@ref)）を提供し、外部パッケージによって追加の操作を提供できるようにします。

明らかに、すべての可能な操作の組み合わせが意味を持つわけではありません（例：`Lookup("is_marker") |> Axis("cell")` は機能しません）。有効な組み合わせの完全なリストについては、以下の [`NAMES_QUERY`](@ref)、[`SCALAR_QUERY`](@ref)、[`VECTOR_QUERY`](@ref)、および [`MATRIX_QUERY`](@ref) を参照してください。

!!! note
    これは非常にシンプルなクエリ言語として始まりました（単純なケースに関しては今でもそうですが）、有用で複雑なシナリオを許可するために複雑になりました。特に、ここでの連結言語（`ggplot` に似たアプローチ）を使用することで、単純なことがより簡単になりますが、より高度な操作のいくつかに対してはやや不自然で制限的になります。ただし、RPN や LISP 表記を使用してそのようなケースをより良くサポートすることは、単純なケースに対してはあまり良い構文にならなかったでしょう。

    できるだけ多くの範囲をカバーできたことを願っていますので、さらなる操作を追加する必要がないことを願っています。また、ほとんどの場合、ベクトル/行列データにアクセスし、複雑なクエリを書く代わりに任意の計算を実行するコードを書くことができます。ただし、ビューやアダプターを定義する際には、データを指定するためにクエリメカニズムに依存しているため、これはオプションではありません。

