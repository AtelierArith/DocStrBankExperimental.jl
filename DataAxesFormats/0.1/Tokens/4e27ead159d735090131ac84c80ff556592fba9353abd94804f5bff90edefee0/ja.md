```
escape_value(value::AbstractString)::String
```

生の `value`（軸の名前、軸のエントリまたはプロパティ、またはパラメータ値）には特殊文字が含まれている可能性があるため、単一の値 [`Token`](@ref) として使用するためにエスケープされたバージョンを返します。

次の種類の文字を考慮する必要があります：

  * **安全**（[`is_value_char`](@ref)）文字には `a` - `z`、`A` - `Z`、`0` - `9`、`_`、`+`、`-`、および `.` が含まれ、非ASCII（すなわち、Unicode）文字も含まれます。これらの文字の任意のシーケンスは単一の値 [`Token`](@ref) と見なされます。これらはすべての一般的なケース（符号付き整数および浮動小数点値を含む）をカバーします。
  * その他のすべてのASCII文字は（少なくとも潜在的に）**特殊**であり、すなわち、操作を説明するために使用される可能性があります。
  * **任意の**文字の前に `\` を付けることで、値 [`Token`](@ref) 内で使用できるようになります。これは、名前や値に特殊文字が含まれている場合に便利です。たとえば、名前が `ACTG:Plate1` のセルがあり、この特定のセルのバッチの名前にアクセスしたい場合は、`/ cell = ACTG\:Plate1 : batch` と書く必要があります。

!!! note
    `\` 文字は、非表示文字を書くために `"..."` 文字列リテラル内でも Julia によって使用されます。たとえば、`"\n"` は改行を含む単一文字列であり、したがって `"\\"` は単一の `\` を書くために使用されます。したがって、上記の例は `"cell = ACTG\\:Plate1 : batch"` と書かなければなりません。これはあまり良くありません。

    幸いなことに、Julia には Python の `r"..."` 文字列と同様に機能する `raw"..."` 文字列リテラルもあります（Julia では、`r"..."` は文字列ではなく正規表現です）。生文字列リテラル内では、`\` は `\` です（`"` の前にない限り）。したがって、上記の例は `raw"/ cell = ACTG\:Plate1 : batch` と書くこともでき、より読みやすくなります。


`escape_value` に戻ると、これは任意の特殊文字の前に `\` を付けます。これは、プログラム的に値を注入したい場合に便利です。これは、値をクエリ文字列に埋め込むために `$(...)` を使用する際によく発生します。たとえば、`/ $(axis) @ $(property)` と書かないでください。これは安全ではなく、埋め込まれた変数のいずれかが安全でない文字を含む可能性があります。代わりに、`/ $(escape_value(axis)) @ $(escape_value(property))` のように書くべきです。
