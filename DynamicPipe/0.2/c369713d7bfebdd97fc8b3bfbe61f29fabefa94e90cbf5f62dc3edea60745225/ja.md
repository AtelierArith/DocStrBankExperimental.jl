```
@>>(code)
```

コードは、パイプの最初の要素が書き換えられずにそのままパイプを通過するという、@> と同じ書き換えルールを使用して書き換えられます。

関数は以下のルールに従って作成されます：

1. アンダースコアは関数引数として扱われます。 `@>> [1,2,3] |> sum(_)` は次のように等価です：

`[1,2,3] |> x -> sum(x)`

2. 式にアンダースコアがない場合、最初の引数が補完されます。

`@>> [1,2,3] |> .+(3)` は次のように等価です：`[1,2,3] |> x -> .+(x, 3)`

3. 式がシンボルの場合、それは関数として扱われます。したがって、`@> "hello world" |> print` は次のように解釈されます：

`"hello world" |> x -> print(x)`

4. 上記の2つのルールは、パイプ演算子 `|>` で区切られた式にも適用されます。したがって、

`@>> 1 |> [_, 1, 2] |> sum()` は次のように等価です：`1 |> x -> [x, 1, 2] |> x -> sum(x)`

5. これらのルールはマクロにも適用されますが、@> と @>> の例外があります。したがって、`@>> "hello world" |> @show` は次のように等価です：

`@>> "hello world" |> @show(_)`

6. マクロは自分自身の中でも使用できます。@>> が自分自身の中に現れる場合、または @> と _ がパイプの最初の部分にある場合、それは周囲のコンテキストから来ます。以下の例を参照してください。
7. パイプ文字 `|>` の代わりに、異なる関数を作成するために `begin ... end` ブロックを使用でき、ブロック内の各行に対して別の関数が作成されます。以下の例を参照してください。
8. パイプ文字のシーケンス内にパイプ文字のシーケンスがある場合、最初の部分にアンダースコアが含まれていない場合、新しいパイプが作成されます。したがって、`@>> 1 |> [_, 2, sqrt(36) |> _/2]` は次のように等価です：`1 |> x -> [x, 3, sqrt(36) |> y -> y/2]`。

例：

```julia-repl
julia> @>> 1 |>
            [(@>> _ |> +(1, 2)), 1, 1] |>
            sum
6
```

```julia-repl
julia> @>> begin 
            1 
            [(@>> _ |> _ + 2), 1, 1] 
            sum
        end
5
```
