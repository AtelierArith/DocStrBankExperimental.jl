```
@>(code)
```

コードを再構成して、1つの引数を取る無名関数を作成します。これは、1つのオブジェクトを複数の関数にパイプするために設計されています。

関数は次のルールに従って作成されます：

1. アンダースコアは関数引数として扱われます。`@> sum(_)`は`x -> sum(x)`と同等です。
2. 式にアンダースコアがない場合、最初の引数が補完されます。

`@> +(3)`は`x -> +(x, 3)`と同等です。

3. 式がシンボルの場合、それは関数として扱われるため、`@> print`は次のように解釈されます。

`x -> print(x)`

4. 上記の2つのルールは、パイプ演算子`|>`で区切られた式にも適用されます。したがって、

`@> [_, 1, 2] |> sum()`は`x -> [x, 1, 2] |> x -> sum(x)`と同等です。

5. これらのルールはマクロにも適用されますが、@>と@>>は例外です。
6. 入力は`begin end`ブロックでも可能です。ブロック内の各行に対して別の関数が作成され、前の関数の結果が次の関数に渡されます。
7. パイプ文字のシーケンスがパイプ文字のシーケンス内にある場合、最初のパートにアンダースコアが含まれていない場合は新しいパイプが作成されます。したがって、`@> [_, 2, sqrt(36) |> _/2]`は`x -> [x, 3, sqrt(36) |> y -> y/2]`と同等です。

このマクロは自体でも使用できますが、望ましい効果を得るためにはしばしば括弧の使用が必要です。

例：

```julia-repl
julia> 1 |>
           @>  [_ |> @>(_ + 2), 1, 1] |>
               sum
5
```

```julia-repl
julia> 1 |>
           @>  begin
                [1, 1, _ |> @> +(1, 2)] 
                sum
            end
6
```
