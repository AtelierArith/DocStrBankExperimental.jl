Le type `AbstractChar` est le supertype de toutes les implémentations de caractères en Julia. Un caractère représente un point de code Unicode et peut être converti en un entier via la fonction [`codepoint`](@ref) afin d'obtenir la valeur numérique du point de code, ou construit à partir du même entier. Ces valeurs numériques déterminent comment les caractères sont comparés avec `<` et `==`, par exemple. Les nouveaux types `T <: AbstractChar` devraient définir une méthode `codepoint(::T)` et un constructeur `T(::UInt32)`, au minimum.

Un sous-type donné d'`AbstractChar` peut être capable de représenter uniquement un sous-ensemble de Unicode, auquel cas la conversion d'une valeur `UInt32` non prise en charge peut générer une erreur. Inversement, le type intégré [`Char`](@ref) représente un *superset* de Unicode (afin d'encoder sans perte des flux d'octets invalides), auquel cas la conversion d'une valeur non-Unicode *en* `UInt32` génère une erreur. La fonction [`isvalid`](@ref) peut être utilisée pour vérifier quels points de code sont représentables dans un type `AbstractChar` donné.

En interne, un type `AbstractChar` peut utiliser une variété d'encodages. La conversion via `codepoint(char)` ne révélera pas cet encodage car elle renvoie toujours la valeur Unicode du caractère. `print(io, c)` de tout `c::AbstractChar` produit un encodage déterminé par `io` (UTF-8 pour tous les types `IO` intégrés), via conversion en `Char` si nécessaire.

`write(io, c)`, en revanche, peut émettre un encodage en fonction de `typeof(c)`, et `read(io, typeof(c))` devrait lire le même encodage que `write`. Les nouveaux types `AbstractChar` doivent fournir leurs propres implémentations de `write` et `read`.
