`AbstractChar` türü, Julia'daki tüm karakter uygulamalarının üst türüdür. Bir karakter, bir Unicode kod noktasını temsil eder ve kod noktasının sayısal değerini elde etmek için [`codepoint`](@ref) fonksiyonu aracılığıyla bir tam sayıya dönüştürülebilir veya aynı tam sayıdan oluşturulabilir. Bu sayısal değerler, karakterlerin `<` ve `==` ile nasıl karşılaştırıldığını belirler. Yeni `T <: AbstractChar` türleri, en azından bir `codepoint(::T)` metodu ve bir `T(::UInt32)` yapıcı tanımlamalıdır.

Verilen bir `AbstractChar` alt türü, yalnızca Unicode'un bir alt kümesini temsil etme yeteneğine sahip olabilir; bu durumda, desteklenmeyen bir `UInt32` değerine dönüşüm bir hata fırlatabilir. Tersine, yerleşik [`Char`](@ref) türü, geçersiz bayt akışlarını kayıpsız bir şekilde kodlamak için bir *üst küme* Unicode'u temsil eder; bu durumda, bir Unicode olmayan değerin `UInt32`'ye dönüşümü bir hata fırlatır. [`isvalid`](@ref) fonksiyonu, belirli bir `AbstractChar` türünde hangi kod noktalarının temsil edilebilir olduğunu kontrol etmek için kullanılabilir.

Dahili olarak, bir `AbstractChar` türü çeşitli kodlamalar kullanabilir. `codepoint(char)` aracılığıyla dönüşüm, bu kodlamayı açığa çıkarmayacaktır çünkü her zaman karakterin Unicode değerini döndürür. Herhangi bir `c::AbstractChar` için `print(io, c)` ifadesi, gerekirse `Char`'a dönüşüm yoluyla `io` tarafından belirlenen bir kodlama üretir (tüm yerleşik `IO` türleri için UTF-8).

Buna karşılık, `write(io, c)`, `typeof(c)`'ye bağlı olarak bir kodlama yayabilir ve `read(io, typeof(c))`, `write` ile aynı kodlamayı okumalıdır. Yeni `AbstractChar` türleri, `write` ve `read` için kendi uygulamalarını sağlamalıdır.
