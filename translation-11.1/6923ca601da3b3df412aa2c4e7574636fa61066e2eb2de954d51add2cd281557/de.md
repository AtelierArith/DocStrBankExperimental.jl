Der `AbstractChar`-Typ ist der Supertyp aller Zeichenimplementierungen in Julia. Ein Zeichen repräsentiert einen Unicode-Codepunkt und kann über die [`codepoint`](@ref)-Funktion in eine Ganzzahl umgewandelt werden, um den numerischen Wert des Codepunkts zu erhalten, oder aus derselben Ganzzahl konstruiert werden. Diese numerischen Werte bestimmen, wie Zeichen mit `<` und `==` verglichen werden, zum Beispiel. Neue `T <: AbstractChar`-Typen sollten mindestens eine `codepoint(::T)`-Methode und einen `T(::UInt32)`-Konstruktor definieren.

Ein gegebener `AbstractChar`-Subtyp kann möglicherweise nur eine Teilmenge von Unicode darstellen, in welchem Fall die Umwandlung von einem nicht unterstützten `UInt32`-Wert einen Fehler auslösen kann. Umgekehrt repräsentiert der eingebaute [`Char`](@ref)-Typ ein *Superset* von Unicode (um ungültige Byte-Streams verlustfrei zu kodieren), in welchem Fall die Umwandlung eines Nicht-Unicode-Wertes *zu* `UInt32` einen Fehler auslöst. Die [`isvalid`](@ref)-Funktion kann verwendet werden, um zu überprüfen, welche Codepunkte in einem gegebenen `AbstractChar`-Typ darstellbar sind.

Intern kann ein `AbstractChar`-Typ eine Vielzahl von Kodierungen verwenden. Die Umwandlung über `codepoint(char)` wird diese Kodierung nicht offenbaren, da sie immer den Unicode-Wert des Zeichens zurückgibt. `print(io, c)` eines beliebigen `c::AbstractChar` erzeugt eine Kodierung, die durch `io` bestimmt wird (UTF-8 für alle eingebauten `IO`-Typen), gegebenenfalls durch Umwandlung in `Char`.

`write(io, c)` hingegen kann eine Kodierung ausgeben, die von `typeof(c)` abhängt, und `read(io, typeof(c))` sollte dieselbe Kodierung lesen wie `write`. Neue `AbstractChar`-Typen müssen ihre eigenen Implementierungen von `write` und `read` bereitstellen.
