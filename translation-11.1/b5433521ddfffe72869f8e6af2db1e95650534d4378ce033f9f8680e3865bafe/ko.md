```
@debug 메시지  [key=value | value ...]
@info  메시지  [key=value | value ...]
@warn  메시지  [key=value | value ...]
@error 메시지  [key=value | value ...]

@logmsg 레벨 메시지 [key=value | value ...]
```

정보성 `메시지`로 로그 레코드를 생성합니다. 편의성을 위해 네 가지 로깅 매크로 `@debug`, `@info`, `@warn` 및 `@error`가 정의되어 있으며, 이는 표준 심각도 수준인 `Debug`, `Info`, `Warn` 및 `Error`에서 로그를 기록합니다. `@logmsg`는 `level`을 프로그래밍적으로 모든 `LogLevel` 또는 사용자 정의 로그 수준 유형으로 설정할 수 있게 해줍니다.

`메시지`는 로그 이벤트에 대한 사람이 읽을 수 있는 설명인 문자열로 평가되는 표현식이어야 합니다. 관례적으로 이 문자열은 표시될 때 마크다운 형식으로 포맷됩니다.

선택적 `key=value` 쌍 목록은 로그 레코드의 일부로 로깅 백엔드에 전달될 임의의 사용자 정의 메타데이터를 지원합니다. 만약 `value` 표현식만 제공되면, [`Symbol`](@ref)를 사용하여 표현식을 나타내는 키가 생성됩니다. 예를 들어, `x`는 `x=x`가 되고, `foo(10)`은 `Symbol("foo(10)")=foo(10)`이 됩니다. 키 값 쌍 목록을 스플래팅하려면 일반 스플래팅 구문인 `@info "blah" kws...`를 사용하세요.

자동으로 생성된 로그 데이터를 재정의할 수 있는 몇 가지 키가 있습니다:

  * `_module=mod`는 메시지의 소스 위치와 다른 출처 모듈을 지정하는 데 사용할 수 있습니다.
  * `_group=symbol`은 메시지 그룹을 재정의하는 데 사용할 수 있습니다(이는 일반적으로 소스 파일의 기본 이름에서 파생됩니다).
  * `_id=symbol`은 자동으로 생성된 고유 메시지 식별자를 재정의하는 데 사용할 수 있습니다. 이는 서로 다른 소스 라인에서 생성된 메시지를 매우 밀접하게 연관시켜야 할 때 유용합니다.
  * `_file=string` 및 `_line=integer`는 로그 메시지의 명백한 소스 위치를 재정의하는 데 사용할 수 있습니다.

관례적인 의미를 가진 몇 가지 키 값 쌍도 있습니다:

  * `maxlog=integer`는 메시지가 `maxlog` 횟수 이상 표시되지 않아야 한다는 힌트로 백엔드에 사용해야 합니다.
  * `exception=ex`는 로그 메시지와 함께 예외를 전송하는 데 사용되며, 종종 `@error`와 함께 사용됩니다. 관련된 백트레이스 `bt`는 튜플 `exception=(ex,bt)`를 사용하여 첨부할 수 있습니다.

# 예시

```julia
@debug "자세한 디버깅 정보. 기본적으로 보이지 않음"
@info  "정보 메시지"
@warn  "무언가 이상했습니다. 주의해야 합니다"
@error "비치명적인 오류가 발생했습니다"

x = 10
@info "메시지에 첨부된 일부 변수" x a=42.0

@debug begin
    sA = sum(A)
    "sum(A) = $sA는 비싼 작업으로, `shouldlog`가 true를 반환할 때만 평가됩니다"
end

for i=1:10000
    @info "기본 백엔드에서는 (i = $i)를 열 번만 볼 수 있습니다"  maxlog=10
    @debug "Algorithm1" i progress=i/10000
end
```
