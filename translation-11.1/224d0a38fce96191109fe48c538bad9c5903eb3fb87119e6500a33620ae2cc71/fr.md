```
merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated}) -> analysis, preference
```

Exécutez l'analyse sur les branches pointées par les extrémités de branche annotées `anns` et déterminez dans quelles circonstances elles peuvent être fusionnées. Par exemple, si `anns[1]` est simplement un ancêtre de `ann[2]`, alors `merge_analysis` rapportera qu'une fusion par avance rapide est possible.

Retournez deux sorties, `analysis` et `preference`. `analysis` a plusieurs valeurs possibles :     * `MERGE_ANALYSIS_NONE` : il n'est pas possible de fusionner les éléments de `anns`.     * `MERGE_ANALYSIS_NORMAL` : une fusion normale, lorsque HEAD et les commits que l'utilisateur souhaite fusionner ont tous divergé d'un ancêtre commun. Dans ce cas, les changements doivent être résolus et des conflits peuvent survenir.     * `MERGE_ANALYSIS_UP_TO_DATE` : tous les commits d'entrée que l'utilisateur souhaite fusionner peuvent être atteints depuis HEAD, donc aucune fusion n'a besoin d'être effectuée.     * `MERGE_ANALYSIS_FASTFORWARD` : le commit d'entrée est un descendant de HEAD et donc aucune fusion n'a besoin d'être effectuée - au lieu de cela, l'utilisateur peut simplement vérifier le(s) commit(s) d'entrée.     * `MERGE_ANALYSIS_UNBORN` : le HEAD du dépôt fait référence à un commit qui n'existe pas. Il n'est pas possible de fusionner, mais il peut être possible de vérifier les commits d'entrée. `preference` a également plusieurs valeurs possibles :     * `MERGE_PREFERENCE_NONE` : l'utilisateur n'a pas de préférence.     * `MERGE_PREFERENCE_NO_FASTFORWARD` : ne pas autoriser les fusions par avance rapide.     * `MERGE_PREFERENCE_FASTFORWARD_ONLY` : autoriser uniquement les fusions par avance rapide et aucun autre type (ce qui peut introduire des conflits). `preference` peut être contrôlé par la configuration git du dépôt ou globale.
