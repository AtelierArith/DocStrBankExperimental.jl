```
gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)
```

Résout l'équation linéaire `A * X = B` (`trans = N`), `transpose(A) * X = B` (`trans = T`), ou `adjoint(A) * X = B` (`trans = C`) en utilisant la factorisation `LU` de `A`. `fact` peut être `E`, auquel cas `A` sera équilibré et copié dans `AF` ; `F`, auquel cas `AF` et `ipiv` d'une factorisation `LU` précédente sont des entrées ; ou `N`, auquel cas `A` sera copié dans `AF` puis factorisé. Si `fact = F`, `equed` peut être `N`, signifiant que `A` n'a pas été équilibré ; `R`, signifiant que `A` a été multiplié par `Diagonal(R)` par la gauche ; `C`, signifiant que `A` a été multiplié par `Diagonal(C)` par la droite ; ou `B`, signifiant que `A` a été multiplié par `Diagonal(R)` par la gauche et `Diagonal(C)` par la droite. Si `fact = F` et `equed = R` ou `B`, les éléments de `R` doivent tous être positifs. Si `fact = F` et `equed = C` ou `B`, les éléments de `C` doivent tous être positifs.

Retourne la solution `X` ; `equed`, qui est une sortie si `fact` n'est pas `N`, et décrit l'équilibrage qui a été effectué ; `R`, le diagonal d'équilibrage des lignes ; `C`, le diagonal d'équilibrage des colonnes ; `B`, qui peut être écrasé par sa forme équilibrée `Diagonal(R)*B` (si `trans = N` et `equed = R,B`) ou `Diagonal(C)*B` (si `trans = T,C` et `equed = C,B`) ; `rcond`, le nombre de condition réciproque de `A` après équilibrage ; `ferr`, la limite d'erreur directe pour chaque vecteur de solution dans `X` ; `berr`, la limite d'erreur directe pour chaque vecteur de solution dans `X` ; et `work`, le facteur de croissance de pivot réciproque.
