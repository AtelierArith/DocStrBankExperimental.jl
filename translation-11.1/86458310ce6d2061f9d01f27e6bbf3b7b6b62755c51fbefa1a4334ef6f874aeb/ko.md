```
==(x, y)
```

일반적인 동등성 연산자입니다. [`===`](@ref)로 대체됩니다. 동등성 개념이 있는 모든 유형에 대해 구현되어야 하며, 이는 인스턴스가 나타내는 추상 값에 기반합니다. 예를 들어, 모든 숫자 유형은 유형을 무시하고 숫자 값으로 비교됩니다. 문자열은 인코딩을 무시하고 문자 시퀀스로 비교됩니다. 동일한 유형의 컬렉션은 일반적으로 키 집합을 비교하며, 이들이 `==`이면 각 키에 대한 값을 비교하여 모든 쌍이 `==`이면 true를 반환합니다. 다른 속성은 일반적으로 고려되지 않습니다(예: 정확한 유형).

이 연산자는 부동 소수점 수에 대한 IEEE 의미론을 따릅니다: `0.0 == -0.0` 및 `NaN != NaN`.

결과는 `Bool` 유형이며, 피연산자 중 하나가 [`missing`](@ref)인 경우 `missing`이 반환됩니다 ([삼값 논리](https://en.wikipedia.org/wiki/Three-valued_logic)). 컬렉션은 일반적으로 [`all`](@ref)과 유사한 삼값 논리를 구현하며, 피연산자 중 하나라도 누락된 값을 포함하면 누락을 반환하고 다른 모든 쌍이 같으면 true를 반환합니다. 항상 `Bool` 결과를 얻으려면 [`isequal`](@ref) 또는 [`===`](@ref)를 사용하십시오.

# 구현

새로운 숫자 유형은 이 함수를 새 유형의 두 인수에 대해 구현하고 가능한 경우 프로모션 규칙을 통해 다른 유형과의 비교를 처리해야 합니다.

[`isequal`](@ref)는 `==`로 대체되므로 `==`의 새로운 메서드는 [`Dict`](@ref) 유형이 키를 비교하는 데 사용됩니다. 귀하의 유형이 사전 키로 사용될 경우, 따라서 [`hash`](@ref)도 구현해야 합니다.

어떤 유형이 `==`, [`isequal`](@ref), 및 [`isless`](@ref)를 정의하는 경우, 비교의 일관성을 보장하기 위해 [`<`](@ref)도 구현해야 합니다.
