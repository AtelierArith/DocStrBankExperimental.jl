```
mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)
mmap(type::Type{Array{T,N}}, dims)
```

메모리 매핑을 사용하여 파일에 연결된 `Array`를 생성합니다. 이는 컴퓨터의 메모리에 맞지 않을 정도로 큰 데이터를 다루는 편리한 방법을 제공합니다.

타입은 `Array{T,N}`으로, `T`의 비트 타입 요소와 배열의 바이트 해석 방식을 결정하는 차원 `N`을 가집니다. 파일은 이진 형식으로 저장되어야 하며, 형식 변환은 불가능합니다(이는 운영 체제의 제한 사항이며, Julia와는 관련이 없습니다).

`dims`는 배열의 크기 또는 길이를 지정하는 튜플 또는 단일 [`Integer`](@ref)입니다.

파일은 스트림 인수를 통해 전달되며, 열려 있는 [`IOStream`](@ref) 또는 파일 이름 문자열로 전달됩니다. 스트림을 초기화할 때, "읽기 전용" 배열의 경우 `"r"`을 사용하고, 디스크에 값을 쓰기 위해 새 배열을 생성할 경우 `"w+"`를 사용합니다.

`type` 인수가 지정되지 않으면 기본값은 `Vector{UInt8}`입니다.

예를 들어, 파일의 헤더를 건너뛰고 싶다면 바이트 단위의 오프셋을 선택적으로 지정할 수 있습니다. 오프셋의 기본값은 `IOStream`의 현재 스트림 위치입니다.

`grow` 키워드 인수는 요청된 배열의 크기를 수용하기 위해 디스크 파일이 확장되어야 하는지를 지정합니다(총 파일 크기가 요청된 배열 크기보다 작을 경우). 파일을 확장하려면 쓰기 권한이 필요합니다.

`shared` 키워드 인수는 결과 `Array`와 그에 대한 변경 사항이 동일한 파일을 매핑하는 다른 프로세스에 보일 것인지를 지정합니다.

예를 들어, 다음 코드는

```julia
# mmapping을 위한 파일 생성
# (이 단계에서도 mmap를 사용할 수 있습니다)
using Mmap
A = rand(1:20, 5, 30)
s = open("/tmp/mmap.bin", "w+")
# 배열의 차원을 파일의 첫 두 Int로 기록합니다
write(s, size(A,1))
write(s, size(A,2))
# 이제 데이터를 기록합니다
write(s, A)
close(s)

# 다시 읽어 테스트합니다
s = open("/tmp/mmap.bin")   # 기본값은 읽기 전용
m = read(s, Int)
n = read(s, Int)
A2 = mmap(s, Matrix{Int}, (m,n))
```

`m`-by-`n` `Matrix{Int}`를 생성하며, 이는 스트림 `s`와 연결된 파일에 연결됩니다.

보다 이식 가능한 파일은 단어 크기 – 32비트 또는 64비트 – 및 엔디안 정보를 헤더에 인코딩해야 합니다. 실제로는 HDF5와 같은 표준 형식을 사용하여 이진 데이터를 인코딩하는 것을 고려하십시오(메모리 매핑과 함께 사용할 수 있습니다).
