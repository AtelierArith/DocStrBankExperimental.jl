```
reduce(op, itr; [init])
```

주어진 이진 연산자 `op`로 주어진 컬렉션 `itr`을 축소합니다. 제공된 경우, 초기 값 `init`은 `op`의 중립 요소여야 하며, 이는 빈 컬렉션에 대해 반환됩니다. `init`이 비어 있지 않은 컬렉션에 사용되는지는 명시되어 있지 않습니다.

빈 컬렉션의 경우, `init`을 제공하는 것이 필요하지만, `op`가 `+`, `*`, `max`, `min`, `&`, `|` 중 하나인 특별한 경우에는 Julia가 `op`의 중립 요소를 결정할 수 있습니다.

일부 일반적으로 사용되는 연산자에 대한 축소는 특별한 구현을 가질 수 있으며, 대신 사용해야 합니다: [`maximum`](@ref)`(itr)`, [`minimum`](@ref)`(itr)`, [`sum`](@ref)`(itr)`, [`prod`](@ref)`(itr)`, [`any`](@ref)`(itr)`, [`all`](@ref)`(itr)`. 특정 배열의 배열을 연결하는 효율적인 방법은 `reduce(`[`vcat`](@ref)`, arr)` 또는 `reduce(`[`hcat`](@ref)`, arr)`을 호출하는 것입니다.

축소의 결합성은 구현에 따라 다릅니다. 이는 `-`와 같은 비결합 연산을 사용할 수 없음을 의미합니다. 왜냐하면 `reduce(-,[1,2,3])`가 `(1-2)-3` 또는 `1-(2-3)`으로 평가되어야 하는지 정의되지 않기 때문입니다. 보장된 왼쪽 또는 오른쪽 결합성을 위해 대신 [`foldl`](@ref) 또는 [`foldr`](@ref) 를 사용하십시오.

일부 연산은 오류를 누적합니다. 축소가 그룹으로 실행될 수 있다면 병렬성이 더 쉬워질 것입니다. Julia의 향후 버전에서는 알고리즘이 변경될 수 있습니다. 정렬된 컬렉션을 사용하는 경우 요소의 순서는 재배열되지 않습니다.

# 예제

```jldoctest
julia> reduce(*, [2; 3; 4])
24

julia> reduce(*, [2; 3; 4]; init=-1)
-24
```
