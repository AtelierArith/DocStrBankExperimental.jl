```
unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)
```

指定されたアドレス `pointer` にあるデータの周りに Julia の `Array` オブジェクトをラップします。コピーは作成されません。ポインタの要素型 `T` は配列の要素型を決定します。`dims` は整数（1次元配列の場合）または配列の次元のタプルです。`own` はオプションで、Julia がメモリの所有権を取得し、配列がもはや参照されなくなったときにポインタに対して `free` を呼び出すかどうかを指定します。

この関数は「unsafe」とラベル付けされています。なぜなら、`pointer` が要求された長さのデータに対する有効なメモリアドレスでない場合、クラッシュするからです。[`unsafe_load`](@ref) や [`unsafe_store!`](@ref) とは異なり、プログラマーは異なる要素型の2つの配列を通じて基礎データにアクセスしないことを保証する責任があります。これは C の厳密なエイリアス規則に似ています。
