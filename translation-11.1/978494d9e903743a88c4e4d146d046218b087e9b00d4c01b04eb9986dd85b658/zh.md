```
@simd
```

注释一个 `for` 循环，以允许编译器采取额外的自由度来允许循环重排序

!!! 警告     此功能是实验性的，可能会在未来的 Julia 版本中发生变化或消失。错误使用 `@simd` 宏可能会导致意外结果。

在 `@simd for` 循环中迭代的对象应该是一个一维范围。通过使用 `@simd`，您正在断言循环的几个属性：

  * 在任意或重叠顺序中执行迭代是安全的，特别考虑到归约变量。
  * 对归约变量的浮点操作可以被重排序或收缩，可能导致与没有 `@simd` 时不同的结果。

在许多情况下，Julia 能够在不使用 `@simd` 的情况下自动向量化内部 for 循环。使用 `@simd` 给编译器提供了一些额外的余地，使其在更多情况下成为可能。在任何情况下，您的内部循环应具有以下属性以允许向量化：

  * 循环必须是最内层循环
  * 循环体必须是直线代码。因此，当前所有数组访问都需要 [`@inbounds`](@ref)。如果安全地无条件评估所有操作数，编译器有时可以将短的 `&&`、`||` 和 `?:` 表达式转换为直线代码。如果安全，可以考虑在循环中使用 [`ifelse`](@ref) 函数代替 `?:`。
  * 访问必须具有步幅模式，不能是“聚集”（随机索引读取）或“散布”（随机索引写入）。
  * 步幅应为单位步幅。

!!! 注意     默认情况下，`@simd` 并不断言循环完全没有循环携带的内存依赖关系，这是在通用代码中很容易被违反的假设。如果您正在编写非通用代码，可以使用 `@simd ivdep for ... end` 还可以断言：

  * 不存在循环携带的内存依赖关系
  * 没有迭代会等待先前的迭代以取得前进进展。
