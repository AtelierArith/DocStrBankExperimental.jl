```
colorzones!(shapes::Vector{GMTdataset}[, fun::Function]; img::GMTimage=nothing,
            url::AbstractString="", layer=0, pixelsize::Int=0, append::Bool=true)
```

`shapes`のポリゴンを`img`画像内で占める平均色で塗りつぶします。`shapes`がプロットされると、結果の画像はコロプレスマップのように見えます。代わりに、`img`画像を送信するのではなく、WMS URL、`layer`番号、および`pixelsize`を提供して、各`shapes`ポリゴンのバウンディングボックスをカバーする画像をWebマップサーバーサービスからダウンロードできます。このオプションは、全体の画像を一度に渡すよりもはるかに遅いですが、はるかに少ないメモリを消費します。総面積が大きい場合（ロシアのサイズを考えてみてください）、中程度の解像度でも巨大なファイルをダウンロードすることを意味する可能性があるため、重要です。

### パラメータ

  * `shapes`: 塗りつぶすポリゴンを含むGMTdatasetのベクター。このコンテナは、各ポリゴン（GMTdataset）の`header`フィールドに塗りつぶし色が追加されるという意味で変更されます（ただし、この変更がどのように行われるかを制御する`append`オプションも参照してください）。
  * `fun`: デフォルトでは、平均色は3つの（RGB）バンドの各平方の平均の平方根を取ることによって得られます（またはグレースケール画像の場合は1つだけ）。このデフォルトを置き換えるために別の関数の名前を指定してください。たとえば、`median`は、問題のポリゴン領域内の各コンポーネントの中央値を計算することによって色を割り当てます。
  * `img`: 各ポリゴンの各色の統計（`fun`）が計算される画像。
  * `url`: `img`オプションが使用されない場合、各ポリゴンのバウンディングボックスをカバーする画像がダウンロードされるWebマップサーバーのURLを渡します（`wmsinfo`および`wmsread`関数を参照）。警告、これははるかに遅い方法ですが、ダウンロードする画像が非常に大きくなるリスクがある場合に潜在的に便利です。
  * `layer`: `url`オプションが使用される場合、これは必須となり、WMSサービスによって提供される関心のあるレイヤー番号またはレイヤー名を表します。つまり、`layer=3`または`layer="Invented layer name"`の両方の形式が許可されています。
  * `pixelsize`: メートル単位で要求されるセルサイズを設定します[デフォルト]。解像度が度で指定される場合は、'd'を付加した文字列を使用します（例：`resolution="0.001d"`）。この方法は、レイヤーが地理的な場合にのみ機能します。
  * `append`: デフォルトでは、`shapes`ベクター内の各ポリゴンへの色の割り当ては、既存の可能性のあるヘッダーフィールドに塗りつぶし色を追加することによって達成されます。`colorzones`コマンドを複数回実行すると、色が追加され続けます（現在は無視されます。最初のものだけが使用されるため）。`append=false`を設定すると、各実行時にヘッダーフィールドの書き換えが強制され、したがって割り当てられた色は常に使用されるものになります（ただし、以前のヘッダーはクリアされます）。

参照：`rasterzones!`

### 戻り値

何も返しませんが、入力の`shapes`が変更されます。

### 例

```
ポルトガルの2020年のSentinel2地球色を100m解像度で読み込みます。行政区域を読み込み、それらの中央値の色を計算します。

wms = wmsinfo("http://tiles.maps.eox.at/wms?");
img = wmsread(wms, layer=3, region=(-9.6,-6,36.9,42.2), pixelsize=100);
Pt = gmtread("C:/programs/compa_libs/covid19pt/extra/mapas/concelhos/concelhos.shp");
colorzones!(Pt, median, img=img);
imshow(Pt, proj=:guess)
```
