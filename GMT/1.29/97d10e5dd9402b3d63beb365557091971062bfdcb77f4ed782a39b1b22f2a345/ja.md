```
gmtconvert(cmd0::String="", arg1=nothing, kwargs...)
```

データテーブルから列を変換、貼り付け、または抽出します

## パラメータ

  * **A** | **hcat** :: [Type => Str | []]

    入力ファイルからのレコードは、縦に追加されるのではなく、横に貼り付けられるべきです [デフォルト]。
  * **C** | **n_records** :: [Type => Str]  $Arg = [+lmin][+umax][+i]$

    出力するセグメントのレコード数が指定した基準に一致するもののみを出力します：
  * **D** | **dump** :: [Type => Str | []]   $Arg = [template[+oorig]]$

    複数のセグメントデータの場合、各セグメントを別々の出力ファイルにダンプします。
  * **E** | **first_last** :: [Type => Str | []]   $Arg = [f|l|m|Mstride]$

    興味のある各セグメントの最初と最後のレコードのみを抽出します。
  * **F** | **conn_method** :: [Type => Str | []]   $Arg = [c|n|r|v][refpoint]$

    ポイントの接続方法（スキームを指定）とデータのグループ化方法（メソッドを指定）を変更します。
  * **I** | **invert** | **reverse** :: [Type => Str | Bool]      $Arg = [tsr]$

    アイテムの順序を反転させます。つまり、アイテムを逆順で出力し、最後のアイテムから始めて最初のアイテムで終わります。
  * **L** | **list_only** :: -[Type => Bool]

    すべてのセグメントヘッダーレコードのリストのみを出力し、データレコードは出力しません。
  * **N** | **sort** :: [Type => Str | Number]      $Arg = [-|+]col$

    各セグメントを列colの値に基づいて数値的にソートします。
  * **Q** | **segments** :: [Type => Str]      $Arg =  [~]selection$

    $$
    selection
    $$

    に含まれる番号のセグメントのみを書き込み、他のすべてをスキップします。
  * **S** | **select_hdr** :: [Type => Str]      $Arg =  [~]”search string” or [~]/regexp/[i]$

    指定されたテキスト文字列を含むヘッダーレコードを持つセグメントのみを出力します。
  * **T** | **suppress** | **skip** :: [Type => Str | []]    $Arg = [h|d]$

    出力時に特定のレコードの書き込みを抑制します。セグメントヘッダーを抑制するにはhを追加します [デフォルト]、または重複データレコードを抑制するにはdを追加します。両方のタイプのレコードを抑制するにはT=:hdを使用します。
  * **W** | **word2num** :: [Type => Str | []]      $Arg = [+n]$

    試行テキスト内の各単語を数値に変換し、その値を数値出力列に追加しようとします。
  * **Z** | **transpose** :: [Type => Str | []]      $Arg =  [first][:last]$

    出力を指定されたレコード範囲に制限します。firstが設定されていない場合は、レコード0（最初のレコード）にデフォルト設定され、lastが設定されていない場合は、最後のレコードにデフォルト設定されます。

完全なドキュメントを見るには、次のように入力します： $@? gmtconvert$
