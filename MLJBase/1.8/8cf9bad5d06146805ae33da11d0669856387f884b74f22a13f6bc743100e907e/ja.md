```
MLJBase.fit_only!(
    mach::Machine;
    rows=nothing,
    verbosity=1,
    force=false,
    composite=nothing,
)
```

他の依存するマシンを変更することなく、データとそれにバインドされたモデルを使用して、指定された場合は`rows`にデータを制限しながら、マシン`mach`に対して次のいずれかのアクションを実行します：

  * *アビニシオトレーニング。* 以前に学習したパラメータとキャッシュを無視して、新しい学習パラメータを計算して保存します。`mach.state`をインクリメントします。
  * *トレーニング更新。* 以前に学習したパラメータおよび/またはキャッシュを利用して、既存の学習パラメータを置き換えるか変更します。効果はアビニシオトレーニングと同じ（またはほぼ同じ）ですが、モデルが更新オプションをサポートしている場合（`MLJBase.update`を実装している場合）、より速く、またはメモリを少なく使用する可能性があります。`mach.state`をインクリメントします。
  * *ノーオペレーション。* 既存の学習パラメータを変更せずにそのままにします。`mach.state`をインクリメントしません。

`mach`にバインドされたモデル`model`がシンボルである場合、`getproperty(composite, model)`によって与えられた真のモデルを使用してアクションを実行します。詳細は[`machine`](@ref)を参照してください。

### トレーニングアクションのロジック

アクションがノーオペレーションであるためには、`mach.frozen == true`であるか、次のいずれかが適用されない必要があります：

1. `mach`はこれまでにトレーニングされていない（`mach.state == 0`）。
2. `force == true`。
3. `mach`が依存している他のマシンの`state`が、`mach`が最後にトレーニングされたとき（つまり、`mach.state`が最後にインクリメントされたとき）以来変更されている。
4. 指定された`rows`が最後の再トレーニング以来変更されており、`mach.model`が`Static`型でない。
5. `mach.model`がモデルであり、トレーニングに使用された最後のモデルとは異なるが、同じ型である。
6. `mach.model`がモデルであるが、トレーニングに使用された最後のモデルとは異なる型である。
7. `mach.model`がシンボルであり、`(composite, mach.model)`がトレーニングに使用された最後のモデルとは異なるが、同じ型である。
8. `mach.model`がシンボルであり、`(composite, mach.model)`がトレーニングに使用された最後のモデルとは異なる型である。

いずれの場合（1）-（4）、（6）、または（8）では、`mach`はアビニシオでトレーニングされます。（5）または（7）が真である場合、トレーニング更新が適用されます。

`mach`をフリーズまたはアンフリーズするには、`freeze!(mach)`または`thaw!(mach)`を使用します。

### 実装の詳細

マシンにバインドされたデータは`mach.args`に保存されます。`args`の各要素は、`Node`オブジェクトであるか、マシンに具体的なデータがバインドされている場合は、`Source`ノードでラップされた具体的なデータです。すべての場合において、実際のトレーニングのための具体的なデータを取得するには、各引数`N`が呼び出され、`N()`または`N(rows=rows)`のように呼び出され、`MLJBase.fit`（アビニシオトレーニング）または`MLJBase.update`（トレーニング更新）が`mach.model`およびこのデータに対してディスパッチされます。これらの低レベルのトレーニングメソッドについては、MLJドキュメントの「一般的な使用のためのモデルの追加」セクションを参照してください。
