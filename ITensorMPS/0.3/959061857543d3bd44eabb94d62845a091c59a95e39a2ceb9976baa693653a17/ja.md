```
contract(A::MPO, B::MPO; kwargs...) -> MPO
*(::MPO, ::MPO; kwargs...) -> MPO
```

`MPO` `A`を`MPO` `B`と収束させ、`A`と`B`の間で共有されていないサイトインデックスを持つ`MPO`を返します。

同じインデックスのセットを持つ2つのMPOを収束させる場合は、次のように呼び出すことが望ましいです：

```julia
C = contract(A', B; cutoff=1e-12)
C = replaceprime(C, 2 => 1)
```

これは、MPO `A`がインデックス構造`-s'-A-s-`を持ち、MPO `B`がインデックス構造`-s'-B-s-`を持つ場合、インデックスのセットの上でのみ収束させたい場合、`(-s'-A-s-)'-s'-B-s- = -s''-A-s'-s'-B-s- = -s''-C-s-`となり、次にプライムレベルをペアのプライムおよび非プライムインデックスに戻すために：`replaceprime(-s''-C-s-, 2 => 1) = -s'-C-s-`を行います。

これは一般的な使用ケースであるため、便利な関数を使用できます：

```julia
C = apply(A, B; cutoff=1e-12)
```

これは上記のコードと同じです。

発散するノルムを持つMPOを収束させている場合、例えば局所演算子の和を表すMPOの場合、切り捨てが数値的に不安定になる可能性があります（より数値的に安定した代替手段についてはhttps://arxiv.org/abs/1909.06341を参照してください）。今のところ、次のオプションを使用してそのようなMPOを収束させることができます：

```julia
C = contract(A, B; alg="naive", truncate=false)
# インデックスをペアのプライムおよび非プライムに戻す
C = apply(A, B; alg="naive", truncate=false)
```

# キーワード

  * `cutoff::Float64=1e-14`: 密度行列の固有値を切り捨てるためのカットオフ値。デフォルトはやや恣意的であり、変更される可能性があるため、一般的には`cutoff`値を設定するべきです。
  * `maxdim::Int=maxlinkdim(A) * maxlinkdim(B))`: 結果のMPSの最大ボンド次元。
  * `mindim::Int=1`: 結果のMPSの最小ボンド次元。
  * `alg="zipup"`: `"zipup"`または`"naive"`のいずれか。`"zipup"`はサイトテンソルのペアを収束させ、サイトを横断してSVDで切り捨てますが、`"naive"`は最初にテンソルのペアを正確に収束させ、`truncate=true`の場合に最後に切り捨てます。
  * `truncate=true`: 切り捨てを有効または無効にします。`truncate=false`の場合、`cutoff`や`maxdim`のような他の切り捨てパラメータは無視されます。これは`"naive"`バージョンに最も関連しており、テンソルをペアごとに正確に収束させたい場合に便利です。これは、局所演算子の和から派生したMPOのように、発散するノルムを持つMPOを収束させる場合に役立ちます。

利用可能な引数の詳細については、[`apply`](@ref)も参照してください。
